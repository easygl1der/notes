<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[大二下作业]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib\media\favicon.png</url><title>大二下作业</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 23 May 2025 11:38:07 GMT</lastBuildDate><atom:link href="lib\rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 23 May 2025 11:19:42 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[有限群表示论]]></title><description><![CDATA[ 
 <br><br>参见肖梁, Artin, Dummit.<br>A matrix representation of a group  is a homomorphism<br><br>from  to one of the complex general linear groups. The number  is the dimension of the representation.<br>We use the notation  instead of  for the image of a group element . Each  is an invertible matrix, and the statement that  is a homomorphism reads<br><br>If a group is given by generators and relations, say , a matrix representation can be defined by assigning matrices  that satisfy the relations. For example, the symmetric group  can be presented as , so a representation of  is defined by matrices  and  such that , and . Some relations in addition to these required ones may hold.<br><br><img alt="有限群表示论-2025032521.png" src="lib\media\有限群表示论-2025032521.png"><br>
<img alt="1-有限群表示论-2025032521.png" src="lib\media\1-有限群表示论-2025032521.png"><br>
<img alt="2-有限群表示论-2025032521.png" src="lib\media\2-有限群表示论-2025032521.png"><br>
<img alt="3-有限群表示论-2025032521.png" src="lib\media\3-有限群表示论-2025032521.png"><br>
<img alt="4-有限群表示论-2025032521.png" src="lib\media\4-有限群表示论-2025032521.png"><br>
<img alt="5-有限群表示论-2025032521.png" src="lib\media\5-有限群表示论-2025032521.png"><br>
If  is finite, then any finite dimensional representation  is "completely reducible".<br>
<img alt="6-有限群表示论-2025032521.png" src="lib\media\6-有限群表示论-2025032521.png"><br>
<img alt="7-有限群表示论-2025032521.png" src="lib\media\7-有限群表示论-2025032521.png"><br>
<img alt="8-有限群表示论-2025032521.png" src="lib\media\8-有限群表示论-2025032521.png"><br>
<img alt="9-有限群表示论-2025032521.png" src="lib\media\9-有限群表示论-2025032521.png">
<br><br><img alt="有限群表示论-2025032601.png" src="lib\media\有限群表示论-2025032601.png"><br>
<img alt="1-有限群表示论-2025032601.png" src="lib\media\1-有限群表示论-2025032601.png"><br><br>There is a natural question: can we find a "good" matrix representation for a given representation  of ? Here "good" means there is a positive definite Hermitian form on  so that every  preserves this Hermitian form; and thus the image of  in  belongs to the unitary group .<br>Let  be a Hermitian space -- a complex vector space together with a positive definite Hermitian form . A unitary operator  on  is a linear operator with the property<br><br>A representation  on a Hermitian space  is called unitary if  is a unitary operator for every . We can write this condition as<br><br>Similarly, a matrix representation  is unitary if . A unitary matrix representation is a homomorphism from  to the unitary group:<br><br>Lemma.
Let  be a unitary representation of  on a Hermitian space , and let  be a -invariant subspace. The orthogonal complement  is also -invariant, and  is the direct sum of its restrictions to the Hermitian spaces  and . These restrictions are also unitary representations.
<br>Proof.<br>
It is true that . Since  is unitary, it preserves orthogonality: If  is invariant and , then . This means that if , then .<br>
□<br><br>In matrix terminology, two representation  and  are equivalent if there is a fixed invertible matrix  such that<br><br>In  -module terminology, two representation  and  are equivalent if there is a fixed  -module isomorphism  such that<br><br>The linear transformation  or the matrix  above is said to interwine the representation  and . <br><br>Because they involve several matrices, each of which may have many entries, representations are notationally complicated. The secret to understanding them is to throw out most of the information that the matrices contain, keeping only one essential part, its trace, or character.<br>Our slogan is: characters determine the representation.<br>
<img alt="有限群表示论-2025032522.png" src="lib\media\有限群表示论-2025032522.png"><br>
<img alt="1-有限群表示论-2025032522.png" src="lib\media\1-有限群表示论-2025032522.png"><br>
<img alt="2-有限群表示论-2025032522.png" src="lib\media\2-有限群表示论-2025032522.png"><br>
<img alt="3-有限群表示论-2025032522.png" src="lib\media\3-有限群表示论-2025032522.png"><br>
<img alt="4-有限群表示论-2025032522.png" src="lib\media\4-有限群表示论-2025032522.png"><br><br>For , we have three representaions, ,  and . <br><br><br><br>Then the characters of these representations are displayed below in tabular form.<br><br>Several interesting phenomena can be observed in this table:<br>
<br>The rows form orthogonal vectors of length equal to six, which is also the order of . The columns are orthogonal too.
<br> is the dimension (degree) of the representation, also called the dimension of the character.

<br>Since a representation is a homomorphism, it sends the identity in the group to the identity matrix. So  is the trace of the identity matrix.


<br>The characters are constant on conjugacy classes.

<br>The conjugacy classes in  are the sets , and .
<br>This is because conjugate matrices has the same trace. ()


<br><br><img alt="5-有限群表示论-2025032522.png" src="lib\media\5-有限群表示论-2025032522.png"><br>
<img alt="6-有限群表示论-2025032522.png" src="lib\media\6-有限群表示论-2025032522.png"><br>
<img alt="7-有限群表示论-2025032522.png" src="lib\media\7-有限群表示论-2025032522.png"><br>
<img alt="1-有限群表示论-2025032608.png" src="lib\media\1-有限群表示论-2025032608.png"><br>
<img alt="有限群表示论-2025032608.png" src="lib\media\有限群表示论-2025032608.png"><br>
<img alt="2-有限群表示论-2025032608.png" src="lib\media\2-有限群表示论-2025032608.png">]]></description><link>表示论\有限群表示论.html</link><guid isPermaLink="false">表示论/有限群表示论.md</guid><pubDate>Sun, 04 May 2025 15:11:49 GMT</pubDate><enclosure url="lib\media\有限群表示论-2025032521.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\有限群表示论-2025032521.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[FG-modules]]></title><description><![CDATA[ 
 <br><br>
See Representations and Characters of Groups (Gordon James, Martin Liebeck) 
<br>We will show that there is a connection between  -modules and representations of  over .<br>Let  be a group and let  be  or .<br>Suppose that  is a representation of . Write , as the vector space. For all  and , the matrix product<a data-footref="[inline0" href="about:blank#fn-1-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a><br><br>is a row vector in . <br>Now we list some basic properties <br><br><br><br><br><img alt="FG-modules-2025050119.png" src="lib\media\fg-modules-2025050119.png"><br>
Motivatied by the above observations on the product , we now define an  -modules.<br>Definition (-module).
Let  be a vector space over  and let  be a group. Then  is an -module if a multiplication  is defined, satisfying the following conditions for all  and  :

<br>;
<br>;
<br>;
<br>;
<br>.<br>


<br>Definition (Matrix representation).
Let  be an -module, and let  be a basis of . For each , let

denote the matrix of the endomorphism  of , relative to the basis .
<br>If  is a representation of  over , and , then  becomes an  -module if we define the multiplication  by <br><br>Moreover, there is a basis  of  such that<br><br>On the other hand, assume that  is an  -module and let   a basis of . Then the function<br><br>is a representation of  over .<br><img alt="FG-modules-2025050120.png" src="lib\media\fg-modules-2025050120.png"><br>
<img alt="1-FG-modules-2025050120.png" src="lib\media\1-fg-modules-2025050120.png"><br>Definition (faithful).
An -module  is faithful if the identity element of  is the only element  for which

<br>For instance, the  -module which appears in Example  is faithful.<br>Our next aim is to construct faithful  -modules by the basis for all subgroups of symmetric groups.<br>Definition (Permutation module).
Let  be a subgroup of . The -module  with basis  such that

is called the permutation module for  over . We call  the natural basis of .
<br><img alt="2-FG-modules-2025050120.png" src="lib\media\2-fg-modules-2025050120.png"><br><img alt="3-FG-modules-2025050120.png" src="lib\media\3-fg-modules-2025050120.png"><br><br>Exercise.
<img alt="4-FG-modules-2025050120.png" src="lib\media\4-fg-modules-2025050120.png">
<br>When , then . When , then <br><br><br><br><br><br>Now let , , . Then<br><br><br>Then<br><br><br>Omitted....<br>Exercise.
<img alt="5-FG-modules-2025050120.png" src="lib\media\5-fg-modules-2025050120.png">
<br>Let . Then<br><br>Check that  is a  -module. NTS:  is a representation of , i.e. <br><br>which is routine.<br><br><br>Definition ( -submodule).
Let  be an  -module. A subset  of  is said to be an  -submodule of  if  is a subspace and  for all  and all .
<br><img alt="FG-modules-2025050121.png" src="lib\media\fg-modules-2025050121.png"><br>
<img alt="1-FG-modules-2025050121.png" src="lib\media\1-fg-modules-2025050121.png"><br>Definition (Irreducible FG-module).
An irreducible FG-module  is said to be irreducible if it is non-zero and it has no -submodules apart from  and .
<br><img alt="FG-modules-2025050122.png" src="lib\media\fg-modules-2025050122.png"><br><img alt="1-FG-modules-2025050122.png" src="lib\media\1-fg-modules-2025050122.png"><br>
<img alt="2-FG-modules-2025050122.png" src="lib\media\2-fg-modules-2025050122.png"><br>
<img alt="3-FG-modules-2025050122.png" src="lib\media\3-fg-modules-2025050122.png"><br><img alt="4-FG-modules-2025050122.png" src="lib\media\4-fg-modules-2025050122.png"><br><br>Omitted....<br>
<br>
<br><a href="about:blank#fnref-1-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>表示论\fg-modules.html</link><guid isPermaLink="false">表示论/FG-modules.md</guid><pubDate>Fri, 02 May 2025 08:58:54 GMT</pubDate><enclosure url="lib\media\fg-modules-2025050119.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\fg-modules-2025050119.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Group algebra]]></title><description><![CDATA[ 
 <br><br>The group algebras are the source of all you need to know about representatio theory. In particular, the ultimate goal of representation theory -- that of understanding all the representations of finite groups -- would be achieved if group algebras could be fully analysed.<br>Definition.
Let  be a finite group and  be  or . The vector space , with the natural multiplication , is called the regular  -module. 
The representation  obtained by taking  to be the natural basis of  is called the regular representation of  over .
<br>Definition (group algebra).
The vector space , with multiplication defined by

is called the group algebra of  over .
<br>Recall that an  -module is a vector space over , together with a multiplication  for  and . Now we can expend the definition of the multiplication so that we have an element  of  for all elements  in the group algebra .<br>Suppose that  is an  -module, and that  and ; say <br><br>Define  by <br><br><br>Omitted...]]></description><link>表示论\group-algebra.html</link><guid isPermaLink="false">表示论/group-algebra.md</guid><pubDate>Fri, 02 May 2025 08:58:54 GMT</pubDate></item><item><title><![CDATA[group-representation]]></title><description><![CDATA[ 
 <br><br> is a finite group.<br><br>Let  be a 1-dimensional vector space over  and make  into an  -module by letting  for all  and . This module affords the representation<br><br>to be trivial, i.e. taking  to  (the  identity matrix). The trivial representation has degree 1 and if , it is not faithful.<br><br>Let  be a  -module, then  affords a representation<br><br>where .  has degree equal to , and it's always faithful. The matrix  has a 1 in row  and column  if , and has 0's in all other positions.<br><br>Let ,  be an  -dimensional vector space over  with basis . Let  act on  by defining for each <br><br>This provides an injective homomorphism of  into . Hence  is an  -module.  has a 1 in row  and column  if .<br><br>If  is any representation of  and  is any group homomorphism, then the composition  is a representation of . <br><br>Any homomorphism of  into the multiplication group  is a degree 1 (matrix) representation. <br>For example, suppose  is the cyclic group of order  and  is a fixed  root of 1 in . Let , for all . This representation of  is a faithful representation if and only if  is a primitive  root of 1.<br><br>For , it has the faithful representation<br><br><br>For , it has the faithful  -linear representation <br><br>And a 4-dimensional faithful  -linear representation is given by<br><br>
Let , , .
<br><br>Suppose  and  is an elementary abelian  -group for some prime . Let  be a vector space over , where scalar  acts on the group element  by . The conjugation action of  on  is  -linear because<br><br>Then  is an  -module. The kernel of thsi representation is . <br><br>See Representations and Characters of Groups Gordon James.<br><br>Let . Define the matrices  over  by<br><br>Prove that each of the functions , given by<br><br>is a representation of . Which of these representations are faithful? Which are equivalent?<br>
Proof.<br>
It suffices to check that <br><br>which is routine. Since<br><br> are faithful. <br><br>Since their matrix representations have the same Jordan Canonical form.<br>
□<br><br>Let  be the dihedral group  . Define the matrices  and  by<br><br>And check that<br><br>It follows (see Example 1.4) that the function  which is given by<br><br>is a representation of  over . The degree of  is .<br>The matrices  for  in  are given in the following table:<br><br>Let <br><br>Then <br><br>So we obtain another representation  of  for which <br><br><br>Let  be a representation of the group . Suppose that  and  are elements of  such that . Does it follow that <br><br>If  is faithful then . Otherwise,  may not commute.<br><br>Exercise (Yau-2024).
<img alt="group-representation-2025050411.png" src="lib\media\group-representation-2025050411.png">
<br>(1)<br>
, . Let  be a  -vector space whose basis is . The dimension of  is . More formally,<br><br> is a finite vector space over . Define the mapping (we will show that it's a representation), <br><br>where . We can extend the action linearly to any , by letting<br><br>To show that it's a homomorphism, we have<br><br>To show that the representation is faithful, consider the kernel<br><br>For , <br><br>Then we have <br><br>Thus . The representation is faithful.<br>(2)<br>
If  is cyclic with order , and , then the mapping<br><br>is a faithful representation.<br>If  has a faithful one-dimensional complex representation, <br><br>, then . Thus every  lies in the set of  roots of unity, which has size . Since  is faithful,  for . Then  is cyclic. Hence  is cyclic.<br>(3)<br>
If  can be generated by , then for any , we have<br><br>Assume that  for every , then the mapping<br><br>is a faithful  -dimensional complex representation.<br>If  has a faithful  -dimensional complex representation,<br><br> can be a diagonized matrix.<br>
....<br>(4)<br>
具有忠实的二维实表示的有限群的分类如下：<br>
<br>循环群 （ n 阶循环群），对于任意  。
<br>二面体群 （ 2 m 阶二面体群，即正 m 边形的对称群），对于任意  。
<br>Remark.
Let  be a finite dimensional -representation of a finite group . Consider the -invariant subspace


<br>Show that  is the same as the multiplicity of the trivial representation appearing in .
<br>Show that .
<br>Construct a surjective map , expressed in terms of a linear combination of linear operators  for , such that  (i.e.  is a projection) and  is a homomorphism.

<br><img alt="group-representation-2025051012.png" src="lib\media\group-representation-2025051012.png"><br>
<img alt="1-group-representation-2025051012.png" src="lib\media\1-group-representation-2025051012.png">]]></description><link>表示论\group-representation.html</link><guid isPermaLink="false">表示论/group-representation.md</guid><pubDate>Sat, 10 May 2025 04:22:36 GMT</pubDate><enclosure url="lib\media\group-representation-2025050411.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\group-representation-2025050411.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Representation Theory and Character Theory]]></title><description><![CDATA[ 
 <br><br><br> is a ring,  is a group then the group ring  is defined by<br><br>with the following properties:<br><br><br> is a commutative ring iff  is an abelian group. <br> is a vector space over  with the elements of  as a basis. ()<br><img alt="Representation Theory and Character Theory-2025040114.png" src="lib\media\representation-theory-and-character-theory-2025040114.png"><br>Formally, a representation  is faithful if the only element of  that is mapped to the identity transformation is the identity element of , i.e.,<br><br>where  is the identity element of .<br><br><img alt="Representation Theory and Character Theory-2025040115.png" src="lib\media\representation-theory-and-character-theory-2025040115.png"><br><img alt="1-Representation Theory and Character Theory-2025040115.png" src="lib\media\1-representation-theory-and-character-theory-2025040115.png"><br>An  -module is finitely generated iff it is finite dimensional.<br><br><img alt="2-Representation Theory and Character Theory-2025040115.png" src="lib\media\2-representation-theory-and-character-theory-2025040115.png"><br>
<img alt="3-Representation Theory and Character Theory-2025040115.png" src="lib\media\3-representation-theory-and-character-theory-2025040115.png"><br><br><img alt="4-Representation Theory and Character Theory-2025040115.png" src="lib\media\4-representation-theory-and-character-theory-2025040115.png"><br>
<img alt="5-Representation Theory and Character Theory-2025040115.png" src="lib\media\5-representation-theory-and-character-theory-2025040115.png"><br><br><img alt="6-Representation Theory and Character Theory-2025040115.png" src="lib\media\6-representation-theory-and-character-theory-2025040115.png">]]></description><link>表示论\representation-theory-and-character-theory.html</link><guid isPermaLink="false">表示论/Representation-Theory-and-Character-Theory.md</guid><pubDate>Sun, 04 May 2025 03:01:58 GMT</pubDate><enclosure url="lib\media\representation-theory-and-character-theory-2025040114.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\representation-theory-and-character-theory-2025040114.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Tensor product]]></title><description><![CDATA[ 
 <br><br>Let  and  be vector spaces over  with bases  and , respectively. For each  with , we introduce a symbol . The tensor product space  is defined to be the mn-dimensional vector space over  with a basis given by<br><br>Thus  consists of all expressions of the form<br><br>For  and  with  and  , we define  by<br><br>For example,<br><br>Do not be misled by the notation into believing that every element of  has the form , but linear combination of .<br>If  and , then<br><br>If  and , then<br><br>Next, we deine the tensor product of two  -modules. <br>Let  be a finite group and let  and  be  -modules with bases  and , respectively. We know that the elements<br><br>give a basis of . The multiplication of  by an element of  is defined in the following simple way, which is then extended linearly to a multiplication on the whole of .<br>Let . For all , , define<br><br>and, more generally, let <br><br>for arbitrary complex numbers .<br>Remark.
You should be warned that  for most elements  in , e.g. when  is a scalar multiple of .
<br><br>See dummit&amp;Foote Sec 10.4<br>Definition (-module).
Let  be a ring (associative with 1). An -module (or left -module) is an abelian group  together with an operation , denoted by , such that for all  and :

A right -module is defined similarly, with the scalar multiplication on the right , denoted by , satisfying analogous axioms.
<br>Our aim is to "extend" an  -module  to an  -module. <br>To satisfy the relations necessary for an  -module structure<a data-footref="[inline0" href="about:blank#fn-1-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a> and the compatibility relation with the action of  on  <a data-footref="[inline1" href="about:blank#fn-2-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[2]</a>, we must take the quotient of this abelian group by the subgroup  generated by all elements of the form<br><br>The resulting quotient group is denoted by  (or jest  if  is clear from the context) and is called the tensor product of  and  over . By the definition of the quotient we have forced the relations<br><br>Definition (universal property for the tensor product).
<img alt="tensor-product-2025050211.png" src="lib\media\tensor-product-2025050211.png">
<br>Example.
<img alt="1-tensor-product-2025050211.png" src="lib\media\1-tensor-product-2025050211.png">
<br>Definition ( -balanced).
<img alt="tensor-product-2025050214.png" src="lib\media\tensor-product-2025050214.png">
<br>Definition ( -bilinear).
<img alt="1-tensor-product-2025050214.png" src="lib\media\1-tensor-product-2025050214.png">
<br>Example.
We have , since  for  so that<br>
and every simple tensor is reduced to 0. In particular . 
<br>Example.
We have , since  and  generates . 
<br>Example.
, where a simple tensor has the form  for some rational numbers  and . Then

<br>Example.
Similar to <a data-href="#^d2f1db" href="about:blank#^d2f1db" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^d2f1db</a><a data-href="#^d2f1db" href="about:blank#^d2f1db" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Example 9</a>,  for any divisible abelian group  and torsion abelian group  (an abelian group in which every element has finite order). For exmaple, .
<br>Example (dimension).
The structure of a tensor product can vary considerably depending on the ring over which the tensors are taken.  and  are isomorphic as left  -modules (both are one dimensional vector spaces over ). Pick any simple tensor  in , then<br>
induces an isomorphism between  and . Pick any simple tensor  in , then<br>
Thus . Hence,<br>

<br>Example.
On the other hand,  and  are not isomorphic  -modules (the former is a 1-dimensional vector space over  and the latter is 2-dimensional over ). Every simple tensor in  has the form , then<br>
induces an isomorphism between  and . Every simple tensor in  has the form , then<br>
induces an isomorphism between  and . Hence<br>

<br><br><a data-tooltip-position="top" aria-label="https://math.stackexchange.com/questions/4306709/dimension-of-a-tensor-product-as-a-vector-space-over-complex-number-field-math" rel="noopener nofollow" class="external-link" href="https://math.stackexchange.com/questions/4306709/dimension-of-a-tensor-product-as-a-vector-space-over-complex-number-field-math" target="_blank">abstract algebra - Dimension of a tensor product as a vector space over complex number field <span class="math math-inline is-loaded"></span> - Mathematics Stack Exchange</a><br>Exercise.
Problem 2 (10 points). Consider the polynomial ring  and its subring .
Consider  -modules

What is the dimension as  -vector space of each tensor product below? No need to prove or explain.
<br>(a) ;<br> has every simple tensor of the form , then<br><br>induces an isomorphism between  and  (the construction is left as an exercise). Therefore <br><br>(b) ;<br> has every simple tensor of the form , then<br><br>induces a nature isomorphism between  and . Therefore,<br><br>(c) .<br> has every simple tensor of the form , then<br><br>induces a nature isomorphism between  and . Therefore,<br><br>We are done!<br>
<br>
<br>, .<a href="about:blank#fnref-1-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
<br><a href="about:blank#fnref-2-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>表示论\tensor-product.html</link><guid isPermaLink="false">表示论/tensor-product.md</guid><pubDate>Sat, 03 May 2025 08:57:09 GMT</pubDate><enclosure url="lib\media\tensor-product-2025050211.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\tensor-product-2025050211.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[复变函数的积分]]></title><description><![CDATA[ 
 <br><br>其实就是关于某个参数  进行积分<br><br>柯西积分公式：若  在一个包含圆周  的区域内全纯，那么对于任意  内的  点，有<br><br>这个公式具有极其广泛的应用场景，比如计算导数，估计不等式....<br><a data-href="#^b51110" href="about:blank#^b51110" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^b51110</a><a data-href="#^b51110" href="about:blank#^b51110" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a> 的证明思路就是类似于调和方程的平均值公式证明<br><br>对于 <a data-href="#^b51110" href="about:blank#^b51110" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^b51110</a><a data-href="#^b51110" href="about:blank#^b51110" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a> 两边同时求  阶导数得到<br><br>这只需要根据导数的定义归纳验证导数的存在性即可.<br>柯西不等式 <a data-href="#^4ec030" href="about:blank#^4ec030" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^4ec030</a><a data-href="#^4ec030" href="about:blank#^4ec030" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (3)</a> 是 <a data-href="#^e4a292" href="about:blank#^e4a292" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^e4a292</a><a data-href="#^e4a292" href="about:blank#^e4a292" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (2)</a> 的直接推论<br><br>进一步我们有复变函数的幂级数表示<br><br>同时还有 Liouville 定理：若  全纯且有界，那么  是常值函数. (直接利用 <a data-href="#^e4a292" href="about:blank#^e4a292" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^e4a292</a><a data-href="#^e4a292" href="about:blank#^e4a292" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (2)</a> )<br><br>然后可以证明代数基本定理.<br>根据幂级数表示 <a data-href="#^945f8c" href="about:blank#^945f8c" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^945f8c</a><a data-href="#^945f8c" href="about:blank#^945f8c" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (4)</a>  可以证明复变函数的零点集是离散的.<br><br>参见《复变函数论 》(第五版) 学习指导书 (钟玉泉编).<br>已知 Jordan 不等式<br><br>证明：<br><br>其中  为圆周  的上半圆周从  到 .<br>选取参数化 . 于是<br><br>Remark.
不等式 <a data-href="#^3ab879" href="about:blank#^3ab879" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^3ab879</a><a data-href="#^3ab879" href="about:blank#^3ab879" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (5)</a>  是一个重要不等式. 可以用来放缩很多围道积分（用来证明 Jordan 引理 ）
<br>Exercise.
若 ，其中  是从  到  沿  的上半圆周，证明：<br>

<br>Proof.<br>
 时，直接利用 <a data-href="#^3ab879" href="about:blank#^3ab879" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^3ab879</a><a data-href="#^3ab879" href="about:blank#^3ab879" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (5)</a> 放缩<br><br> 时，利用留数定理显然，或者直接放缩估计 .<br>□<br><br><br>柯西积分定理对于解析函数  的实部和虚部都不成立.<br>对于一般的题目，正常计算即可. 注意先将分母有理化，再判断奇点是否在积分曲线内部.<br>下面介绍一种思想：<br>
<img alt="复变函数的积分-2025040601.png" src="lib\media\复变函数的积分-2025040601.png">]]></description><link>复变函数\复变函数的积分.html</link><guid isPermaLink="false">复变函数/复变函数的积分.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\复变函数的积分-2025040601.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\复变函数的积分-2025040601.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[复分析脉络]]></title><description><![CDATA[ 
 <br>见 Rudin 《实分析与复分析》<br><br>A region is  nonempty connected open subset of . Each open set  in the plane is union of discs. For  if  exists then denote it . If  exists , say .  is the class of all holomorphic functions in , which is a ring. If  is representable by power series in , then  and  is also representable. Check the convergence by evaluate<br><br>Fix , and choose  s.t., where . For , if  then<br><br>Then<br><br>An general result is for complex (finite) measure on a measurable space ,  is a plex measurable function on ,  is an open set in the plane which does not intersect  and <br><br>Then  is representable by power series in . <br>The proof is from the fact that for , every ,<br><br>Converges uniformly on . Then<br><br>Suppose  a path,  a continuous function defined on  (the range of ), then <br><br> is unique under continuously differentaible one-to-one mapping.<br>Let  be a closed path,  the complement of , and define<br><br>Then  is an integer-valued function on  which is constant in each component of  and which is 0 in the unbounded component of .<br>
We call  the index of  w.r.t. , which is "the number of times  winds around ".
<br><img alt="复分析脉络-2025040416.png" src="lib\media\复分析脉络-2025040416.png"><br>
<img alt="2-复分析脉络-2025040416.png" src="lib\media\2-复分析脉络-2025040416.png"><br>
<img alt="1-复分析脉络-2025040416.png" src="lib\media\1-复分析脉络-2025040416.png"><br>The easy consequence of the above theorem is the representability of holomorphic functions by power series.<br>The Cauchy theorem has a useful convers:<br>
<img alt="3-复分析脉络-2025040416.png" src="lib\media\3-复分析脉络-2025040416.png"><br>
Next we consider the power series representation of holomorphic functions. Suppose  a region,  and . Then either  or  has no limit point in . In the later case  such that  for , where  and . Furthermore,  is at most countable.<br>Analogous results hold of course ofor the set of  -points of , i.e. the zero set of . <br><img alt="4-复分析脉络-2025040416.png" src="lib\media\4-复分析脉络-2025040416.png"><br><img alt="5-复分析脉络-2025040416.png" src="lib\media\5-复分析脉络-2025040416.png"><br><img alt="7-复分析脉络-2025040416.png" src="lib\media\7-复分析脉络-2025040416.png"><br><img alt="8-复分析脉络-2025040416.png" src="lib\media\8-复分析脉络-2025040416.png"><br><img alt="9-复分析脉络-2025040416.png" src="lib\media\9-复分析脉络-2025040416.png"><br><img alt="10-复分析脉络-2025040416.png" src="lib\media\10-复分析脉络-2025040416.png"><br>The proof is routine since<br><br>Here are some consequences:<br>Theorem (Liouvill's theorem).
Every bounded entire function is constant.
<br>Proof.<br>
Suppose  entire,  for all ,  for all . Then<br><br>for all , which is possible only if .<br>
□<br>
<img alt="11-复分析脉络-2025040416.png" src="lib\media\11-复分析脉络-2025040416.png"><br><br><img alt="12-复分析脉络-2025040416.png" src="lib\media\12-复分析脉络-2025040416.png"><br><br><img alt="13-复分析脉络-2025040416.png" src="lib\media\13-复分析脉络-2025040416.png"><br>利用柯西积分公式可以给出如下定理的证明.<br><img alt="14-复分析脉络-2025040416.png" src="lib\media\14-复分析脉络-2025040416.png"><br><br><img alt="15-复分析脉络-2025040416.png" src="lib\media\15-复分析脉络-2025040416.png"><br>Every nonconstant holomorphic function in a region is locally of the form  (), except for an additive constant.<br><img alt="16-复分析脉络-2025040416.png" src="lib\media\16-复分析脉络-2025040416.png"><br><img alt="17-复分析脉络-2025040416.png" src="lib\media\17-复分析脉络-2025040416.png"><br><br><br><img alt="20-复分析脉络-2025040416.png" src="lib\media\20-复分析脉络-2025040416.png"><br>
<img alt="复分析脉络-2025040417.png" src="lib\media\复分析脉络-2025040417.png"><br><br><img alt="18-复分析脉络-2025040416.png" src="lib\media\18-复分析脉络-2025040416.png"><br><img alt="19-复分析脉络-2025040416.png" src="lib\media\19-复分析脉络-2025040416.png"><br><br><img alt="10-复分析脉络-2025040417.png" src="lib\media\10-复分析脉络-2025040417.png"><br>
<img alt="6-复分析脉络-2025040417.png" src="lib\media\6-复分析脉络-2025040417.png"><br>
<img alt="7-复分析脉络-2025040417.png" src="lib\media\7-复分析脉络-2025040417.png"><br>
<img alt="8-复分析脉络-2025040417.png" src="lib\media\8-复分析脉络-2025040417.png"><br>
<img alt="9-复分析脉络-2025040417.png" src="lib\media\9-复分析脉络-2025040417.png"><br><br><br><img alt="1-复分析脉络-2025040417.png" src="lib\media\1-复分析脉络-2025040417.png"><br><br><img alt="2-复分析脉络-2025040417.png" src="lib\media\2-复分析脉络-2025040417.png"><br>For , .<br><br>The first one concerns zeros of holomorphic functions, the second is the evaluation of a certain integral.<br><img alt="3-复分析脉络-2025040417.png" src="lib\media\3-复分析脉络-2025040417.png"><br><img alt="4-复分析脉络-2025040417.png" src="lib\media\4-复分析脉络-2025040417.png"><br>
 在  处的极点阶数恰恰等于其在  处的留数.
<br><img alt="5-复分析脉络-2025040417.png" src="lib\media\5-复分析脉络-2025040417.png">]]></description><link>复变函数\复分析脉络.html</link><guid isPermaLink="false">复变函数/复分析脉络.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\复分析脉络-2025040416.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\复分析脉络-2025040416.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[共形映射]]></title><description><![CDATA[ 
 <br><br>See Dennis Zill. Appendex III for Table of Conformal Mappings<br><img alt="共形映射-2025051501.png" src="lib\media\共形映射-2025051501.png"><br>
Some examples of conformal mapping:<br>
<br>Translations: , where  is a complex number.
<br>Rotations: , where  is a real number.
<br>Dilations (or scalings): , where  is a real number.
<br>Inversion: , .
<br>Linear transformations: , where  are complex numbers and .
<br>Möbius transformations (or linear fractional transformations): , where  are complex numbers and .
<br><img alt="1-共形映射-2025051501.png" src="lib\media\1-共形映射-2025051501.png"><br>
<img alt="2-共形映射-2025051501.png" src="lib\media\2-共形映射-2025051501.png"><br>Definition (Simply Connected Domain).
A domain  is simply connected if it is connected and every closed curve in  can be continuously deformed to a point in .
<br>Then we introduce the Riemann Mapping Theorem:<br>
<img alt="3-共形映射-2025051501.png" src="lib\media\3-共形映射-2025051501.png"><br><img alt="4-共形映射-2025051501.png" src="lib\media\4-共形映射-2025051501.png"><br>Linear fractional transformations are also called Möbius transformations or bilinear transformations.<br>
<img alt="5-共形映射-2025051501.png" src="lib\media\5-共形映射-2025051501.png"> <br><img alt="6-共形映射-2025051501.png" src="lib\media\6-共形映射-2025051501.png"><br><img alt="7-共形映射-2025051501.png" src="lib\media\7-共形映射-2025051501.png"><br><br><img alt="8-共形映射-2025051501.png" src="lib\media\8-共形映射-2025051501.png"><br>
<img alt="9-共形映射-2025051501.png" src="lib\media\9-共形映射-2025051501.png"><br>
This matrix is called the adjoint matrix of .<br><img alt="10-共形映射-2025051501.png" src="lib\media\10-共形映射-2025051501.png"><br><br><img alt="11-共形映射-2025051501.png" src="lib\media\11-共形映射-2025051501.png"><br>
<img alt="12-共形映射-2025051501.png" src="lib\media\12-共形映射-2025051501.png"><br><br><img alt="14-共形映射-2025051501.png" src="lib\media\14-共形映射-2025051501.png"><br>
<img alt="15-共形映射-2025051501.png" src="lib\media\15-共形映射-2025051501.png"><br>
<img alt="16-共形映射-2025051501.png" src="lib\media\16-共形映射-2025051501.png"><br><br>See Section 7.3....<br><br>See Section 7.4....<br><br>See Section 7.5....<br><br>The expression  has several important special properties in complex analysis, especially when  is a point within the unit disk (i.e., ). This expression is commonly known as a Blaschke factor (or a component thereof) and is also a type of Möbius transformation.<br>Here are some of its key properties:<br>
<br>Maps the unit disk to itself: If , this transformation maps the open unit disk  to itself. That is, if , then .
<br>Maps the unit circle to itself: If , this transformation also maps the unit circle  to itself. That is, if , then .
<br>Zero: The transformation has a zero at . That is, when , .
<br>Pole: The transformation has a pole at . If , then , so this pole lies outside the unit disk.
<br>Conformal automorphism: When , this expression (or when multiplied by a constant  with modulus 1) is a conformal automorphism of the unit disk onto itself (i.e., a biholomorphic map). This means it preserves angles and is a one-to-one and onto mapping.
<br>Inverse Transformation: If , its inverse transformation is . This can be seen as a transformation of the same form, , where the parameter  replaces  and the sign in the denominator is adjusted (or more precisely, it is  if we rewrite  as ).
<br>Derivative at : Let . Its derivative at  is . This property is relevant in contexts such as Schwarz's Lemma.
<br>In summary, this expression defines a very important complex transformation that plays a central role in the geometry and function theory of the unit disk. It allows for a standardized way to map any point  inside the unit disk to the origin, while preserving the disk and its boundary, which is fundamental in many areas of complex analysis.<br><br>Exercise.
设 , 若  使得 , 求全部 .
<br>Proof.<br>
若  在  有无穷个零点, 则若零点在  内部有聚点, 则解析函数唯一性告诉我们 , 这不可能, 若这些零点的聚点只在  边界, 那么  在聚点处应该为 0, 这也不可能. 所以我们知道  在  只有有限个零点 , 这里  允许有相同的项出现.<br>考虑无零点函数<br><br>显然  且 . 故由最大模定理知 . 因此我们知道  为常数, 所以<br><br>□]]></description><link>复变函数\共形映射.html</link><guid isPermaLink="false">复变函数/共形映射.md</guid><pubDate>Mon, 19 May 2025 13:49:11 GMT</pubDate><enclosure url="lib\media\共形映射-2025051501.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\共形映射-2025051501.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[解析函数]]></title><description><![CDATA[ 
 <br><br><br>
<br>判定可微
<br>判定不可微
<br>C-R 方程
<br> 在  解析   在  可微
<br> 在  解析   在  可微

<br>存在可微但不解析的点
<br>解析是一个局部的概念，指的是在  附近都可微
<br>可微是一个点态的概念


<br>极坐标形式的 C-R 方程
<br>若  则 .
<br>洛必达法则
<br>Exercise (在  可微但不解析).
<img alt="4-解析函数-20250320.png" src="lib\media\4-解析函数-20250320.png">
<br><img alt="5-解析函数-20250320.png" src="lib\media\5-解析函数-20250320.png"><br>Remark (对比).
<img alt="解析函数-20250320.png" src="lib\media\解析函数-20250320.png">
<img alt="1-解析函数-20250320.png" src="lib\media\1-解析函数-20250320.png">
<br><img alt="3-解析函数-20250320.png" src="lib\media\3-解析函数-20250320.png"><br><br>考点：<br>
<br>. .
<br>
<br>在  不能断言 .
<br>证明  的一致连续性和不一致连续性
<br>.

<br> 的零点  是  在  的全部奇点
<br> 的零点 ，是  在  的全部奇点


<br>
<br>Exercise.
证明<br>

<br>Proof.<br>
只需证明<br><br><br>□<br>Exercise.
<img alt="6-解析函数-20250320.png" src="lib\media\6-解析函数-20250320.png">
<br>Proof.<br>
<img alt="7-解析函数-20250320.png" src="lib\media\7-解析函数-20250320.png"><br><img alt="9-解析函数-20250320.png" src="lib\media\9-解析函数-20250320.png"><br>□<br><br>这一节的主要内容是采用限制辐角或割破平面的方法，来分出根式函数和对数函数的单值解析分支。<br><img alt="10-解析函数-20250320.png" src="lib\media\10-解析函数-20250320.png"><br>Exercise.
<img alt="11-解析函数-20250320.png" src="lib\media\11-解析函数-20250320.png">
<br><img alt="12-解析函数-20250320.png" src="lib\media\12-解析函数-20250320.png"><br><img alt="13-解析函数-20250320.png" src="lib\media\13-解析函数-20250320.png"><br><img alt="14-解析函数-20250320.png" src="lib\media\14-解析函数-20250320.png"><br><img alt="15-解析函数-20250320.png" src="lib\media\15-解析函数-20250320.png"><br><br><img alt="17-解析函数-20250320.png" src="lib\media\17-解析函数-20250320.png"><br><img alt="18-解析函数-20250320.png" src="lib\media\18-解析函数-20250320.png"><br><img alt="19-解析函数-20250320.png" src="lib\media\19-解析函数-20250320.png"><br><img alt="22-解析函数-20250320.png" src="lib\media\22-解析函数-20250320.png"><br><img alt="20-解析函数-20250320.png" src="lib\media\20-解析函数-20250320.png"><br><img alt="21-解析函数-20250320.png" src="lib\media\21-解析函数-20250320.png"><br><img alt="23-解析函数-20250320.png" src="lib\media\23-解析函数-20250320.png"><br>由已给单值解析分支  的初值 ，计算终值  的公式为<br><br>其中  为连接起点  和终点  且不穿过支割线的路线.<br>当把  换成  的动点  时，得到的<br><br>也是此单值解析分支的解析表达式.<br>Exercise.
<img alt="24-解析函数-20250320.png" src="lib\media\24-解析函数-20250320.png">
<br><img alt="25-解析函数-20250320.png" src="lib\media\25-解析函数-20250320.png"><br>Exercise.
<img alt="26-解析函数-20250320.png" src="lib\media\26-解析函数-20250320.png">
<br><img alt="27-解析函数-20250320.png" src="lib\media\27-解析函数-20250320.png"><br><img alt="28-解析函数-20250320.png" src="lib\media\28-解析函数-20250320.png"><br><img alt="29-解析函数-20250320.png" src="lib\media\29-解析函数-20250320.png"><br>Exercise.
<img alt="30-解析函数-20250320.png" src="lib\media\30-解析函数-20250320.png">
<br><img alt="31-解析函数-20250320.png" src="lib\media\31-解析函数-20250320.png"><br><img alt="32-解析函数-20250320.png" src="lib\media\32-解析函数-20250320.png"><br>Exercise.
<img alt="33-解析函数-20250320.png" src="lib\media\33-解析函数-20250320.png">
<br><img alt="34-解析函数-20250320.png" src="lib\media\34-解析函数-20250320.png"><br><img alt="35-解析函数-20250320.png" src="lib\media\35-解析函数-20250320.png"><br><br><img alt="36-解析函数-20250320.png" src="lib\media\36-解析函数-20250320.png"><br>
所有这些函数分成单值解析分支的方法，与我们前面用过的讨论方法是类似的，也要先讨论它们的支点，然后适当割破平面，只是较复杂些也较困难些。当然也可以像例 2.3.17 和例 2.3.19 一样，把他们视为复合函数来化简处理。
<br>Exercise.
<img alt="37-解析函数-20250320.png" src="lib\media\37-解析函数-20250320.png">
<br><img alt="38-解析函数-20250320.png" src="lib\media\38-解析函数-20250320.png"><br><img alt="39-解析函数-20250320.png" src="lib\media\39-解析函数-20250320.png"><br>Exercise.
<img alt="40-解析函数-20250320.png" src="lib\media\40-解析函数-20250320.png">
<br>
变量代换 ，化简，并将  分成单值解析分支，然后就可以按照复合函数求导。
<br><img alt="41-解析函数-20250320.png" src="lib\media\41-解析函数-20250320.png"><br><img alt="42-解析函数-20250320.png" src="lib\media\42-解析函数-20250320.png">]]></description><link>复变函数\解析函数.html</link><guid isPermaLink="false">复变函数/解析函数.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\4-解析函数-20250320.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\4-解析函数-20250320.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[解析函数的幂级数表示]]></title><description><![CDATA[ 
 <br><br>复级数的收敛性：<br><br>收敛半径：<br><br>解析函数的泰勒展开式：<br><br><br><br><br>Exercise.
求  在  的泰勒展开式.
<br>因为<br><br>于是<br><br><img alt="解析函数的幂级数表示-2025040611.png" src="lib\media\解析函数的幂级数表示-2025040611.png"><br>Exercise.
求  在  的泰勒展式.
<br>通过分析奇点可知， 在  内解析. 利用“大除法”：<br><img alt="1-解析函数的幂级数表示-2025040611.png" src="lib\media\1-解析函数的幂级数表示-2025040611.png"><br><br>Exercise.
求  在  的泰勒展式.
<br><img alt="2-解析函数的幂级数表示-2025040611.png" src="lib\media\2-解析函数的幂级数表示-2025040611.png"><br><br>Exercise.
展开 .
<br><img alt="3-解析函数的幂级数表示-2025040611.png" src="lib\media\3-解析函数的幂级数表示-2025040611.png"><br><br><img alt="4-解析函数的幂级数表示-2025040611.png" src="lib\media\4-解析函数的幂级数表示-2025040611.png"><br><br><img alt="5-解析函数的幂级数表示-2025040611.png" src="lib\media\5-解析函数的幂级数表示-2025040611.png"><br>
<img alt="6-解析函数的幂级数表示-2025040611.png" src="lib\media\6-解析函数的幂级数表示-2025040611.png"><br><img alt="7-解析函数的幂级数表示-2025040611.png" src="lib\media\7-解析函数的幂级数表示-2025040611.png"><br><br>Exercise.
若 ，且 ，则<br>

<br>Proof.<br>
因为<br><br>所以<br><br>□<br>
<img alt="8-解析函数的幂级数表示-2025040611.png" src="lib\media\8-解析函数的幂级数表示-2025040611.png"><br><img alt="9-解析函数的幂级数表示-2025040611.png" src="lib\media\9-解析函数的幂级数表示-2025040611.png"><br><br><img alt="10-解析函数的幂级数表示-2025040611.png" src="lib\media\10-解析函数的幂级数表示-2025040611.png"><br><img alt="11-解析函数的幂级数表示-2025040611.png" src="lib\media\11-解析函数的幂级数表示-2025040611.png"><br>
<img alt="12-解析函数的幂级数表示-2025040611.png" src="lib\media\12-解析函数的幂级数表示-2025040611.png"><br><img alt="13-解析函数的幂级数表示-2025040611.png" src="lib\media\13-解析函数的幂级数表示-2025040611.png"><br><img alt="14-解析函数的幂级数表示-2025040611.png" src="lib\media\14-解析函数的幂级数表示-2025040611.png"><br><br><img alt="解析函数的幂级数表示-2025040612.png" src="lib\media\解析函数的幂级数表示-2025040612.png"><br>Exercise.
设函数列  在区域  上解析，且在  中内闭一致收敛于函数 . 证明：

<br>若  不恒为零， 是  内可求长的简单闭曲线，其内部属于  ，且不经过  的零点，则存在正整数 , 使得当  时，在  的内部  和  有相同个数的零点. 
<br>若  在区域  内部时单叶的， 不为常数，则  在  内单叶解析.

<br>Proof.<br>
由 Weierstrass 定理， 在  内解析. 因为  在  上不为零，则<br><br>又  在  上一致收敛到 ，存在正整数 ，使得当  时，在  上有 . 即当  时，在  上有 . 由 Rouche 定理，在  的内部， 和  有相同个数的零点.<br>对于第二问采用反证法，若  在  内不是单叶的，则存在  使得 ，考虑函数 ，圆周 ，其中  充分小使得其包含于  内，而且  在圆周内有唯一的零点. 于是存在  ，使得  时， 和  在  内有相同个数（1 个）零点 ，从而 . 这与  的单叶性矛盾！<br>
□<br>Exercise (cmc 高年级第 10 届).
设  是复函数  的  阶极点. 证明：一定存在  使得对于任意 ，函数  在  中必有  个零点.
<br>Proof.<br>
定义<br><br>且在  处补充定义（因为是可去奇点），于是  在  的一个小邻域内解析，故存在  使得 . 再令<br><br>由最大模原理，对于  有<br><br>由 Rouche 定理，函数  在  内零点个数与函数  相等，即为  个. 由于  是  在  处的极点阶数，故 ，于是 . 故  在  存在  个零点，故  在  中必有  个零点.<br>
□<br>Theorem (Picard's Big Theorem).
Let  be an analytic function on a punctured neighborhood of , say on .
If  has an essential singularity at , then  takes on all possible complex values, with at most a single exception, infinitely often in any neighborhood of .
<br>Theorem (Picard's Little Theorem).
If  is an entire function which is not constant, then the image of  is either the whole complex plane or the complex plane minus a single point.
]]></description><link>复变函数\解析函数的幂级数表示.html</link><guid isPermaLink="false">复变函数/解析函数的幂级数表示.md</guid><pubDate>Wed, 14 May 2025 14:48:50 GMT</pubDate><enclosure url="lib\media\解析函数的幂级数表示-2025040611.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\解析函数的幂级数表示-2025040611.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[留数计算方法]]></title><description><![CDATA[ 
 <br><br>参见《积分的方法与技巧》· 金玉明; A first course in complex analysis with applications by Dennis Zill <br>留数的表示<br><br>留数定理由柯西积分公式得到<br><br>无穷远点的留数定理积分曲线方向相反 (考虑黎曼球，这是显然的)<br><br><br>留数就是  的 Laurent 展开式中系数 ，对于极点，有下面较为直接的方法，不需要 Laurant 展开.<br>Remark.
Laurant 展开就是按照公式计算 

<br><br>在  的邻域中有<br><br>于是<br><br><br> 在  点解析，且 ，但是 ，那么<br><br><br>Laurant 展开式为<br><br>那么<br><br>两边  得到<br><br>于是<br><br><br>详细计算见《积分的方法与技巧》· 金玉明 p 328<br><br><br>Lemma (Jordan's Lemma).
Let  be a semicircular contour in the upper half-plane defined by  for . Suppose  is a function that is analytic in the upper half-plane for  (for some constant ).
If  uniformly as  for  in the upper half-plane (i.e.,  as ), then for any real constant ,<br>

A similar statement holds for a semicircular contour in the lower half-plane if .
<br>Proof.<br>
Let , denote<br><br>Estmate the value,<br><br>□<br><br>参见 A first course in complex analysis with applications by Dennis Zill, Section 6.6<br><br>Given the integrals of the form <br><br>To convert it to a complex integral on , we parametrize the contour by . We can then write<br><br>i.e. <br><br>Then <a data-href="#^09155c" href="about:blank#^09155c" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^09155c</a><a data-href="#^09155c" href="about:blank#^09155c" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a> becomes<br><br>where  is the unit circle .<br><img alt="留数计算方法-2025051500.png" src="lib\media\留数计算方法-2025051500.png"><br>
<img alt="1-留数计算方法-2025051500.png" src="lib\media\1-留数计算方法-2025051500.png"><br>Cauchy principal value of an integral is defined by<br><br>If a integral diverges, it may still possess a Cauchy principal value.<br><img alt="2-留数计算方法-2025051500.png" src="lib\media\2-留数计算方法-2025051500.png"><br><img alt="3-留数计算方法-2025051500.png" src="lib\media\3-留数计算方法-2025051500.png"><br>Another powerful lemma is <a data-href="#^3910a9" href="about:blank#^3910a9" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^3910a9</a><a data-href="#^3910a9" href="about:blank#^3910a9" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Lemma 2 (Jordan's Lemma)</a>. <br>Next we calculate <br><br><img alt="4-留数计算方法-2025051500.png" src="lib\media\4-留数计算方法-2025051500.png"><br>
<img alt="5-留数计算方法-2025051500.png" src="lib\media\5-留数计算方法-2025051500.png"><br>Indented contour is of great use.<br><img alt="6-留数计算方法-2025051500.png" src="lib\media\6-留数计算方法-2025051500.png"><br><img alt="7-留数计算方法-2025051500.png" src="lib\media\7-留数计算方法-2025051500.png"><br><img alt="8-留数计算方法-2025051500.png" src="lib\media\8-留数计算方法-2025051500.png"><br><img alt="9-留数计算方法-2025051500.png" src="lib\media\9-留数计算方法-2025051500.png"><br>
<img alt="10-留数计算方法-2025051500.png" src="lib\media\10-留数计算方法-2025051500.png"><br><br>In the next discussion we examine integration along a Branch cut (cf section 2.6 and 4.1 in Dennis Zill)<br><img alt="11-留数计算方法-2025051500.png" src="lib\media\11-留数计算方法-2025051500.png"><br>
<img alt="12-留数计算方法-2025051500.png" src="lib\media\12-留数计算方法-2025051500.png"><br>This technique also goes for . <br><br><br><img alt="13-留数计算方法-2025051500.png" src="lib\media\13-留数计算方法-2025051500.png"><br>
<img alt="14-留数计算方法-2025051500.png" src="lib\media\14-留数计算方法-2025051500.png"><br><br><img alt="15-留数计算方法-2025051500.png" src="lib\media\15-留数计算方法-2025051500.png"><br><br>Rouche's theorem is a consequence of Argument Principle.<br><img alt="17-留数计算方法-2025051500.png" src="lib\media\17-留数计算方法-2025051500.png"><br>
<img alt="18-留数计算方法-2025051500.png" src="lib\media\18-留数计算方法-2025051500.png"><br><br><img alt="19-留数计算方法-2025051500.png" src="lib\media\19-留数计算方法-2025051500.png"><br>
<img alt="20-留数计算方法-2025051500.png" src="lib\media\20-留数计算方法-2025051500.png"><br><img alt="21-留数计算方法-2025051500.png" src="lib\media\21-留数计算方法-2025051500.png"><br><img alt="22-留数计算方法-2025051500.png" src="lib\media\22-留数计算方法-2025051500.png"><br><img alt="23-留数计算方法-2025051500.png" src="lib\media\23-留数计算方法-2025051500.png">]]></description><link>复变函数\留数计算方法.html</link><guid isPermaLink="false">复变函数/留数计算方法.md</guid><pubDate>Thu, 15 May 2025 02:20:55 GMT</pubDate><enclosure url="lib\media\留数计算方法-2025051500.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\留数计算方法-2025051500.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[洛朗级数]]></title><description><![CDATA[ 
 <br><br>Theorem (Laurant 定理).
在圆环  内解析的函数  必可以展开成双边幂级数，即Laurant 级数<br>
其中Laurant 系数<br>
 为圆周 ，并且展开式唯一.
<br>展开洛朗级数直接暴力展开即可.<br><br><img alt="1-洛朗级数-2025040612.png" src="lib\media\1-洛朗级数-2025040612.png"><br>
<img alt="洛朗级数-2025040612.png" src="lib\media\洛朗级数-2025040612.png"><br><br><img alt="6-洛朗级数-2025040616.png" src="lib\media\6-洛朗级数-2025040616.png"><br>
<img alt="5-洛朗级数-2025040616.png" src="lib\media\5-洛朗级数-2025040616.png"><br><br>由于函数  在  总是无意义的，所以点  总是  的奇点. <br><br>对于函数<br><br>它是有理分式函数，分母的零点  是这个函数的极点，下面考虑它们的阶.<br> 是分母的一阶零点，且不是分子  的零点，故  是  的一阶极点. 注意到 ,<br><br>于是  也是  的一阶极点.<br>接下来考虑 ，因为<br><br>其中  在  解析，且 ，因此  是  的一阶零点.<br><br>对于函数<br><br>它只有  作为奇点， 作为  的三阶极点， 在  的主要部分 (即正幂) 为零，故  是  的可去奇点.<br>由于  以  为二阶极点，故  以  为二阶零点.<br><br>对于函数 <br><br>解  得到  的零点<br><br>又因为 ，所以  都是  的一阶零点. 于是  都是  的一阶极点.<br>当  时，. 故点  是  的非孤立奇点，即极点列  的聚点.<br><br><img alt="洛朗级数-2025040614.png" src="lib\media\洛朗级数-2025040614.png"><br><img alt="1-洛朗级数-2025040614.png" src="lib\media\1-洛朗级数-2025040614.png"><br><br><img alt="2-洛朗级数-2025040614.png" src="lib\media\2-洛朗级数-2025040614.png"><br><br><img alt="4-洛朗级数-2025040616.png" src="lib\media\4-洛朗级数-2025040616.png"><br><br><img alt="3-洛朗级数-2025040614.png" src="lib\media\3-洛朗级数-2025040614.png"><br><br>Exercise.
设 ，当  时 . 证明： 必有一个零点.
<br>Proof.<br>
由于  是整函数，故只有  作为孤立奇点，于是可设<br><br>又由题设<br><br>可见  为  的可去奇点，从而  为  的一阶极点，从而<br><br>于是  必然有且仅有一个零点.<br>□<br><br><img alt="4-洛朗级数-2025040614.png" src="lib\media\4-洛朗级数-2025040614.png"><br>
<img alt="5-洛朗级数-2025040614.png" src="lib\media\5-洛朗级数-2025040614.png"><br><br><a data-tooltip-position="top" aria-label="https://fr.wikipedia.org/wiki/Lemme_de_Schwarz#Preuve" rel="noopener nofollow" class="external-link" href="https://fr.wikipedia.org/wiki/Lemme_de_Schwarz#Preuve" target="_blank">Lemme de Schwarz — Wikipédia</a><br><br>Let  be a holomorphic function on the open unit disk<br><br>Such that:<br>
<br>,
<br> for all .
<br>Then:<br>
<br> for all ,
<br>,
<br>Moreover, if equality holds at any point other than 0 (i.e., if  for some  ), or if , then  for some real constant .
<br><br>The proof is a straightforward application of the maximum modulus principle on the function<br><br>which is holomorphic on the whole of , including at the origin (because  is differentiable at the origin and fixes zero). Now if  denotes the closed disk of radius  centered at the origin, then the maximum modulus principle implies that, for , given any , there exists  on the boundary of  such that<br><br>As  we get .<br>Moreover, suppose that  for some non-zero , or . Then,  at some point of . So by the maximum modulus principle,  is equal to a constant  such that . Therefore, , as desired.<br><br>If , then let<br><br>Then . Apply Schwarz lemma,<br><br>i.e.<br><br><br>Exercise (cmc 第八届高年级决赛).
设函数  在单位圆  内解析，并且 ， 为常数. 证明：<br>

<br>Proof.<br>
令 ，做变换<br><br>则该变换将单位圆  映射为 . 由 Schwarz 引理 . 由于<br><br>则 <br><br>从而<br><br>□<br><br><img alt="洛朗级数-2025040616.png" src="lib\media\洛朗级数-2025040616.png"><br><img alt="2-洛朗级数-2025040616.png" src="lib\media\2-洛朗级数-2025040616.png"><br><br><a data-tooltip-position="top" aria-label="https://www.ma.imperial.ac.uk/~dcheragh/Teaching/2016-F-GCA/2016-F-GCA-Ch2.pdf" rel="noopener nofollow" class="external-link" href="https://www.ma.imperial.ac.uk/~dcheragh/Teaching/2016-F-GCA/2016-F-GCA-Ch2.pdf" target="_blank">LectureNotes</a><br>We have see that every rotation , for fixed , is an automorphism of the disk. For  define<br><br>which is also an automorphism of .<br>When , we have<br><br>Observe that <br><br>Then<br><br>By the Schwarz lemma, , and . Thus  is indentity map of . It follows that  is bijection from  to .<br>Theorem (Automorphism of ).
A map  is an automorphism of  iff there are  and  s.t.<br>

<br><br><img alt="洛朗级数-2025041018.png" src="lib\media\洛朗级数-2025041018.png"><br><br><br><br><br>For , , , , evaluate the maximum of . Denote , then<br><br>Apply Schwarz lemma to , with  then<br><br>At the same time, by Schwarz lemma, for any ,<br><br>Since  is automorphism, replace  by  where , then<br><br>i.e.<br><br>The above two inequaltities is called Schwarz-pick lemma.<br><br><a rel="noopener nofollow" class="external-link" href="http://www.webpages.ttu.edu/jengwer/notes/SchwarzPickLemmas.pdf" target="_blank">http://www.webpages.ttu.edu/jengwer/notes/SchwarzPickLemmas.pdf</a><br><img alt="洛朗级数-2025041019.png" src="lib\media\洛朗级数-2025041019.png">]]></description><link>复变函数\洛朗级数.html</link><guid isPermaLink="false">复变函数/洛朗级数.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\1-洛朗级数-2025040612.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\1-洛朗级数-2025040612.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[最大模原理]]></title><description><![CDATA[ 
 <br><br>参见 Rudin《实分析与复分析》.<br>This chaper contains further generealizations of the maximum modulus theorem, as well as some rather striking applications of it, and it concludes with a theorem which shows that the maximum property "almost" characterizes the class of holomorphic functions.<br><img alt="最大模原理-2025040417.png" src="lib\media\最大模原理-2025040417.png"><br><br>Suppose  is an entire function and <br><br>for all . Then  is a constant.<br>This follows immediately from the Cauchy estimates, since they show that  for <br><img alt="1-最大模原理-2025040417.png" src="lib\media\1-最大模原理-2025040417.png"><br><img alt="2-最大模原理-2025040417.png" src="lib\media\2-最大模原理-2025040417.png"><br><img alt="3-最大模原理-2025040417.png" src="lib\media\3-最大模原理-2025040417.png">]]></description><link>复变函数\最大模原理.html</link><guid isPermaLink="false">复变函数/最大模原理.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\最大模原理-2025040417.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\最大模原理-2025040417.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw1]]></title><description><![CDATA[ 
 <br>p13 1(2)(3) 4 7 9(2) 11 14 
<br>Exercise.
<img alt="hw1-20250303.png" src="lib\media\hw1-20250303.png">
<br><br><br>Exercise.
<img alt="1-hw1-20250303.png" src="lib\media\1-hw1-20250303.png">
<br>, then <br><br>Hence<br><br><br>Exercise.
<img alt="3-hw1-20250303.png" src="lib\media\3-hw1-20250303.png">
<br>Let , then<br><br>Exercise.
<img alt="6-hw1-20250303.png" src="lib\media\6-hw1-20250303.png">
<br>Definition (棣莫弗公式).
<img alt="10-hw1-20250303.png" src="lib\media\10-hw1-20250303.png">
<br><br>Exercise.
<img alt="7-hw1-20250303.png" src="lib\media\7-hw1-20250303.png">
<br>Solve the equation:<br><br>Then<br><br>Exercise.
<img alt="8-hw1-20250303.png" src="lib\media\8-hw1-20250303.png">
<br>
<img alt="11-hw1-20250303.png" src="lib\media\11-hw1-20250303.png">
<br>If , then <br><br>On the other hand<br><br>Therefore<br><br>If , we have  then<br><br>And<br><br>We have<br><br>Consider the function<br><br>which is decreasing in . Since , we have , that is <br><br>Therefore,<br>]]></description><link>复变函数\hw1.html</link><guid isPermaLink="false">复变函数/hw1.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\hw1-20250303.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw1-20250303.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw2]]></title><description><![CDATA[ 
 <br>p15 16 17(3)(4)(8)(9)(10)
p38 3(3)(5) 4 5 6 8 10    
<br><img alt="hw2-20250318.png" src="lib\media\hw2-20250318.png"><br>在复平面拓扑下：<br>(1)  不含内点，故不是开集， 没有聚点，故为闭集。由于  同构于  ，故  是紧集当且仅当  是有界闭集，但  并非有界，故  不是紧集。<br>(2) 同理于 (1)，该集合不是开集，是闭集，是紧集。<br>(3) 令<br><br><img alt="1-hw2-20250318.png" src="lib\media\1-hw2-20250318.png"><br>所有点都是内点，所以  是开集。而任意  作为极限点，却不在  中，故  不是闭集，进而不是紧集。<br>(4) 显然  是开集，不是闭集，不是紧集。 是闭集，是开集，是紧集。 是开集，是闭集，是紧集。<br>Remark.
 的定义是黎曼球球极投影得到的，它是依照  中的  表面拓扑而定的。它是  的紧致化。
<br><img alt="2-hw2-20250318.png" src="lib\media\2-hw2-20250318.png"><br>(3)<br>
<img alt="3-hw2-20250318.png" src="lib\media\3-hw2-20250318.png"><br>
单连通的闭圆盘<br>(4)<br><br>设 ，那么<br><br>平方得到<br><br>化简得到<br><br>平方得到<br><br>化简得到<br><br>是一个椭圆，显然单连通。<br>(8)<br><br>设 ，则<br><br>于是 . 平方得到<br><br>化简得到<br><br>也就是说<br><br>即<br><br>这是复平面挖掉一个圆盘，显然单连通。<br>
<img alt="7-hw2-20250318.png" src="lib\media\7-hw2-20250318.png"><br>(9)<br><br><img alt="4-hw2-20250318.png" src="lib\media\4-hw2-20250318.png"><br>这是单连通区域<br>(10) <br><br>设 ，则<br><br>于是，对于 ，，对于 ，则<br><br>若 ，则<br><br>也就是说<br><br><img alt="9-hw2-20250318.png" src="lib\media\9-hw2-20250318.png"><br>若 ，则<br><br>也就是说<br><br><img alt="10-hw2-20250318.png" src="lib\media\10-hw2-20250318.png"><br>总而言之，该区域为<br><img alt="12-hw2-20250318.png" src="lib\media\12-hw2-20250318.png"><br>是多连通的开区域<br><img alt="hw2-20250306.png" src="lib\media\hw2-20250306.png"><br>Definition (解析函数).
<img alt="3-hw2-20250306.png" src="lib\media\3-hw2-20250306.png">
<br>Theorem.
<img alt="1-hw2-20250306.png" src="lib\media\1-hw2-20250306.png">
<br>Theorem.
<img alt="2-hw2-20250306.png" src="lib\media\2-hw2-20250306.png">
<br>(3)  so . If  is differentiable at  then  implies that  thus . Hence  is the only point at which  is differentiable. For any neighborhood  of ,  is not differentiable in  thus  is not holomorphic over . Therefore  is holomorphic at no point.<br>
(5)  so , and .<br><img alt="4-hw2-20250306.png" src="lib\media\4-hw2-20250306.png"><br> for , since  then  where , and  where , we have , i.e. . (the differentiability is derived from  and theorem 3.2) Therefore  constant, and  is constant in .<br><img alt="hw2-20250307.png" src="lib\media\hw2-20250307.png"><br>(1)  for .  means  and , i.e. . If  is constant in  then , combined with the fact that  and , we have . Therefore  is constant in . There is a similar proof for  in .<br>
(2) If   is a constant in  then  is holomorphic in . However, if both  and  satisfies the C-R equation, it is easy to get  and thus  is constant.<br><img alt="6-hw2-20250306.png" src="lib\media\6-hw2-20250306.png"><br> for . . By theorem 3.2 it suffices to show that  and  are differentiable in  and  for . By theorem 3.2 we have  are differentiable in  and , i.e. . <br><br>Therefore  is holomorphic in the lower half plane.<br><img alt="7-hw2-20250306.png" src="lib\media\7-hw2-20250306.png"><br>. So we have<br><br>Then<br><br>And<br><br>The Cauchy-Riemann condition is , which means <br><br>where  then <br><br>Therefore<br><br>Hence <br><br><img alt="8-hw2-20250306.png" src="lib\media\8-hw2-20250306.png"><br><br><br>which is Cauchy-Riemann equation.]]></description><link>复变函数\hw2.html</link><guid isPermaLink="false">复变函数/hw2.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\hw2-20250318.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw2-20250318.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw3]]></title><description><![CDATA[ 
 <br>p40 11 14 15 16    
<br>Exercise.
11．试求出  的值． 
<br><br><br><br><br><br>Exercise.
14．设函数  在  解析，那么我们说  在  解析．下列函数中，哪些在无穷远点解析？

<br> 在  无定义，故不解析，故  在  不解析。<br> 在  解析，故  在  解析。<br>，当  且  时，在  解析，故  在  解析，否则在  不解析。<br> 是多值函数，在  的每个分支内解析，故  是多值解析函数。<br>Exercise.
15．在复平面上取上半虚轴作割线．试在所得区域内分别取定函数  与  在正实轴取正实值的一个解析分支，并求它们在上半虚轴左沿的点及右沿的点  处的值．
<br>对于 ，它有两个解析分支<br><br>令  在正实轴取正实值，于是  在  的解析分支。在上半虚轴右沿，令 ，那么 ，.<br>在左沿 ，.<br>对于 ，它有无穷多个解析分支<br><br>令  在正实轴取正实值，于是  在  的解析分支。在上半虚轴右沿，令 ，那么 ，.<br>在左沿，，.<br>Exercise.
16．在复平面上取正实轴作割线．试在所得的区域内：（1）取定函数  在正实轴上沿取正实值的一个解析分支，并求这一分支在

处的值；在正实轴下沿的值．（2）取定函数  在正实轴上沿取实值的一个解析分支，并求这一分支在  处的值；在正实轴下沿的值．
<br>(1)<br><br>在正实轴上沿取正实值的解析分支为 . 令  则<br><br>在正实轴下沿<br><br>(2)<br><br>在正实轴上沿取正实值的解析分支为 ，令  则<br><br>在正实轴下沿<br>]]></description><link>复变函数\hw3.html</link><guid isPermaLink="false">复变函数/hw3.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate></item><item><title><![CDATA[hw4]]></title><description><![CDATA[ 
 <br>p40 17 18 19
<br>Exercise.
<img alt="hw4-2025032420.png" src="lib\media\hw4-2025032420.png">
<br>函数  的支点为<br><br>于是线段  和  可以将复平面分割为解析分支. <br><br>其中 ，取  得到<br><br>于是<br><br>Exercise.

<br>设函数<br>
如果规定  时，. 作两种适当的割线，求这函数的一个解析分支在  的值.

<br><br>令  那么<br><br>故<br><br>第一种割法：<br>
<img alt="hw4-2025032500.png" src="lib\media\hw4-2025032500.png"><br><br>于是<br><br>第二种割法：<br>
<img alt="1-hw4-2025032500.png" src="lib\media\1-hw4-2025032500.png"><br>
在割线左沿：<br><br>于是<br><br>在割线右沿：<br><br>于是<br><br>Remark.
计算  的时候要注意，不是直接计算，而是注意到  时，，然后做曲线  ，这条曲线不经过割线，然后算出这条曲线绕过的角度，就是  的值.
<br>Exercise.
<img alt="1-hw4-2025032420.png" src="lib\media\1-hw4-2025032420.png">
<br> 但 ，这是因为<br><br><br>二者不是同一个多值函数.]]></description><link>复变函数\hw4.html</link><guid isPermaLink="false">复变函数/hw4.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\hw4-2025032420.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw4-2025032420.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw5]]></title><description><![CDATA[ 
 <br>p58 1 2 3 7 8 9 10
<br>Exercise.
<img alt="1-hw5-2025032512.png" src="lib\media\1-hw5-2025032512.png">
<br>记<br><br><br><br>于是<br>(1)<br><br>(2)<br><br>(3)<br><br>Exercise.
<img alt="2-hw5-2025032512.png" src="lib\media\2-hw5-2025032512.png">
<br>记<br><br><br>(1)<br><br>(2)<br><br>Exercise.
<img alt="3-hw5-2025032512.png" src="lib\media\3-hw5-2025032512.png">
<br>Proof.<br>
当  时，<br><br>令  得到<br><br>□<br>Exercise.
<img alt="hw5-2025032720.png" src="lib\media\hw5-2025032720.png"><br>
<img alt="1-hw5-2025032720.png" src="lib\media\1-hw5-2025032720.png">
<br>(1)<br>
,<br><br>,<br><br>(2)<br>
,<br><br>,<br><br>Exercise.
<img alt="2-hw5-2025032720.png" src="lib\media\2-hw5-2025032720.png">
<br>Let <br><br>Then <br><br> is holomorphic in , then for any <br><br>with . We have <br><br>where <br><br>Similarly,<br><br>Therefore<br><br><br>where .<br><img alt="2-hw5-2025032721.png" src="lib\media\2-hw5-2025032721.png"><br>Exercise.
<img alt="3-hw5-2025032720.png" src="lib\media\3-hw5-2025032720.png">
<br>(1)<br><br><br>(2)<br><br>(3)<br><br>Exercise.
<img alt="4-hw5-2025032720.png" src="lib\media\4-hw5-2025032720.png">
<br>Since  is continuous in the neighborhood of 0, then for any , there exists , s.t.<br><br>Let , then<br><br>Since  can be arbitrarily small, thus we have<br>]]></description><link>复变函数\hw5.html</link><guid isPermaLink="false">复变函数/hw5.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\1-hw5-2025032512.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\1-hw5-2025032512.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw6]]></title><description><![CDATA[ 
 <br>第三章 11 12 14 15 17 18
<br><img alt="hw6-2025040513.png" src="lib\media\hw6-2025040513.png"><br>(1)<br><br>(2)<br><br>(3)<br>
Since  is holomorphic in the unit disc and its boundary,<br><br>(4)<br><br><img alt="hw6-2025040411.png" src="lib\media\hw6-2025040411.png"><br>Apply Cauchy's integral formula to  at , then<br><br>Therefore<br><br><img alt="1-hw6-2025040411.png" src="lib\media\1-hw6-2025040411.png"><br><br>Let <br><br>Then<br><br>Let  then<br><br>Thus<br><br>On the other hand<br><br>Therefore<br><br><img alt="2-hw6-2025040411.png" src="lib\media\2-hw6-2025040411.png"><br>
<img alt="3-hw6-2025040411.png" src="lib\media\3-hw6-2025040411.png"><br>For , apply the Cauchy's integral formula<br><br>Clearly,  reaches its maximum at . Let  then<br><br><img alt="4-hw6-2025040411.png" src="lib\media\4-hw6-2025040411.png"><br>When ,<br>Let  large enough such that  is contained in , where  is the circle centered at  with radius , counterclockwise. Then<br><br>,  s.t. , we have<br><br>Then for <br><br>Thus<br><br>Since  is arbitrary,<br><br>When , let  be the circle centered at  with radius , clockwise.  is small enough such that  is contained in . Then<br><br>By Cauchy's integral formula<br><br>Hence<br><br><img alt="5-hw6-2025040411.png" src="lib\media\5-hw6-2025040411.png"><br>(1)<br>
Fix a point  and define<br><br>where  is any path in  connecting  to  and  is a complex number so that . This definition is independent of the path  since  is simple connected. We find that  is holomorphic with<br><br>and a simple calculation gives<br><br>so that  is constant. Evaluating this expression at  we find  so that  for all , and the proof is complete.<br>(2)<br>(1) implies (2). Put , then .]]></description><link>复变函数\hw6.html</link><guid isPermaLink="false">复变函数/hw6.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\hw6-2025040513.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw6-2025040513.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw7]]></title><description><![CDATA[ 
 <br>56789
<br>Exercise.
<img alt="3-hw7-2025041510.png" src="lib\media\3-hw7-2025041510.png">
<br>(1)  then .<br>(2) , where <br><br>Then , .<br>(3)  then .<br>(4)  then .<br>(5) . Then .<br>(6) <br><br>Lemma.

<br><br>Thus .<br>Exercise.
<img alt="4-hw7-2025041510.png" src="lib\media\4-hw7-2025041510.png"><br>
<img alt="5-hw7-2025041510.png" src="lib\media\5-hw7-2025041510.png">
<br>Proof.<br>
(1)<br><br>Then<br><br>(2)<br>
If  is entire, since  is bounded, then for each , let ,<br><br>Therefore  is constant.<br>(3)<br><br>□<br>Exercise.
<img alt="6-hw7-2025041510.png" src="lib\media\6-hw7-2025041510.png">
<br>Proof.<br><br>□<br>Exercise.
<img alt="7-hw7-2025041510.png" src="lib\media\7-hw7-2025041510.png">
<br>Proof.<br><br>Let , , then<br><br>. Thus<br><br>□<br>Exercise.
<img alt="8-hw7-2025041510.png" src="lib\media\8-hw7-2025041510.png">
<br>(1)<br><br>(2)<br><br>(3)<br><br>(4) 主值支：<br><br>(5)<br>]]></description><link>复变函数\hw7.html</link><guid isPermaLink="false">复变函数/hw7.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\3-hw7-2025041510.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\3-hw7-2025041510.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw8]]></title><description><![CDATA[ 
 <br>10 11 
12(3)(5)(6) 13
<br>Exercise.
<img alt="hw8-2025042123.png" src="lib\media\hw8-2025042123.png">
<br>Proof.<br>
由于  是整函数，考虑它的幂级数表示形式<br><br>由 Cauchy 定理，<br><br>其中  是以原点为中心，半径为  的逆时针方向的圈. 对于任意 ，有<br><br>由  的任意性，令 ，就有 . 于是  是一个至多  次的多项式或者常数.<br>
□<br>Exercise.
<img alt="1-hw8-2025042123.png" src="lib\media\1-hw8-2025042123.png">
<br>Proof.<br>
只需要证明<br><br>其中<br><br>当  时，有<br><br>故得证！<br>
□<br>Exercise.
<img alt="2-hw8-2025042123.png" src="lib\media\2-hw8-2025042123.png">
<br>(3)<br><br>(5)<br><br>(6) 在 <br><br>在 <br><br>Exercise.
<img alt="3-hw8-2025042123.png" src="lib\media\3-hw8-2025042123.png"><br>
<img alt="4-hw8-2025042123.png" src="lib\media\4-hw8-2025042123.png">
<br>(1)<br><br>有孤立奇点 ，其中  为 1 阶极点， 和  为 2 阶极点.  为可去奇点.<br>(2)<br><br> 为  奇点当且仅当 ，即 . 也就是 ，即  其中 . 于是 ， 为  的孤立奇点，都是 1 阶奇点.<br>(3)<br><br>于是孤立奇点为  其中 ，若 , ，那么 ,  是所有孤立奇点，都是 2 阶极点. 否则  ,  是所有孤立奇点，都是 1 阶极点.<br>(4)<br><br>孤立奇点为  和 ，其中  为 1 阶极点， 是本性奇点.<br>(5)<br><br>孤立奇点为 ，其中  是本性奇点， 是可去奇点.<br>(6)<br><br>, 即 .  也是奇点，但 ，故  是可去奇点. 综上：,  是所有孤立奇点，其中  是可去奇点， 是 1 阶极点]]></description><link>复变函数\hw8.html</link><guid isPermaLink="false">复变函数/hw8.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\hw8-2025042123.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw8-2025042123.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw9]]></title><description><![CDATA[ 
 <br>第4章：14 17 18 19 
第5章：1 2 3 7
<br>Exercise.
<img alt="hw9-2025042910.png" src="lib\media\hw9-2025042910.png">
<br>Proof.<br><br>Since , <br><br>is holomorphic at . Thus .<br><br>where <br><br>And .<br>
□<br>Exercise.
<img alt="1-hw9-2025042910.png" src="lib\media\1-hw9-2025042910.png">
<br>Proof.<br>
For , we have<br><br>where . Since  for . Then  for . Therefore<br><br>is constant in .<br>□<br>Exercise.
<img alt="2-hw9-2025042910.png" src="lib\media\2-hw9-2025042910.png">
<br>Proof.<br>
(1)<br>
不存在，由于非平凡解析函数零点孤立，而 ,  在 0 的某个邻域内恒为 0. 当  充分大的时候  落在这个邻域内，但 .<br>(2)<br>
可做函数<br><br>(3)<br>
不存在，事实上点列 ，故在 0 的某个邻域内, ，这与题设  矛盾.<br>□<br>Exercise.
<img alt="3-hw9-2025042910.png" src="lib\media\3-hw9-2025042910.png">
<br>Proof.<br>
并不矛盾，因为 1 是函数的奇点，函数不在 1 处解析.<br>□<br>Exercise.
<img alt="4-hw9-2025042910.png" src="lib\media\4-hw9-2025042910.png">
<br>(1)<br><br><br>(2)<br><br>(3)<br><br>(4)<br><br>Exercise.
<img alt="5-hw9-2025042910.png" src="lib\media\5-hw9-2025042910.png">
<br><br> 时， 在  处有可去奇点，在  处有一阶极点.<br><br><br> 时， 在  处有一阶极点，在  处有一阶极点.<br><br><br>Exercise.
<img alt="6-hw9-2025042910.png" src="lib\media\6-hw9-2025042910.png">
<br>(1)<br><br>(2)<br><br>(3)<br><br>Exercise.
<img alt="7-hw9-2025042910.png" src="lib\media\7-hw9-2025042910.png">
<br>记奇点为 ，我们知道<br><br>由于  在  处解析，所以 . 从而<br><br>记<br><br>在扩充复平面上解析，因为洛朗展开没有正项，所以<br><br>因此<br>]]></description><link>复变函数\hw9.html</link><guid isPermaLink="false">复变函数/hw9.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\hw9-2025042910.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw9-2025042910.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw10]]></title><description><![CDATA[ 
 <br>p110 8(1)(2)(4)
<br>Exercise.
<img alt="hw10-2025050521.png" src="lib\media\hw10-2025050521.png">
<br>(1)<br>
Let <br><br>Consider the toy contour<br>
<img alt="2-hw10-2025050521.png" src="lib\media\2-hw10-2025050521.png"><br>
We have<br><br>On ,<br><br>Let  in <a data-href="#^e8496f" href="about:blank#^e8496f" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^e8496f</a><a data-href="#^e8496f" href="about:blank#^e8496f" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a>, then <br><br>Hence <br><br>(2)<br><br>The singularities are  and . Since , then<br><br>(4)<br><br>Let <br><br>Consider the toy contour, an indented semicircle in the upper plane.<br><br>On , <br><br>where , thus . <br>Let  in <a data-href="#^11089d" href="about:blank#^11089d" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^11089d</a><a data-href="#^11089d" href="about:blank#^11089d" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (2)</a> ,then<br><br>Thus<br>]]></description><link>复变函数\hw10.html</link><guid isPermaLink="false">复变函数/hw10.md</guid><pubDate>Tue, 06 May 2025 03:52:49 GMT</pubDate><enclosure url="lib\media\hw10-2025050521.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw10-2025050521.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw11]]></title><description><![CDATA[ 
 <br>p110 8 (6)(7)(8)(10)(12)(13)(14)
p111 11 12 14 15
<br>Exercise.
<img alt="1-hw11-2025051222.png" src="lib\media\1-hw11-2025051222.png">
<br>(6) <br>(7)  <br>(8) <br>Exercise.
<img alt="3-hw11-2025051222.png" src="lib\media\3-hw11-2025051222.png">
<br><img alt="e4aa87a842ea72501199a17e1558455c.jpg" src="lib\media\e4aa87a842ea72501199a17e1558455c.jpg"><br>Exercise.
<img alt="2-hw11-2025051222.png" src="lib\media\2-hw11-2025051222.png">
<br>(12) .<br>(13) .<br><img alt="3ae846ce63aa5cfd332852fc20c2e6f7.jpg" src="lib\media\3ae846ce63aa5cfd332852fc20c2e6f7.jpg"><br>Exercise.
<img alt="4-hw11-2025051222.png" src="lib\media\4-hw11-2025051222.png">
<br><br>Exercise.
<img alt="5-hw11-2025051222.png" src="lib\media\5-hw11-2025051222.png">
<br><img alt="99f6b691971bbe6f3052a1503163e3d3.jpg" src="lib\media\99f6b691971bbe6f3052a1503163e3d3.jpg"><br>Exercise.
<img alt="6-hw11-2025051222.png" src="lib\media\6-hw11-2025051222.png">
<br><img alt="99f6b691971bbe6f3052a1503163e3d3 1.jpg" src="lib\media\99f6b691971bbe6f3052a1503163e3d3-1.jpg"><br>Exercise.
<img alt="7-hw11-2025051222.png" src="lib\media\7-hw11-2025051222.png">
<br><img alt="3019c9996e90f823fa10aaca79a20fd0.jpg" src="lib\media\3019c9996e90f823fa10aaca79a20fd0.jpg"><br>Exercise.
<img alt="8-hw11-2025051222.png" src="lib\media\8-hw11-2025051222.png">
<br>假设有一个复变函数 ，它在一条简单闭合曲线  的内部及边界上是解析的（除了有限个极点外），并且在  上没有零点和极点。那么，当  沿着曲线  逆时针方向绕行一周时， 的辐角变化量等于  乘以函数  在曲线  内部零点的个数（计重数）减去极点的个数（计重数）。<br>
用公式表示:<br>
其中：<br>
<br> 表示当  沿曲线  逆时针方向绕行一周时， 的辐角变化量。
<br> 表示函数  在曲线  内部零点的个数（如果一个零点是  重的，则计为  个）。
<br> 表示函数  在曲线  内部极点的个数（如果一个极点是  重的，则计为  个）。
<br>另一种等价的表述形式是利用对数导数:<br><br>这个积分实际上计算了  的像在原点周围缠绕的圈数。<br><img alt="15e68e8704605b6d0579751f181ee127.jpg" src="lib\media\15e68e8704605b6d0579751f181ee127.jpg">]]></description><link>复变函数\hw11.html</link><guid isPermaLink="false">复变函数/hw11.md</guid><pubDate>Tue, 13 May 2025 03:36:13 GMT</pubDate><enclosure url="lib\media\1-hw11-2025051222.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\1-hw11-2025051222.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw12]]></title><description><![CDATA[ 
 <br>p134 1 3 4 5 6 7
<br>Exercise.
<img alt="hw12-2025051912.png" src="lib\media\hw12-2025051912.png">
<br>Consider the parameterization of ,<br><br>Then the parameterization of  is<br><br>Since  is injective, the path  is well-defined simple closed curve. Then<br><br>On the other hand,<br><br>Therefore<br><br>Denote  ，where 。<br>The area  of the region  in the -plane can be obtained by variable substitution using the Jacobian determinant:<br><br>According to the variable substitution formula for double integrals, we have:<br><br>where  is the Jacobian determinant:<br><br>Since  is an analytic function, its real part  and imaginary part  satisfy the Cauchy-Riemann equations:<br><br><br>Substituting the Cauchy-Riemann equations into the Jacobian determinant:<br><br>We know that the complex derivative  can be expressed as:<br><br>Therefore, the square of the modulus of the complex derivative is:<br><br>So, the value of the Jacobian determinant is equal to :<br><br>Now we substitute this result back into the area integral formula:<br><br>This proves the second conclusion.<br>Exercise.
<img alt="1-hw12-2025051912.png" src="lib\media\1-hw12-2025051912.png">
<br>(1)<br>
For , if<br><br>Then<br><br><br>Thus .  is injective.<br>(2)<br>
For , if<br><br>Then<br><br><br>Thus .  is injective.<br>(3)<br>
For , if<br><br>Then<br><br>Thus .  is injective.<br>Exercise.
<img alt="3-hw12-2025051912.png" src="lib\media\3-hw12-2025051912.png">
<br>Denote<br><br>Then<br><br>By Cauchy's formula,<br><br>where . Then<br><br>Let , then<br><br>Thus for any ,<br><br>By Rouche's theorem,  and  has the same numbers of zero's in , i.e. only  zero. As ,  has no zero in .<br>Assume that  is not injective in . There exists  s.t. <br><br>By the MVT, there exists , s.t. <br><br>By the convexity of , <br><br>is a zero of , whihc is a contradiction. Hence,  is injective in ; for any , it is an interior point of , thus has a neighborhood where  is injective. <br>Exercise.
<img alt="hw12-2025051920.png" src="lib\media\hw12-2025051920.png">
<br><br>Then<br><br><br>Thus the inverse of  is<br><br>Exercise.
<img alt="5-hw12-2025051912.png" src="lib\media\5-hw12-2025051912.png">
<br><br><br>Then<br><br>Exercise.
<img alt="6-hw12-2025051912.png" src="lib\media\6-hw12-2025051912.png">
<br><img alt="hw12-2025051921.png" src="lib\media\hw12-2025051921.png"><br>(1)<br><br>Then<br><br>(2)<br><br>i.e. <br><br>Then<br>]]></description><link>复变函数\hw12.html</link><guid isPermaLink="false">复变函数/hw12.md</guid><pubDate>Tue, 20 May 2025 02:25:14 GMT</pubDate><enclosure url="lib\media\hw12-2025051912.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw12-2025051912.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[primary-functions]]></title><description><![CDATA[ 
 <br><br>See chapter 2 of  A First Course in Complex Analysis with Applicaitons. Dennis<br><br><br><br>For ,  has infinite many different values.  represents the principle value of . <br><br> is the complex number satisfying .  <br><br> is the principle value of .<br>
Note that for ,<br><br>We use  instead of  for the consideration of multiple values.<br><br><img alt="7-primary-functions-20250314.png" src="lib\media\7-primary-functions-20250314.png"><br><br>For , . . If  then  is  -valued. If  or , then  is  -valued.<br><img alt="primary-functions-20250314.png" src="lib\media\primary-functions-20250314.png"><br> 阶支点：转  圈回到最初的值。<br><img alt="2-primary-functions-20250314.png" src="lib\media\2-primary-functions-20250314.png"><br>无穷阶支点：转不回最初的值。<br><img alt="3-primary-functions-20250314.png" src="lib\media\3-primary-functions-20250314.png"><br><img alt="4-primary-functions-20250314.png" src="lib\media\4-primary-functions-20250314.png"><br><img alt="5-primary-functions-20250314.png" src="lib\media\5-primary-functions-20250314.png"><br>计算根式函数在某个给定的解析分支内的取值：<br>
<br>先计算出这个解析分支是啥，考虑极坐标
<br>再代入给定的点到这个解析分支中
<br><img alt="6-primary-functions-20250314.png" src="lib\media\6-primary-functions-20250314.png"><br><img alt="8-primary-functions-20250314.png" src="lib\media\8-primary-functions-20250314.png"><br><img alt="9-primary-functions-20250314.png" src="lib\media\9-primary-functions-20250314.png">]]></description><link>复变函数\primary-functions.html</link><guid isPermaLink="false">复变函数/primary-functions.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\7-primary-functions-20250314.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\7-primary-functions-20250314.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[rudin-approximation-by-rational-functions]]></title><description><![CDATA[ 
 <br><br><br><img alt="1-rudin-approximation-by-rational-functions-2025052223.png" src="lib\media\1-rudin-approximation-by-rational-functions-2025052223.png"><br><img alt="rudin-approximation-by-rational-functions-2025052223.png" src="lib\media\rudin-approximation-by-rational-functions-2025052223.png">]]></description><link>复变函数\rudin-approximation-by-rational-functions.html</link><guid isPermaLink="false">复变函数/rudin-approximation-by-rational-functions.md</guid><pubDate>Thu, 22 May 2025 15:12:58 GMT</pubDate><enclosure url="lib\media\1-rudin-approximation-by-rational-functions-2025052223.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\1-rudin-approximation-by-rational-functions-2025052223.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[rudin-conformal-mapping]]></title><description><![CDATA[ 
 <br><br>The direction of  is . <br>Definition (preserves angles).
<img alt="rudin-conformal-mapping-2025052220.png" src="lib\media\rudin-conformal-mapping-2025052220.png">
<br>In less precise language, the requirement is that for any two rays  and , starting at , the angle which their images  and  make at  is the same as that made by  and , in size as well as in orientation.<br>The property of preserving angles at each point of a region is characteristic of holomorphic functions whose derivative has no zero in that region.<br>Definition.
Suppose , for some region . We call  a normal family if every sequence of members of  contains a subsequence which converges<a data-footref="[inline0" href="about:blank#fn-1-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a> uniformly on compact subsets of . The limit function is not required to belong to .
<br>Theorem.
Suppose  and  is uniformly bounded on each compact subset of the region . Then  is a normal family.
<br><br><img alt="1-rudin-conformal-mapping-2025052220.png" src="lib\media\1-rudin-conformal-mapping-2025052220.png"><br>The Riemann mapping theorem reduces the study of  to , for any simply connected proper subregion of the plane. <br><img alt="2-rudin-conformal-mapping-2025052220.png" src="lib\media\2-rudin-conformal-mapping-2025052220.png"><br><br>Definition.
 is the class of all  which are injective in  and which satisfy

Thus every  has a power series expansion

<br>The class  is not closed under addition or multiplication, but has many other interesting properties. We shall develop only a few of these in this section. Theorem 14.15 will be used in the proof of Mergelyan's theorem, in Chap. 20.<br><img alt="rudin-conformal-mapping-2025052221.png" src="lib\media\rudin-conformal-mapping-2025052221.png"><br>Proof.<br>
(a) is clear. To prove (b), write . Then , and  has no zero in  since  has no zero in . Hence there exists , with , . Put<br><br>Then . NTS: . Clearly, , . For , , then, ; as  is injective, . If , then ; it follows that , and since  has no zero in , we have .<br>
□<br>Theorem (area theorem (Theorem 14.13)).
If ,  is one-to-one in , and

then

<br>Proof.<br>
WLOG, assume ,  is real. Put , , . Then  is a neighborhood of ; the sets ,  and  are disjoint, as  is injective.  is in the interior of . Write<br><br> and<br><br>For , we then obtain<br><br>Then<br><br>There exists , if sufficiently small , we have<br><br>This says  lies in the interior of ellipse , whose semiaxes are  and , and which therefore bounds an area<br><br>Since  is in the interior of , the area of  is no larger than <a data-href="#^4fdc67" href="about:blank#^4fdc67" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^4fdc67</a><a data-href="#^4fdc67" href="about:blank#^4fdc67" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a>. The Cauchy-Riemann equations show that the Jacobian of  is , then<br><br>Thus<br><br>Let , then let . We are done!<br>
□<br>Corollary.
Under the same hypothesis in <a data-href="#^1a9dd9" href="about:blank#^1a9dd9" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^1a9dd9</a><a data-href="#^1a9dd9" href="about:blank#^1a9dd9" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 5 (area theorem (Theorem 14.13))</a>, .
<br><img alt="rudin-conformal-mapping-2025052222.png" src="lib\media\rudin-conformal-mapping-2025052222.png"><br>
The second assertion is that  contains all  with . 
<br>Proof.<br>
(a) By theorem 14.12, there exists  s.t. . Denote , then <a data-href="#^1a9dd9" href="about:blank#^1a9dd9" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^1a9dd9</a><a data-href="#^1a9dd9" href="about:blank#^1a9dd9" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 5 (area theorem (Theorem 14.13))</a> applies to  and this yields (a). Since<br><br>we have<br><br>and hence<br><br>By <a data-href="#^74fd16" href="about:blank#^74fd16" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^74fd16</a><a data-href="#^74fd16" href="about:blank#^74fd16" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Corollary 6</a>, . <br>To prove (b), suppose . Define<br><br>Then ,  is injective in , and <br><br>so that . Apply (a) to : we have  and since , we finally obtain . So  for every . This complete the proof.<br>
□<br>Moreover, given any , one can find entire  with , , that omit the value . For example, <br><br>Of course, by Theorem 14.14, that  is injective in  and  cannot happen at the same time. <br><img alt="1-rudin-conformal-mapping-2025052222.png" src="lib\media\1-rudin-conformal-mapping-2025052222.png"><br>Proof.<br>
Let , then , hence , so the image of  under  contains all  with . Since  is not in this image, we have .<br>
□<br>
<br>
<br>may converges to <a href="about:blank#fnref-1-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>复变函数\rudin-conformal-mapping.html</link><guid isPermaLink="false">复变函数/rudin-conformal-mapping.md</guid><pubDate>Thu, 22 May 2025 14:48:58 GMT</pubDate><enclosure url="lib\media\rudin-conformal-mapping-2025052220.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\rudin-conformal-mapping-2025052220.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[rudin-harmonic-function]]></title><description><![CDATA[ 
 <br><br><br>The Poisson kernel is<br><br>If ,<br><br><br>From <a data-href="#^7f4037" href="about:blank#^7f4037" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^7f4037</a><a data-href="#^7f4037" href="about:blank#^7f4037" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a> ,we have , , , for . Then <br><br>Now denote  by ,  by . Indentify the spaces  and  with the corresponding spaces of  -period functions in . <br>Regard  as , then<br><br>The Poisson integral  is <br><br>If  is real, <br><br>, then  is harmonic.<br>Poisson integrals of continuous function behave well near the boundary of .<br>
<img alt="rudin-harmonic-function-2025052210.png" src="lib\media\rudin-harmonic-function-2025052210.png"><br>
This theorem, using Poisson integral, solves the boundary value problem<a data-footref="[inline0" href="about:blank#fn-1-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a>: given , find harmonic  in . 
<br>The harmonic  is also unique.<br>
<img alt="rudin-harmonic-function-2025052211.png" src="lib\media\rudin-harmonic-function-2025052211.png"><br>Proof.<br>
By theorem 10.7, . Let ,  is harmonic. NTS:  on . Assume not, WLOG, , s.t. ; pick , , then . As ,  is subharmonic, by maximum principle, this is a contradiction.<br>
□<br>For harmonic<a data-footref="[inline1" href="about:blank#fn-2-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[2]</a> , <br><br>For , by <a data-href="#^7f4037" href="about:blank#^7f4037" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^7f4037</a><a data-href="#^7f4037" href="about:blank#^7f4037" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a>,<br><br>Let  harmonic in open . For ,  satisfies <a data-href="#^9f27a7" href="about:blank#^9f27a7" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^9f27a7</a><a data-href="#^9f27a7" href="about:blank#^9f27a7" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (2)</a> <a data-footref="[inline2" href="about:blank#fn-3-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[3]</a>, and  for some , where  is unique up to  <br>The Poisson integral also yields information about sequences of harmonic functions.<br>
<img alt="1-rudin-harmonic-function-2025052211.png" src="lib\media\1-rudin-harmonic-function-2025052211.png"><br>Proof.<br>
(a) As  on ,  satisfies <a data-href="#^9f27a7" href="about:blank#^9f27a7" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^9f27a7</a><a data-href="#^9f27a7" href="about:blank#^9f27a7" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (2)</a>, we have  satisfies  <a data-href="#^9f27a7" href="about:blank#^9f27a7" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^9f27a7</a><a data-href="#^9f27a7" href="about:blank#^9f27a7" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (2)</a>, thus  is harmonic. <br>(b) Assume that , , , . For any , <br><br><br>Thus<br><br>Let , then <a data-href="#^ae7692" href="about:blank#^ae7692" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^ae7692</a><a data-href="#^ae7692" href="about:blank#^ae7692" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (3)</a> also holds for . Thus  are open. As  is connected,  or . We are done!<br>
□<br><br><img alt="2-rudin-harmonic-function-2025052212.png" src="lib\media\2-rudin-harmonic-function-2025052212.png"><br>
<img alt="3-rudin-harmonic-function-2025052212.png" src="lib\media\3-rudin-harmonic-function-2025052212.png"><br>The theorem asserts  can be extended to , where . , we extend  to  by letting , and . <br><br>Let , . Theorem 11.8 can be restated as: for , , then  on  as . i.e. . <br>We replace  by :<br>
<img alt="4-rudin-harmonic-function-2025052212.png" src="lib\media\4-rudin-harmonic-function-2025052212.png"><br>Proof.<br><br>Then<br><br>Integrate  ove , then we obtain (1).<br>As  is dense in  for  <a data-footref="[inline3" href="about:blank#fn-4-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[4]</a>, pick  s.t. , , then<br><br>By theorem 11.8, , therefore  as .<br>
□<br><br><img alt="8-rudin-harmonic-function-2025052212.png" src="lib\media\8-rudin-harmonic-function-2025052212.png"><br><br><img alt="6-rudin-harmonic-function-2025052212.png" src="lib\media\6-rudin-harmonic-function-2025052212.png"><br><img alt="7-rudin-harmonic-function-2025052212.png" src="lib\media\7-rudin-harmonic-function-2025052212.png"><br>A considerably stronger uniqueness theorem will be obtained later.<br>
<br>
<br>the Dirichlet problem<a href="about:blank#fnref-1-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
<br>in .<a href="about:blank#fnref-2-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
<br> <a data-href="#^9f27a7" href="about:blank#^9f27a7" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^9f27a7</a><a data-href="#^9f27a7" href="about:blank#^9f27a7" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (2)</a> is the criterion of harmonic function, due to the above two theorems.<a href="about:blank#fnref-3-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
<br><a href="about:blank#fnref-4-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>复变函数\rudin-harmonic-function.html</link><guid isPermaLink="false">复变函数/rudin-harmonic-function.md</guid><pubDate>Thu, 22 May 2025 04:50:28 GMT</pubDate><enclosure url="lib\media\rudin-harmonic-function-2025052210.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\rudin-harmonic-function-2025052210.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[rudin-Hp-spaces]]></title><description><![CDATA[ 
 <br><br>This chapter studies certain subspaces of  which are defined by certain growth conditions. These so-called  -spaces have a large number of interesting properties concerning factorizations, boundary values, and Cauchy-type representations in terms of measures on the boundary of . <br>A convenient approach to the subject is via subharmonic functions, and we begin with a brief outline of their properties. <br><br>Definition.
A function  defined in an open set  in the plane is said to be subharmonic if it has the following four properties.

<br> for all .
<br> is upper semicontinuous in .
<br>Whenever , then


<br>None of the integrals in (c) is .

<br>Note that the integrals in (c) always exist and are not , since (a) and (b) imply that  is bounded above on every compact . <a data-footref="[inline0" href="about:blank#fn-1-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a> Hence (d) says that the integrands in (c) belong to .<br>Theorem (Theorem 17.2).
If  is subharmonic in , and if  is a monotonically increasing convex function on , then  is subharmonic.
<br>Theorem (Theorem 17.3).
If  is a region, , and  is not identically 0, then  is subharmonic in , and so are  and .<a data-footref="[inline1" href="about:blank#fn-2-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[2]</a>
<br>Theorem (Theorem 17.4).
Suppose  is a continuous subharmonic function in ,  is a compact subset of ,  is a continuous real function on  which is harmonic in the interior  of , and  at all boundary points of . Then .
<br>
Clearly by maximum modulus principle. But we gives a proof without it.
<br>Proof.<br>
Put . Assume that  for some . Since ,  attains its maximum  on ; and since  on the boundary of , the set  is a nonempty compact subset of . Let  be a boundary point of . Then for some , we have , but some subarc of the boundary of  lies in the complement of . Hence <br><br>and this means  is not subharmonic in , which is a contradiction.<br>
□<br>Theorem (Theorem 17.5).
Suppose  is a continuous subharmonic function in , and

If , then .
<br>Proof.<br>
Let  be the continuous function on  which conincides with  on the boundary of  and which is harmonic in . By <a data-href="#^b2d12b" href="about:blank#^b2d12b" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^b2d12b</a><a data-href="#^b2d12b" href="about:blank#^b2d12b" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 4 (Theorem 17.4)</a>,  in . Hence<br><br>□<br><br>Let  denote Lebesgue measure on , so normalized that . <br><br><br>and we also introduce<br><br>Definition.
If  and , we put

<br>If ,  is defined to be the class of all  for which . (Note that this coincides with our previously introduced terminology in the case .)<br>The class  consists of all  for which <br>It is clear that  if <br>
<br>
<br>Proof: If  is the set of all  at which , then , so either  for some , or , in which case  for some .<a href="about:blank#fnref-1-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
<br>if  has no zero in ,  is harmonic.<a href="about:blank#fnref-2-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>复变函数\rudin-hp-spaces.html</link><guid isPermaLink="false">复变函数/rudin-Hp-spaces.md</guid><pubDate>Thu, 22 May 2025 16:02:48 GMT</pubDate></item><item><title><![CDATA[rudin-maximum-modulus-principle]]></title><description><![CDATA[ 
 <br><br>Theorem (Maximum Modulus Principle).
If  is the closure of a bounded region , if  is continuous on  and holomorphic in , then

for every . If equality holds at one point , then  is constant.
<br>The equality , which is part of Theorem 11.32, implies that<br><br>This time boundedness on  is enough; we do not need continuity on . <br>This chapter contains further generalizations of the maximum modulus theorem, as well as some rather striking applications of it, and it concludes with a theorem which shows that the maximum property "almost" characterizes the class of holomorphic functions.<br><br>Theorem (Schwarz lemma).
Suppose , , and . Then


if equality holds in (1) for one , or if equality holds in (2), then , where  is a constant, .
<br>Proof.<br>
Apply <a data-href="#^bbe383" href="about:blank#^bbe383" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^bbe383</a><a data-href="#^bbe383" href="about:blank#^bbe383" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 1 (Maximum Modulus Principle)</a> to  which has a removable singularity at 0.<br>
□<br>For any , define<br><br>Then  is bijection, , . The inverse is . We have<br><br>Suppose  and  are complex numbers, , and . How large can  be if  is subject to the conditions , and ?<br>To solve this, put . Clearly, , , . By <a data-href="#^8304d0" href="about:blank#^8304d0" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^8304d0</a><a data-href="#^8304d0" href="about:blank#^8304d0" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 2 (Schwarz lemma)</a>, . The chain rule gives<br><br>Apply <a data-href="#^6e6ce3" href="about:blank#^6e6ce3" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^6e6ce3</a><a data-href="#^6e6ce3" href="about:blank#^6e6ce3" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a>, we have <br><br>The equality holds iff , in which case  is a rotation, thus<br><br>for some constant  with . <br>
We imposed no smooth condition on the behavior of  near . 
<br><img alt="rudin-maximum-modulus-principle-2025052218.png" src="lib\media\rudin-maximum-modulus-principle-2025052218.png"><br>Proof.<br>
Let  be the inverse of , . As  is injective, ,   exists for any , thus . By the chain rule, . By <a data-href="#^3725bc" href="about:blank#^3725bc" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^3725bc</a><a data-href="#^3725bc" href="about:blank#^3725bc" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (2)</a>, <br><br>thus the equality holds. By <a data-href="#^0291fc" href="about:blank#^0291fc" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^0291fc</a><a data-href="#^0291fc" href="about:blank#^0291fc" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (3)</a>, with ,  for some .<br>
□<br><br>For unbounded regions,  for  is no longer true. <br>Example.
Let , the boundary  is . Put , for real ,<br>
, but  since .
<br>Theorem.
Suppose

 is continuous on , , and suppose that  for all  and some fixed . If

then we actually have

i.e.  is a convex function on .
<br>Proof.<br>
WLOG, assume that . Otherwise, replace  by , which also satisfies the conditions, where .<br>We need to show  for all . For each , define an auxiliary function<br><br>Since ,  in , thus . Also, , so that . <br>Let  be the rectangle cut off from  by , then  on ; hence on  by the maximum modulus theorem. <br>For fixed ,  for any sufficiently small , then ; let , then , . We are done!<br>
□<br><img alt="rudin-maximum-modulus-principle-2025052219.png" src="lib\media\rudin-maximum-modulus-principle-2025052219.png"><br><br>The letter j will denote the identity function: . The function which assigns the number 1 to each  will be denoted by 1.<br><img alt="rudin-maximum-modulus-principle-2025052220.png" src="lib\media\rudin-maximum-modulus-principle-2025052220.png"><br>
Note that (c) is a rather weak form of the maximum modulus principle; (c) asserts only that the overall maximum of  on  is attained at some point of the boundary , but (c) does not a priori exclude the existence of local maxima of  in . 
<br>Proof.<br>
By (a) and (b),  contains all polynomials. In conjunction with (c), this shows that  satisfies the hypotheses of Theorem 5.25. Thus every  is harmonic in . We shall use (b) to show that every  actually satisfies the Cauchy-Riemann equation.<br>Let  and  be the differential operators introduced in Sec.11.1. The product rule for differentiation gives<br><br>Fix , and take . Then . Hence  and  are harmonic, so  and . Also,  and . The above identity therefore reduces to . Thus .<br>
□<br>
<img alt="1-rudin-maximum-modulus-principle-2025052220.png" src="lib\media\1-rudin-maximum-modulus-principle-2025052220.png"><br><img alt="2-rudin-maximum-modulus-principle-2025052220.png" src="lib\media\2-rudin-maximum-modulus-principle-2025052220.png"><br>
In particular, the theorem asserts that  is at most countable, unless .
]]></description><link>复变函数\rudin-maximum-modulus-principle.html</link><guid isPermaLink="false">复变函数/rudin-maximum-modulus-principle.md</guid><pubDate>Thu, 22 May 2025 12:09:29 GMT</pubDate><enclosure url="lib\media\rudin-maximum-modulus-principle-2025052218.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\rudin-maximum-modulus-principle-2025052218.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[rudin-zeros-of-holomorphic-functions]]></title><description><![CDATA[ 
 <br><br>See also Stein II, Chapter 5.<br><br>Lemma.

<br>Proof.<br>
<img alt="1-rudin-zeros-of-holomorphic-functions-2025052223.png" src="lib\media\1-rudin-zeros-of-holomorphic-functions-2025052223.png"><br>
□<br><img alt="2-rudin-zeros-of-holomorphic-functions-2025052223.png" src="lib\media\2-rudin-zeros-of-holomorphic-functions-2025052223.png"><br>
This is known as Jensen's formula. The hypothesis  causes no harm in applications, for if  has a zero of order  at , the formula can be applied to .
<br>Proof.<br>
<img alt="4-rudin-zeros-of-holomorphic-functions-2025052223.png" src="lib\media\4-rudin-zeros-of-holomorphic-functions-2025052223.png"><br>
□]]></description><link>复变函数\rudin-zeros-of-holomorphic-functions.html</link><guid isPermaLink="false">复变函数/rudin-zeros-of-holomorphic-functions.md</guid><pubDate>Thu, 22 May 2025 15:19:56 GMT</pubDate><enclosure url="lib\media\1-rudin-zeros-of-holomorphic-functions-2025052223.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\1-rudin-zeros-of-holomorphic-functions-2025052223.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[the logic of Harmoic function]]></title><description><![CDATA[ 
 <br>Suppose  a complex function defined in a plane open set , regarding  a transformation which maps  into . Suppose  differentiable at , WLOG , then <br><br>Since , then <br><br>which suggests the introduction of the differential operators<br><br>Now<br><br>If , then  iff the Cauchy-Riemann equation<br><br>holds for every . In that case we have<br><br>If ,  and  real. Then  splits into .<br>
The laplacian of  is defined to be <br><br>If  is continuous in  and if  then  is said to be harmonic in .<br>
Note that . If  is holomorphic then ,  has continuous deivarives of all orders and , which means "Holomorphic functinos are harmonic."<br>
Every real harmonic function is locally the real part of a holomorphic function, and it will yield information about the boundary behavior of certain classes of holomorphic functions in open discs.]]></description><link>复变函数\the-logic-of-harmoic-function.html</link><guid isPermaLink="false">复变函数/the logic of Harmoic function.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate></item><item><title><![CDATA[常微分方程数值解]]></title><description><![CDATA[ 
 <br><br>见 Fiddie 讲义 11,12,13<br><br><img alt="常微分方程数值解-2025051512.png" src="lib\media\常微分方程数值解-2025051512.png"><br><img alt="1-常微分方程数值解-2025051512.png" src="lib\media\1-常微分方程数值解-2025051512.png"><br>
<img alt="2-常微分方程数值解-2025051512.png" src="lib\media\2-常微分方程数值解-2025051512.png"><br>自治系统就是<br><br>其中  与  无关.<br><img alt="3-常微分方程数值解-2025051512.png" src="lib\media\3-常微分方程数值解-2025051512.png"><br><img alt="5-常微分方程数值解-2025051512.png" src="lib\media\5-常微分方程数值解-2025051512.png"><br><img alt="6-常微分方程数值解-2025051512.png" src="lib\media\6-常微分方程数值解-2025051512.png"><br><br><img alt="7-常微分方程数值解-2025051512.png" src="lib\media\7-常微分方程数值解-2025051512.png"><br><img alt="8-常微分方程数值解-2025051512.png" src="lib\media\8-常微分方程数值解-2025051512.png"><br>
<img alt="10-常微分方程数值解-2025051512.png" src="lib\media\10-常微分方程数值解-2025051512.png"><br><img alt="11-常微分方程数值解-2025051512.png" src="lib\media\11-常微分方程数值解-2025051512.png"><br><img alt="13-常微分方程数值解-2025051512.png" src="lib\media\13-常微分方程数值解-2025051512.png"><br><br><img alt="12-常微分方程数值解-2025051512.png" src="lib\media\12-常微分方程数值解-2025051512.png"><br>
<img alt="14-常微分方程数值解-2025051512.png" src="lib\media\14-常微分方程数值解-2025051512.png"><br><br>考虑以下形式的数值方法<br><br>其中  和  是实常数， 是步长。这个公式被称为线性多步法。当  时，该方法是显式的；否则，它是隐式的。<br>改写为<br><br>其中 .<br><img alt="15-常微分方程数值解-2025051512.png" src="lib\media\15-常微分方程数值解-2025051512.png"><br>
<img alt="16-常微分方程数值解-2025051512.png" src="lib\media\16-常微分方程数值解-2025051512.png"><br><img alt="17-常微分方程数值解-2025051512.png" src="lib\media\17-常微分方程数值解-2025051512.png"><br>
<img alt="18-常微分方程数值解-2025051512.png" src="lib\media\18-常微分方程数值解-2025051512.png"><br>对于线性  步法 <a data-href="#^7fcebc" href="about:blank#^7fcebc" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^7fcebc</a><a data-href="#^7fcebc" href="about:blank#^7fcebc" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a>, 考虑<br><br><br>Theorem (相容条件).
线性  步法相容的充要条件是

<br><img alt="19-常微分方程数值解-2025051512.png" src="lib\media\19-常微分方程数值解-2025051512.png"><br>
<img alt="20-常微分方程数值解-2025051512.png" src="lib\media\20-常微分方程数值解-2025051512.png"><br><img alt="21-常微分方程数值解-2025051512.png" src="lib\media\21-常微分方程数值解-2025051512.png"><br>
<img alt="22-常微分方程数值解-2025051512.png" src="lib\media\22-常微分方程数值解-2025051512.png"><br><br>Example.
判断求解常微分方程初值问题的线性多步法

是否收敛，并说明理由.
<br>首先判断零稳定性.<br>
该方法的特征多项式为, 其根为, 均在单位圆上, 且绝对值为1的根是单根, 故该方法是零稳定的.<br>接下来判断相容性.<br>
, , 故.<br>
所以该方法收敛.]]></description><link>计算数学\常微分方程数值解.html</link><guid isPermaLink="false">计算数学/常微分方程数值解.md</guid><pubDate>Thu, 15 May 2025 04:46:48 GMT</pubDate><enclosure url="lib\media\常微分方程数值解-2025051512.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\常微分方程数值解-2025051512.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[数值积分误差估计]]></title><description><![CDATA[ 
 <br><br>好的，这是一份关于数值积分主要公式的备考资料，包括公式、误差分析、代数精度以及简要的推导思路。<br>数值积分备考资料<br><br>数值积分（Numerical Quadrature）用于逼近定积分  的值，特别是当被积函数  的原函数很难或无法用初等函数表达时，或者当  是以离散数据点形式给出时。<br><br>牛顿-柯特斯公式的基本思想是用一个次数为  的插值多项式  来近似 , 然后计算插值多项式的积分。<br><br>节点  在积分区间  内等距分布。<br><br>使用1次插值多项式（连接  和  的直线）。<br><br>
<br>
估计值:


<br>
误差分析 (截断误差):


<br>
代数精度: 1 (对于次数  的多项式，结果精确)

<br>
简要推导思路:

<br>用线性插值多项式  近似 。
<br>计算  得到 。
<br>误差项可以通过泰勒展开或插值多项式的误差公式推导。对于 ，积分后得到。


<br><br>将  分成  个等长的子区间 , 每个子区间长度 ,。<br>
<br>
估计值:


<br>
误差分析:


<br>
简要推导思路:
将各子区间上的基本梯形公式误差累加起来。。根据中值定理，存在  使得 ，则误差为 。

<br><br>使用2次插值多项式。通常考虑区间  和中点 。<br><br>令 （即每个小子区间的长度）。<br>
<br>
估计值:


<br>
误差分析:


<br>
代数精度: 3 (对于次数  的多项式，结果精确)。比预期的2次要高，这是因为选取节点的方式对称，使得三次项的误差积分为0。

<br>
简要推导思路:

<br>用过点 , ,  的二次插值多项式  近似 。
<br>计算  得到 。
<br>误差项可以通过更高阶的泰勒展开（Peano核方法）或插值多项式误差  推导，但更标准的方法是使用Hermite插值或特定技巧显示其为 。一个常用方法是先对  在  处泰勒展开到4阶。


<br><br>将  分成  个等长的子区间（ 为偶数），每个子区间长度 ，。相当于应用  次基本辛普森公式。<br>
<br>估计值:


<br>误差分析:


<br>简要推导思路:
<br>累加  个基本辛普森公式的误差。每个基本辛普森公式作用的区间长度是 。所以单个误差是 。总共  个这样的应用。<br>总误差是<br><br><br>高斯求积公式的目标是选择节点  和权重  使得求积公式对于尽可能高次的多项式是精确的。<br>
对于  个节点，高斯求积公式可以达到  的代数精度。<br>
通用形式：<br><br>其中  是权函数。节点  是与权函数  在区间  上相关的  次正交多项式的根。<br>
<br>
高斯-勒让德求积 (Gauss-Legendre Quadrature)
这是最常见的高斯求积，其中权函数 ，积分区间通常标准化为 。


<br>
节点 : 是  次勒让德多项式  的根。

<br>
权重 : 。

<br>
估计值 (例子):

<br>: .  (中点公式)
<br>: . 
<br>: . . 


<br>
误差分析:

(对于一般的区间 ，需要做线性变换 ，然后误差项会包含  因子)<br>


<br>
代数精度: 

<br>
简要推导思路:

<br>目标：选择  个节点  和  个权重  (共  个自由参数)，使得公式对次数尽可能高的多项式精确。
<br>令  是一个次数  的多项式。作带余除法 ，其中  是  次正交多项式（其根为 ），。
<br> (由于  与所有次数 &lt; n 的多项式正交)。
<br> (因为  是  的根)。
<br>问题转化为选择  使得  对所有次数  的  精确。这可以通过构造一个  次的插值多项式  使得 ，然后令  (其中  是拉格朗日基函数)。




<br><br>高斯-切比雪夫求积 (Gauss-Chebyshev Quadrature)<br>这是高斯求积的一种特殊情况，权函数 ，积分区间 。<br><br>
<br>节点 : 是  次第一类切比雪夫多项式  的根: , for .
<br>
<br>
权重 : 非常特殊，所有权重都相等 .

<br>
估计值:


<br>
误差分析:


<br>
代数精度: 

<br>
简要推导思路: 同高斯求积一般思路，使用切比雪夫多项式作为正交多项式系。

<br>下面给出误差的推导<br>设  在  上充分光滑，则可以将其展开为 Chebyshev 多项式级数：<br><br>其中  是第  阶 Chebyshev 多项式，  是对应的系数。<br>将上述展开式代入积分：<br><br>利用 Chebyshev 多项式的正交性：<br><br>可以得到<br><br>因此，<br><br>另一方面，考虑数值积分公式：<br><br>利用 Chebyshev 多项式的离散正交性：<br><br>可以得到<br><br>因此，<br><br>所以误差为<br><br>当  充分光滑时，有<br><br>其中  为常数。因此，误差可以表示为<br><br>其中 .<br><br>
<br>中点公式 (Midpoint Rule):  的开型牛顿-柯特斯公式，或  的高斯-勒让德公式（经过调整）。<br>
. 误差: 。代数精度: 1.
<br>龙贝格积分 (Romberg Integration): 对复合梯形公式使用理查森外推法，逐步提高精度。
<br>自适应求积 (Adaptive Quadrature): 根据被积函数在不同子区间的行为自动调整步长或子区间划分，以在满足给定精度要求的情况下最小化计算量。
<br><br><br><br>
<br>
牛顿-柯特斯:

<br>基于插值多项式的误差公式: 。
<br>积分 。如果 ，误差主项包含 。
<br>对于对称节点（如辛普森，中点），有时积分 ，使得误差阶比预期高一阶（即 ）。这需要使用更高阶的埃尔米特(Hermite)插值或Peano核方法。
<br>Peano核方法: 误差  对于所有次数  的多项式 ，。。


<br>
高斯求积:

<br>利用正交多项式的性质。关键在于  次正交多项式  与所有次数小于  的多项式关于权函数  正交。
<br>误差基于  次Hermite插值多项式 ，它在节点  处与  和  都一致 (但高斯公式本身不使用  的值)。实际推导更直接：构造一个在节点  处取值为  的  次多项式 。那么  在  处为0。误差 。 。但高斯公式误差是关于  的，这是因为节点  的特殊选择（正交多项式的根）。
<br>一个更标准的误差推导是考虑一个在  处与  值相同的  次Hermite插值多项式 ，它在  处满足  和 （尽管公式不直接用 ）。积分  得到高斯公式的权重。误差 。


<br>这份资料应该能帮助你复习数值积分的主要内容。祝你考试顺利！]]></description><link>计算数学\数值积分误差估计.html</link><guid isPermaLink="false">计算数学/数值积分误差估计.md</guid><pubDate>Thu, 15 May 2025 03:42:02 GMT</pubDate></item><item><title><![CDATA[正交多项式]]></title><description><![CDATA[ 
 <br><br>
<br>
Legendre多项式：


<br>
Laguerre多项式：


<br>
Hermite多项式：


<br>
Chebyshev多项式：


<br>我们关心的是 Legendre 多项式和 Chebyshev 多项式.<br><br>Legendre多项式是以  为定义域，以  为权函数的正交多项式。满足递推关系<br><br><br>Chebyshev多项式是以  为定义域，以  为权函数的正交多项式。满足递推关系<br>]]></description><link>计算数学\正交多项式.html</link><guid isPermaLink="false">计算数学/正交多项式.md</guid><pubDate>Mon, 19 May 2025 14:50:53 GMT</pubDate></item><item><title><![CDATA[交换代数]]></title><description><![CDATA[ 
 <br><br>参见 Atiyah, <a data-tooltip-position="top" aria-label="https://phanpu.github.io/2021/12/26/a-rough-reading-note-for-atiyah-s-commutative-algebra/Commutative_Algebra_Atiyah.pdf" rel="noopener nofollow" class="external-link" href="https://phanpu.github.io/2021/12/26/a-rough-reading-note-for-atiyah-s-commutative-algebra/Commutative_Algebra_Atiyah.pdf" target="_blank">Commutative_Algebra_Atiyah.pdf</a><br>Exercise.
设  是环, 令

证明:

<br> 是  的可逆元  是  中可逆元且  是幂零元。
<br> 幂零  幂零。
<br> 是零因子  存在着环  的非 0 元  使得 。
<br>如果 ,  就叫本原多项式。证明: 如果 , 那么  本原  均为本原。

<br>Proof.<br>
<br>: 设 , 不妨 , 否则考虑 , 则 , 记幂数为 , 从而 。（实际上就是题 1）
<br>: 设 , 且 , 令 , 可得 , 从而  可逆。<br>从而有 （线性代数的结论）, 特别的 , , 从而 , 如此往下, , 故  幂零。对其余同理。（由于  幂零，则  幂零，故  依然可逆，对  重复上述论证可得  幂零，依此类推）<br>
□<br><br>Proposition.
极大理想都是素理想.
<br>Exercise.
.
<br>
这里使用  而不是 ，是因为后者只在  的情况下有定义，而前者总是良好定义的.
<br>Exercise.
<img alt="交换代数-2025052111.png" src="lib\media\交换代数-2025052111.png"><br>
<img alt="1-交换代数-2025052111.png" src="lib\media\1-交换代数-2025052111.png">
<br>解释 3 的证明：<br>这个证明的目的是要说明：在一个局部环  上，如果两个有限生成的 -模  和  的张量积 ，那么  和  中至少有一个是零模。<br>证明过程可以分解为以下几个步骤：<br><br>引入剩余域 (Residue Field)<br>设  是一个局部环，其唯一的极大理想为 。<br>考虑 。因为  是极大理想，所以  是一个域，称为  的剩余域。<br>张量积与剩余域<br>我们已知 。<br>将这个等式两边都用  在  上作张量积，可以得到：<br><br>利用张量积的结合律和换环定理 (change of rings, ，其中  是一个 -代数)，这里 ，我们有：<br><br>根据题目2的结论 ()，我们知道：<br>
<br>。我们记 。
<br>。我们记 。
<br>因此，上面的等式变为 。 注意  和  都是域  上的向量空间。<br>向量空间的张量积<br>我们得到了 ，其中  和  是域  上的向量空间。<br>对于域上的向量空间 ，如果 ，那么必然有  或者 。（如果  均非零，它们分别有非空基底，则  的基底由它们基底元素的张量积构成，因此  也非零。）<br>证明中使用了Hom函子的性质来推导这一结论：<br>
<br>利用张量-Hom伴随 (tensor-hom adjunction)：


<br>由于 ，那么左边的  只包含零映射（从零空间到  的唯一线性映射是零映射）。
<br>因此，右边的  也必须为零（即只包含零映射）。
<br>对于域  上的向量空间  和 ，如果 ，那么  或者 。（如果  且 ，我们可以构造一个非零的从  到  的线性映射）。
<br>所以，从  可以得出：<br>
 或者 。
<br>如果 ，这意味着从  到  的唯一线性映射是零映射。但如果 ，那么其上的恒等映射  就不是零映射。所以， 必然意味着 。
<br>综上，我们得出结论： 或者 。也就是  或者 。
<br>应用中山正引理 (Nakayama's Lemma)<br>我们已知  是一个局部环， 是其唯一的极大理想。 和  是有限生成的 -模。<br>中山正引理的一个形式是：若  是环  上的有限生成模， 是  的一个理想且  包含于  的 Jacobson 根  中。如果 ，则 。<br>对于局部环 ，其 Jacobson 根就是其唯一的极大理想 。<br>所以：<br>
<br>如果 ，这意味着 。由于  是有限生成的 -模，根据中山正引理，可得 。
<br>同理，如果 ，这意味着 。由于  是有限生成的 -模，根据中山正引理，可得 。
<br>结论<br>因为我们已经证明了  或者 ，所以根据中山正引理，必然有  或者 。<br>这就完成了证明。这个证明巧妙地利用了局部环的性质、剩余域、张量积的性质以及关键的中山正引理。<br>Exercise.
<img alt="2-交换代数-2025052111.png" src="lib\media\2-交换代数-2025052111.png">
<br>证明中指出 ""。这里  指的是由  生成的 -子模，即 。<br>作为 -模， 是所有形如 （其中 ）的多项式的集合。它可以看作是 -模 ，，，… 的直和：<br><br>这意味着  是一个自由  -模，其基为 。]]></description><link>交换代数\交换代数.html</link><guid isPermaLink="false">交换代数/交换代数.md</guid><pubDate>Wed, 21 May 2025 17:00:26 GMT</pubDate><enclosure url="lib\media\交换代数-2025052111.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\交换代数-2025052111.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[环论]]></title><description><![CDATA[ 
 <br><br>Theorem.
设  为含  的结合环，  ．若  ，且关于  的方程

在  中有解．证明： ．
<br>Proof.<br>
1）首先注意到<br><br>结果有：<br><br>因此有  可逆且 <br>2）现在考虑  ，则有  ，结合前面所证  可逆，因此得  ．进而有<br><br>亦即  ．<br>□<br>Exercise (Kaplansky).
含幺环中某元若有多于一个右逆，则它必然有无限多个右逆.
<br>Proof.<br>
设  有多于一个右逆，则它是左零因子，设理想<br><br>只需要证明： 是无限集. 这是因为若  是  的一个右逆，则 ， 也是  的右逆.<br>考虑反证，假设  是有限集 ，() 于是 . 考虑 ，它们显然也在  内，但 ，两两不同，故  是  的一个置换. <br>取  为  的一个右逆，因为  是零因子，故 （若  是  的左右逆，则  为 unit，不是零因子）从而 ，但是 ，故 . 于是  for some . 同时 ， for some . 于是 <br><br>矛盾！<br>□<br>Exercise (注意环的乘法不包含可逆性).
设  为整环， 和  为互素的正整数，. 如果 ，. 求证：.
<br>Proof.<br>
不妨设 ，由于 ，故存在整数  使得 ，如果  则  故<br><br>由于  是整环，， 不是零因子，所以  是零因子，故为 0. 也就是 .<br>若  则考虑 .<br>
□<br>Remark.
注意环关于乘法一般不可逆. 所以  时， 是没有意义的.
]]></description><link>近世代数\环论.html</link><guid isPermaLink="false">近世代数/环论.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate></item><item><title><![CDATA[群论]]></title><description><![CDATA[ 
 <br><br>见《近世代数三百题》<br>Proposition.
1．9．9．设  为自然数，则<br>
（1）  当且仅当  ．<br>
（2）如果  两两互素，则  ．
<br>Proposition.
1．9．10．试证  阶群一定是循环群．
<br>Proof.<br>
首先利用 Sylow 定理证明 . 借助 <a data-href="#^785b89" href="about:blank#^785b89" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^785b89</a><a data-href="#^785b89" href="about:blank#^785b89" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Proposition 1</a> 可知  是循环群.<br>
□<br>Definition.
Let  be a subgroup of . Define

to be the intersection of all conjugates of .
<br>Exercise.

<br>Show that  is a normal subgroup of .
<br>Show that if  is finite, then  is finite. (Hint: first show that the intersection above defining  is essentially a finite intersection.)

<br>Proof.<br>
(1) We check that for any ,<br><br>with  in the notation. So  is a normal subgroup of .<br>(2) We start with a lemma: if  and  are subgroups of  of finite index. Then  is a subgroup of  of finite index. The easiest way to see this is to let  act on the left cosets  by left multiplication. Then the stabilizer group at  is precisely . We know that the index of  inside  is precisely the number of elements in the orbit of the identity coset  in  under this action. In particular, . It then follows that .<br>Now, we come back to the proof of (2). As  is assumed to be finite, we may choose a finite set of coset representatives  of . Then for every element  (writing  ), we have<br><br>So  is the intersection<br><br>which is the intersection of finitely many finite index subgroups. By the lemma above,  is finite as well.<br>
□]]></description><link>近世代数\群论.html</link><guid isPermaLink="false">近世代数/群论.md</guid><pubDate>Thu, 08 May 2025 07:15:30 GMT</pubDate></item><item><title><![CDATA[Broad classifications]]></title><description><![CDATA[ 
 <br><br>Let  be a group. The letter , , and  are used for primes. Moreover, they are assumed to be distinct.  is a positive integer.<br><br> is simple.<br><br>.  has nontrivial center due to the class equation. Assume  then<br><br>which is a contradiction. Then  is a nontrivial normal subgroup of .<br><br>.  is not simple since  by Sylow III theorem.<br><br>Claim  is not simple.<br><br>By Sylow III, we know . Then . The Sylow  -subgroups is normal, thus  is not simple.<br><br>By Sylow III, . If  then we are done. As , , this cannot happen for . Now we consider the case .<br>Since each Sylow-  subgroup has order , the intersection of two distinct Sylow-  subgroups must be trivial. Thus there are  elements of order . There left  elements. Since  by Sylow I, the remaining elements must form the unique Sylow-  subgroup and we get . Thus  is not simple.<br><br> is not simple. <br>Assume  is simple, then . Since , and , then . Then there exists  elements of order ,  of order  and  of order . <br><br>which is a contradiction.<br><br>.<br>Claim  is not simple.<br>. If  then we are done. <br>If  then consider the action<br><br><br>Then . Since the action is transitive, . Since  then , otherwise . Therefore  is a proper nontrivial normal<a data-footref="[inline0" href="about:blank#fn-1-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a> subgroup of .<br><br>.<br>Claim  is not simple.<br>. If  then we are done. <br>If , consider the action<br><br><br>.  as the action is transitive.  as . Thus  is proper nontrivial normal subgroup of .<br>
<br>
<br>The kernel is always normal.<a href="about:blank#fnref-1-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>近世代数\broad-classifications.html</link><guid isPermaLink="false">近世代数/Broad-classifications.md</guid><pubDate>Fri, 09 May 2025 02:43:00 GMT</pubDate></item><item><title><![CDATA[Decomposition-of-Finite-Abelian-Groups]]></title><description><![CDATA[ 
 <br><br><a data-tooltip-position="top" aria-label="https://kconrad.math.uconn.edu/blurbs/grouptheory/finite-abelian.pdf" rel="noopener nofollow" class="external-link" href="https://kconrad.math.uconn.edu/blurbs/grouptheory/finite-abelian.pdf" target="_blank">finite-abelian.pdf</a><br>Definition (indecomposable).
Let  be a nontrivial finite abelian group. Call  indecomposable if we can't write  for some nontrivial subgroups  and . Call  decomposable if we can write  for two nontrivial subgroups  and .
<br>
<br>A group of prime order is abelian (it's cyclic) and is indecomposable.
<br>A cyclic group of prime-power order is indecomposable because if it could be decomposed into  for some nontrivial subgroups  and , both  and  would contain a subgroup of order . This would imply that the original group  has more than one subgroup of order , contradicting the property that a cyclic group has at most one subgroup of each size.
<br>Theorem.
Let  be a cyclic group. Then, for every divisor  of , there is a unique subgroup of  of order .
<br>Proof.<br>
Let  and . Suppose that , and let . Then , and so  is a subgroup of  of order .<br>Now suppose that  is any subgroup of  of order . Then  for some integer . Also, , and so . Thus,  for some integer , and so . Therefore, , and so .<br>
□<br>Remark.
The groups  and  are not isomorphic since  is indecomposable. Or since  has an element of order 4 and  does not.
<br>Theorem (Theorem 2.5).
A nontrivial finite abelian group is a direct sum of indecomposable subgroups.
<br>
The proof is trivial.
<br>Proof.<br>
This argument will be the same as the standard proof of the existence of prime factorization in the positive integers. We argue by induction on the order  of the group.<br>For the base case , abelian groups of order 2 are indecomposable since 2 is prime. Suppose  and each nontrivial abelian group of order less than  is a direct sum of indecomposable subgroups. Let  be abelian of order .<br>Case 1:  is indecomposable. We are done, since  is a direct sum of itself (one term).  <br>Case 2:  is decomposable. We have  for nontrivial subgroups  and . Then  with  and  being greater than 1 , so they are less than . By induction,<br><br>for indecomposable  and . Then .<br>
□<br><br>Lemma.
If  is an abelian group and  where  then  for the subgroups  and .
<br>Proof.<br>
The subsets  and  are subgroups because  is abelian, e.g., if  and  then . Using multiplicative notation for a moment, we have  when , but it might not be true if .<br>To show , write  for  since . For all ,<br><br>We have  since , and similarly . Thus .<br>To show , if  then  and , so  . Alternatively, the order of  divides  and , so the order divides  and thus .<br>We have shown  and , so .<br>
□<br>Remark.
<a data-href="#^897c32" href="about:blank#^897c32" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^897c32</a><a data-href="#^897c32" href="about:blank#^897c32" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Lemma 5</a>  has a uniqueness aspect: , and these are the unique subgroups of  with orders  and . We will not need this.
<br>Theorem.
An indecomposable finite abelian group has prime-power order.
<br>Proof.<br>
Let  be a nontrivial abelian group. We will prove the contrapositive of the theorem for  : if  is not a prime power then  is decomposable. By <a data-href="#^897c32" href="about:blank#^897c32" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^897c32</a><a data-href="#^897c32" href="about:blank#^897c32" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Lemma 5</a>, we are done.<br>
□<br>Lemma (3.4).
A nontrivial finite abelian -group with a unique subgroup of order  is cyclic.
<br>Proof.<br>
Let  be a finite abelian -group with a unique subgroup of order  and let  be the largest order of the elements of . Then  and each element of  has order  where  (  is a -group and  is the maximal order), so all elements of  have order dividing .<br>Let  have order . Since  has order  is a subgroup of order , so it is the only one by assumption. To prove , we'll assume  and get a contradiction.<br>The quotient group  (this makes sense since  is abelian) is nontrivial, abelian, and of  -power order. By Cauchy's theorem,  has an element of order , say . That means  and . So we can write<br><br>for some . Since  (all elements of  have order dividing  ) and ,<br><br>Since  has order , so . Thus  for some , so . Rewrite that as . The only subgroup of order  is in , so . This contradicts , so .<br>
□<br>Remark.
<a data-href="#^4f15a0" href="about:blank#^4f15a0" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^4f15a0</a><a data-href="#^4f15a0" href="about:blank#^4f15a0" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Lemma 8 (3.4)</a>  is true without assuming  is abelian when , but the quaternion group  has a unique subgroup of order 2 and is not cyclic.
<br>Theorem.
Let  be a finite abelian group and let  have maximal order in . There is a subgroup  such that .
<br>
See r.f. <a data-tooltip-position="top" aria-label="https://kconrad.math.uconn.edu/blurbs/grouptheory/charthy.pdf" rel="noopener nofollow" class="external-link" href="https://kconrad.math.uconn.edu/blurbs/grouptheory/charthy.pdf" target="_blank">charthy.pdf</a> section 5.
<br><img alt="Decomposition-of-Finite-Abelian-Groups-2025041818.png" src="lib\media\decomposition-of-finite-abelian-groups-2025041818.png"><br>
<img alt="1-Decomposition-of-Finite-Abelian-Groups-2025041818.png" src="lib\media\1-decomposition-of-finite-abelian-groups-2025041818.png">]]></description><link>近世代数\decomposition-of-finite-abelian-groups.html</link><guid isPermaLink="false">近世代数/Decomposition-of-Finite-Abelian-Groups.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate><enclosure url="lib\media\decomposition-of-finite-abelian-groups-2025041818.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\decomposition-of-finite-abelian-groups-2025041818.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Elementary Field Theory]]></title><description><![CDATA[ 
 <br><br>Exercise.
<img alt="group-representation-2025050911.png" src="lib\media\group-representation-2025050911.png">
<br>A perfect field  can be characterized in several equivalent ways:<br>
<br>Separable Extensions: Every algebraic extension of  is a separable extension. (An algebraic extension is separable if the minimal polynomial of every element in the extension over  has distinct roots.)
<br>Separable Polynomials: Every irreducible polynomial in  (the ring of polynomials with coefficients in ) is separable (has distinct roots in its splitting field).
<br>Characteristic Property:

<br>If  has characteristic 0 (like ), it is always perfect.
<br>If  has characteristic  (where  is a prime number), then  is perfect if and only if the Frobenius endomorphism , defined by  for all , is surjective. This means that every element in  is a -th power of some element in  (i.e., ). Since the Frobenius endomorphism is always injective for fields, this condition means it must be an automorphism.


<br>Examples of perfect fields include:<br>
<br>All fields of characteristic 0 (e.g., the rational numbers , the real numbers , the complex numbers ).
<br>All finite fields (e.g.,  for a prime , or ). In finite fields, any injective map from the field to itself must also be surjective.
<br>All algebraically closed fields.
<br>Now, an imperfect field is a field that does not satisfy these conditions. Based on the above:<br>
<br>An imperfect field must have characteristic  for some prime .
<br>In an imperfect field  of characteristic , the Frobenius endomorphism  is not surjective. This means there exists at least one element in  that cannot be written as the -th power of any element in  (i.e., ).
<br>Imperfect fields have at least one irreducible polynomial that is inseparable (i.e., has multiple roots in an extension field).
<br>There exist algebraic extensions of an imperfect field that are not separable.
<br>Exercise (yau-2021-poblem-3).
<img alt="elementary-field-theory-2025051600.png" src="lib\media\elementary-field-theory-2025051600.png">
<br>NTS: the ideal  is maximal, i.e.  is irreducible. It suffices to show  irreducible in , where  is the fraction field of . Since  is quadratic, if irreducible, it must have root in , denoted , where . Then<br><br>Consider the smallest orders of  in the polynomials; the left is even, the right is odd; contradiction! Thus  is an integral domain.]]></description><link>近世代数\elementary-field-theory.html</link><guid isPermaLink="false">近世代数/elementary-field-theory.md</guid><pubDate>Thu, 15 May 2025 16:10:09 GMT</pubDate><enclosure url="lib\media\group-representation-2025050911.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\group-representation-2025050911.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Elementary Ring Theory]]></title><description><![CDATA[ 
 <br><br>See 肖梁<br>In this course, all rings are assumed to be unital and .<br><img alt="1-elementary-ring-theory-2025050816.png" src="lib\media\1-elementary-ring-theory-2025050816.png"><br>
Field only has zero ideal. 
<br>If  is an ideal such that  then ,  is an ideal of the field  thus is zero. Therefore,  is maximal.<br>Exercise.
Let  be a commutative ring. If all submodules of finitely generated free modules over  are free over , then  is a PID.
<br>Definition (Finitely generated free module over ).
A module  over a ring  is called a finitely generated free module if it has a basis consisting of a finite number of elements.
This means there exists a finite set of elements  such that every element  can be written uniquely in the form

for some unique coefficients .
Such a module is isomorphic to the direct sum of  copies of , denoted .
<br>
The definition of  as  -module  is similar to  as  -linear space.
<br>Definition (free -module).
An -module  is a free -module if it has a basis, i.e., there exists a subset  such that for every , there is a unique finite subset  and unique scalars  such that . Equivalently,  is isomorphic to a direct sum of copies of , denoted  for some index set .
<br><br>Theorem.
Let  be a commutative ring. If all submodules of finitely generated free modules over  are free over , then  is a PID.
<br>Proof.<br>
First prove that  is an integral domain. Suppose that  with . Consider ; it is a submodule of free module; so  is a free -module. However, we know that  kills all of  because ; this contradicts that  is a free -module.<br>Let  be an ideal; it is then a free -submodule of . We claim that  is a free module of rank 1 over . Suppose not, then there exist  forming an -basis of . But if , we know that , contradiction! This says that  is free of rank one, i.e.  is generated by one element  so that  is a principal ideal. Thus  is a PID.<br>
□<br><br>Okay, let's break down this proof step by step.<br>The Statement to be Proven:<br>"Let  be a commutative ring. If all submodules of finitely generated free modules over  are free over , then  is a PID."<br>Let's define the key terms:<br>
<br>Commutative Ring (): A set with addition and multiplication operations that satisfy certain properties (associativity, commutativity of both operations, distributivity, additive identity 0, additive inverses, multiplicative identity 1). "Commutative" means  for all .
<br>Module over  (or  -module): Similar to a vector space over a field, but scalars come from a ring .
<br>Free  -module: An  -module that has a basis, i.e., a linearly independent spanning set. A finitely generated free module has a finite basis.  itself is a free  -module of rank 1 (with basis ).  (tuples of  elements from ) is a free  -module of rank .
<br>Submodule: A subset of a module that is itself a module under the same operations and with scalars from the same ring.
<br>PID (Principal Ideal Domain): An integral domain in which every ideal is principal.

<br>Integral Domain: A commutative ring with no zero divisors (if  and , then either  or ).
<br>Ideal: A submodule of  (when  is considered as a module over itself). More formally, a subset  such that  is a subgroup of , and for any  and , .
<br>Principal Ideal: An ideal generated by a single element, i.e., an ideal of the form  for some .


<br>The Hypothesis: All submodules of finitely generated free modules over  are free over .<br>The Goal: Prove that  is a PID. This requires proving two things:<br>
<br> is an integral domain.
<br>Every ideal in  is principal.
<br><br>Proof Breakdown:<br>Part 1: Prove that  is an integral domain.<br>
<br>
"Suppose that  with ."<br>
This is the standard way to start a proof that  is an integral domain by contradiction. We assume  is not an integral domain, which means there exist non-zero elements  and  whose product is zero. Our goal is to show this assumption leads to a contradiction, forcing us to conclude that such  and  cannot exist (meaning if , then  or ).

<br>
"Consider ; it is a submodule of free module; so  is a free  -module."

<br> itself can be considered as a (finitely generated) free  -module of rank 1 (its basis is just the element ).
<br> is the set . This is an ideal in , and every ideal is a submodule of  (when  is viewed as an  -module).
<br>Since  is a finitely generated free module, and  is a submodule of , the hypothesis of the theorem applies: " is a free  -module."


<br>
"However, we know that  kills all of  because ; this contradicts that  is a free  -module."

<br>"Kills" means  for all . Let . Then  for some .
<br>So, . Since we assumed  (and  is commutative, so ), we have .
<br>So,  for all .
<br>Now, why is this a contradiction to  being a free  -module?

<br>If  is a free  -module, it has a basis.
<br>Case 1:  (the zero module). This means . But we started by assuming  (i.e., ). So this case is ruled out by our initial assumption about .
<br>Case 2: . Then  is a non-zero free  -module. Let  be a basis for . Since , there is at least one basis element, say .
<br>Since , we know from above that .
<br>If an element  annihilates a non-zero element  in a free module, this means that the module cannot be free unless  forces all coefficients to be zero in some sense.
<br>More precisely: A free module  over a ring  has the property that if  for some  and , then either  is a zero divisor for elements related to , or . If  is free with basis , then any  can be written as . If , then by linear independence,  for all .
<br>Here,  is free. If , it has a non-empty basis, say . Take any basis element . We know . Since  (it's a basis element of a non-zero module) and  (by assumption), this implies that  is a zero-divisor "acting on" .
<br>The crucial property of a free module  over a ring  is that if  annihilates every element of  (i.e.,  for all ), and , then  must be .
<br>In our situation,  and  (since ). We have  for all . This means  is a non-zero element that annihilates the entire non-zero module . This can only happen if  is not actually free (unless  itself has issues). The only way a non-zero scalar can annihilate every element of a non-zero free module is if the module itself is the zero module (which we've ruled out because ) or if the ring itself isn't "nice."
<br>The more direct contradiction: A non-zero free module cannot have a non-zero annihilator. The set of elements  such that  for all  is called the annihilator of , denoted . If  is a free  -module and , then .<br>
Here, . Since ,  (as ). We found that . But we assumed . This means , which contradicts the fact that  is a non-zero free module.




<br>
This contradiction shows that our initial assumption ( with ) must be false. Therefore,  must be an integral domain.

<br>Part 2: Let  be an ideal; it is then a free  -submodule of . We claim that  is a free module of rank 1 over .<br>
<br>
"Let  be an ideal; it is then a free  -submodule of ."

<br>An ideal  of  is, by definition, a submodule of  (when  is considered as an  -module).
<br>As established before,  is a finitely generated free  -module (rank 1, basis ).
<br>By the hypothesis of the theorem, any submodule of a finitely generated free module is free. Thus,  must be a free  -module.


<br>
"We claim that  is a free module of rank 1 over ."<br>
This means  should have a basis consisting of a single element. If  for some , then  would be its basis (assuming ).

<br>
"Suppose not, then there exist  forming an  -basis of . But if , we know that , contradiction!"

<br>Let's assume the rank of  (as a free  -module) is not 1.

<br>Could the rank be 0? If rank is 0, , which is the principal ideal . This fits the "rank 1 or 0" pattern, as  is generated by one element. So the argument is primarily against rank .
<br>So, assume the rank is greater than or equal to 2. This means there are at least two distinct basis elements in any basis for . Let  and  be two distinct elements from such a basis.


<br>Consider the expression: .

<br>Here,  and  are elements of the ideal , and also elements of the ring .
<br>The coefficients are  and , which are also elements of .
<br>The expression is a linear combination of the basis elements  and .
<br>.
<br>Since  is a commutative ring (this was stated at the beginning), .
<br>So, .


<br>This is a linear combination of basis elements that equals zero:<br>
, where  and .
<br>For a set of elements to be a basis, they must be linearly independent. This means if a linear combination of them is zero, all coefficients must be zero.
<br>So, we must have  and .
<br>But if , then it cannot be a basis element of a free module (unless the module is the zero module, which would have an empty basis or rank 0, not ). Basis elements are non-zero.
<br>The contradiction: We found a linear combination of distinct basis elements  which is . For this to not violate linear independence, the coefficients must be zero. That is,  and . But basis elements of a free module must be non-zero if the module itself is non-zero (and if  has rank , it's non-zero).
<br>This specific relation  is always true in a commutative ring. If  are part of a basis for an ideal , and these are considered as elements of the module , the coefficients in the linear combination are  and .
<br>If  is non-zero, and its basis has at least two elements . Then .
<br>For this to be a non-trivial relation, at least one of the coefficients  or  must be non-zero. Since  are basis elements, they are non-zero (assuming ). So the coefficients  and  are non-zero (since  is now an integral domain, if , then , which is not possible for a basis element).
<br>So we have a linear combination of basis elements equal to zero, where the coefficients are non-zero elements from . This contradicts the definition of a basis for a free module over an integral domain  (unless  was the zero ring, which it isn't as it has a 1 and is an integral domain).
<br>Therefore, the assumption that the rank of  is  must be false.


<br>
"This says that  is free of rank one, i.e.  is generated by one element  so that  is a principal ideal."

<br>Since  is a free  -module and its rank cannot be , its rank must be 0 or 1.

<br>If rank is 0, then , which is the principal ideal .
<br>If rank is 1, then  has a basis consisting of a single element, say , where . This means every element  can be written uniquely as  for some . This is precisely the definition of the principal ideal generated by , i.e., .


<br>So, every ideal  in  is a principal ideal.


<br>Conclusion:<br>
<br>We have shown that  is an integral domain (Part 1).
<br>We have shown that every ideal  in  is a principal ideal (Part 2).
<br>By definition, an integral domain in which every ideal is principal is a Principal Ideal Domain (PID).<br>
Thus, the proof is complete.<br><br>Exercise.
Let  be a finite field with  elements.

<br>How many monic irreducible polynomials are there in  of each degree ?
<br>What are the possible Galois groups of the splitting field of a (not necessarily irreducible) polynomial of degree 5 over ? Why?

<br>Proof.<br>
(1) Each irreducible polynomial of degree 2 has exactly two zeros in .<br>
Denote one zero of the irreducible polynomial  by , then , otherwise , thus , which is a contradiction. 
Claim that . Since , , then , ; but  and the minimal polynomial of  is unique (by definition); so .  is the spliting field of  over , with degree . , which means  is a 2-dimensional vector space over ; , thus . 
Claim that . This refers to the construction of , more generally, , which is the splitting field of  over . It suffices to verify that every field with  elements is a<a data-footref="[inline0" href="about:blank#fn-1-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a> splitting field of  over . Consider the multiplitcative group, ; it has  elements. For any , by Lagrange's theorem from group theory,  is divided by , the order of ; thus ;  is the solution of . Including , then any element in  is the solution of , which has  distinct zeros. Since  also has  distinct elements, they correspond to  different roots of . By the definition of , ; thus ; similarly, .
<br>So there are  irreducible polynomials of degree 2.<br>
This is because, every element in the extension of  has a unique minimal polynomial , which is the definition of minimal polynimial. We know that  is the minimal polynomial of exactly two elements,  in ; each irreducible polynomial of degree 2 corresponds to 2 different elements in . Thus there are  irreducible polynomials of degree 2. We are done!
<br>Similarly, there are  irreducible polynomials of degree 3, and there are  irreducible polynomials of degree 5.<br>Each irreducible polynomial of degree 4 corresponds to four elements of ; so there are  irreducible polynomials of degree 4.<br>Each irreducible polynomial of degree 6 corresponds to six elements of ; there are  such polynomials.<br>
We know that

<br>(2) The factorization of  into irreducibles corresponds to partitions of 5:<br>If  is irreducible, the splitting field is . The associated Galois group is .<br>If  factors as the product of a degree 2 and a degree 3 polynomials, the splitting field is . The associated Galois group is .<br>In other cases, we can get similarly , and . The associated Galois groups are , respectively.<br>
□<br><br><img alt="elementary-ring-theory-2025050920.png" src="lib\media\elementary-ring-theory-2025050920.png"><br><br>Exercise.
Suppose that  is a UFD for which every nonzero prime ideal is maximal. Show that  is a PID.
<br>Proof.<br>
We first prove that for two prime elements  and , either they are associates, or there exists  such that . Indeed, if  and  are not associates, the ideals  and  cannot have containment relations (otherwise, say , we must have ; which would immediately forces  and  to be associates). Now as nonzero prime ideals (such as  and ) are maximal, the ideal  must be the unit ideal, i.e. there exists  such that .<br>Next, we show that if, in the factorization of two elements , no prime factors of  are associates of prime factors of , then there exists  such that . By induction, it suffices to prove that: if , then . Indeed, write  and  for , then<br><br>This implies that .<br>We finally prove that  is a PID. Let  be a nonzero ideal. Pick an element  with minimal number of prime factors. We show that . If , then write  and  and  with , and  have distinct prime factors. By the discussion above, there exist  such that . This implies that , contradicting with the minimality of prime factors of . Thus  is a principal ideal.<br>□<br><br>Proposition.
PID is Bézout integral domain; UFD may not.
<br>Definition (Bézout domain).
A Bézout domain is an integral domain in which every finitely generated ideal is principal. 
<br>
Equivalently, an integral domain is called Bézout domain provided that for any ,  exists, i.e. , i.e.  s.t.<br>

<br>By the definition, PID is Bézout domain. But there exists non-Bézout UFD, e.g. . Consider  in ; UFD admits gcd; , but no  satisfy , as letting , then . (a contradiction!)<br>
<br>
<br>"a" means "the", since the splitting field is unique up to isomorphism.<a href="about:blank#fnref-1-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>近世代数\elementary-ring-theory.html</link><guid isPermaLink="false">近世代数/elementary-ring-theory.md</guid><pubDate>Sun, 11 May 2025 05:39:13 GMT</pubDate><enclosure url="lib\media\1-elementary-ring-theory-2025050816.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\1-elementary-ring-theory-2025050816.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Galois-theory]]></title><description><![CDATA[ 
 <br><br><br>因为 Galois 理论本来是研究多项式的根的，所以我们知道 normal and separable 的条件是必然的. 我们称一个扩张  是 normal，如果  在  内有一个根，那么  的所有根都在  内. 我们称一个扩张  是 separable，如果任意  的极小多项式  都无重根. 这保证了我们在进行多项式的根的置换的时候是对于在  中的  个不同元素来进行的（若  是有限扩张）. <br><br>Galois 理论的基本定理揭示了群和域之间存在的反序一一对应．确切地说，设  是有限 Galois 扩张， 是域同构   ．令  的中间域  的子群  ．考虑如下两个映射：<br>
 ，其中  ，<br> ，其中  ．<br>注意到  也是有限 Galois 扩张， ．从而有<br><br>Galois 理论的基本定理（主要）是说：<br>
（1）  和  是互逆的反序的映射．于是有<br><br>（2） 是  的正规子群当且仅当  是正规扩张；或等价地， 是正规扩张当且仅当  是  的正规子群．在这种情况下，有<br><br>或等价地，<br><br><br>Lemma (Artin 引理).
设  为域  的一个有限自同构群， 为它的不动域，则  ．
<br><br>Theorem (Primitive element theorem).
Theorem 16.3.1. A finite separable extension of fields is generated by one element.
<br>In fact, we have a stronger statement: if  with  algebraic over  and  separable over . Then  for some .<br><br>See 代数学引论·丁、聂 p.247.<br><br>下面说明域  的 Galois 群  同构于半直积 <br><br>这个 Galois 群作用只需要考虑在生成元  和  上，只有如下可能：<br><br><br>恰好就是 .]]></description><link>近世代数\galois-theory.html</link><guid isPermaLink="false">近世代数/Galois-theory.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate></item><item><title><![CDATA[Galois-theory-at-work]]></title><description><![CDATA[ 
 <br><br><br>Exercise.
证明：

<br>存在恰有  个元素的域  ；
<br>如果  是一个  元域，则  ；
<br>设  是有限域扩张，则映射  是域自同构，且满足


<br>域扩张  的  群  是由  生成的循环群；
<br> 关于  中乘法成为一个循环群．特别地，存在  使  ．

<br>Proof.<br>
<br>
Let  be the splitting field of the polynomial . Since ,  has exactly  roots in the splitting field , denoted as . Directly verifying that  is a subfield, we conclude that .

<br>
If , then , which implies . Thus,  is also an -th degree extension of , similar to . Since  forms a group of order  under multiplication, we have  for all . This means that the field  consists of the  roots of  in . Therefore,  and  are both splitting fields of the same polynomial, implying .

<br>
From the proof of conclusion (1), we know that elements in  satisfy , i.e., . Because , we have . It's easy to prove that  is a field isomorphism.

<br>
Let  be an -th degree extension; then  is a field with  elements. From the proof of conclusion (2), we know that  is a splitting field of the separable polynomial , so . On the other hand, for any  is not an identity map (otherwise, the polynomial  would have  roots in , which contradicts ), so  is a cyclic group generated by .

<br>
Let  be an element of maximal order  in the finite abelian group . We claim that

Indeed, suppose the order of  is . If , then . Let  be the greatest common divisor of  and .

is the irreducible factorization, . Then , the order of  is , and the order of  is . It is easy to prove that the order of  is , which contradicts the choice of . Therefore, all elements in  are roots of the equation , so , which means  is a cyclic group generated by .

<br>□<br><br><a data-tooltip-position="top" aria-label="https://kconrad.math.uconn.edu/blurbs/galoistheory/galoisapp.pdf" rel="noopener nofollow" class="external-link" href="https://kconrad.math.uconn.edu/blurbs/galoistheory/galoisapp.pdf" target="_blank">galoisapp.pdf</a><br> is a Galois extension of  because:<br>
<br>
, and , .

<br>
 is a root of , and all roots of  are in  because .

<br>
 is a root of , and all roots of  are in .

<br>
 is a splitting field of  over , making it a normal extension.

<br>
Since  has characteristic 0,  is a separable extension of .

<br>
Therefore,  is a Galois extension of .

<br>Definition (normal extension).
An algebraic field extension  is a normal extension if every irreducible polynomial in  that has a root in  factors completely into linear factors in .
<br>Definition (separable extension).
An algebraic extension  is a separable extension if every element of  is separable over , i.e., is a root of a separable polynomial in .
<br>Definition (separable polynomial).
A polynomial is called separable if all its roots are distinct.
<br>Task: why splitting field of  over  is separable.<br>Output:<br>
The splitting field of  over  is separable because we are in characteristic 0. More generally, if  is a field of characteristic 0 and , then the splitting field of  over  is separable. This is because every irreducible polynomial over a field of characteristic 0 is separable.<br>In this case, the splitting field  is an extension of . Since  has characteristic 0,  also has characteristic 0. The polynomials  and  have distinct roots. The roots of  are . The roots of  are . Since these are all distinct, the extension is separable.<br>Theorem.
Every irreducible polynomial over a field of characteristic 0 is separable.
<br>Counterexample:<br>Let  be the field of rational functions in one variable over . Then  is irreducible by Eisenstein's criterion. However, , so . Thus,  is not separable because a polynomial is separable if and only if it has no repeated roots in its splitting field, which is equivalent to the polynomial and its derivative being coprime (i.e., their greatest common divisor is 1). Since ,  has repeated roots and is therefore not separable.<br><br>The field extension  has degree 8, not 16, because . The Galois group  has at most 16 automorphisms, determined by  and , but the choices of  and  are not independent. Since ,  is a common subfield of both  and . <br>The effect of  on  partially determines it on , and conversely: , which gives the relation <br><br>This tells us that if  then , so , while if  then , so . For example,  can't both fix  and send  to  because <a data-href="#^503e51" href="about:blank#^503e51" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^503e51</a><a data-href="#^503e51" href="about:blank#^503e51" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a>  would not hold.<br><br>Theorem.
Let  and  be Galois over . There is an injective homomorphism

given by . In particular, if  and  are finite abelian extensions then  is a finite abelian extension of .
<br>Proof.<br>
We omit this proof<br>
□<br>Proposition.
Consider a finite extension  is normal if and only if any of the following equivalent conditions hold:

<br>Every irreducible polynomial in  that has at least one root in  splits completely into linear factors over .
<br> is the splitting field of some polynomial in .
<br>Every  -embedding of  into an algebraic closure  of  has its image contained in . That is, if  is a field homomorphism such that  for all , then .

<br>Task: The Galois group of  over  is . Its Galois group over  is trivial. Why trivial?<br>Answer:<br>The Galois group of a polynomial over a field  is the group of automorphisms of the splitting field of the polynomial that fix .<br>In this case, we are considering the polynomial  over .<br>
The roots of  are , and the roots of  are .  Since  and  are both real numbers, all four roots  are in . Thus, the splitting field of  over  is  itself.<br>The Galois group consists of automorphisms of the splitting field that fix the base field. In this case, we seek automorphisms of  that fix . The only such automorphism is the identity map. Therefore, the Galois group is trivial.<br><img alt="Galois-theory-at-work-2025041800.png" src="lib\media\galois-theory-at-work-2025041800.png"><br><br>Theorem (Theorem 4.10).
Let  be a separable polynomial of degree .
(a) If  is irreducible in  then its Galois group over  has order divisible by .<br>
(b) The polynomial  is irreducible in  if and only if its Galois group over  is a transitive subgroup of .
<br>Proof.<br>
(a) For a root  of  in  is a factor of the degree of the splitting field over , which is the size of the Galois group over .<br>(b) First suppose  is irreducible. For two roots  and  of , we can write  for some  in the Galois group of  over . Therefore the Galois group, as a subgroup of , sends  to , so it is a transitive subgroup. Now suppose  is reducible (so ). It is a product of distinct irreducibles since it is separable. Let  and  be roots of different irreducible factors of . These irreducible factors are the minimal polynomials of  and  over . For any  in the Galois group of  over  has the same minimal polynomial over  as , so we can't have . Therefore, as a subgroup of , the Galois group of  does not send  to , so it is not a transitive subgroup of .<br>
□<br>Definition (transitive subgroup).
A subgroup  of  is called transitive if for every , there exists a  such that .
<br>Theorem.
Let  be an irreducible polynomial of prime degree  with all but two roots in . The Galois group of  over  is isomorphic to .
<br>Proof.<br>
Let  be the splitting field of  over . The permutations of the  's by  provide an embedding  and  is divisible by  by Theorem 4.10, so  contains an element of order  by Cauchy's theorem. In , the only permutations of order  are  -cycles (why?). So the image of  in  contains a  -cycle.<br>We may take  to be a subfield of , since  is algebraically closed. Complex conjugation restricted to  is a member of . Since  has only two non-real roots by hypothesis, complex conjugation transposes two of the roots of  and fixes the others. Therefore  contains a transposition of the roots of . (This is the reason for the hypothesis about all but two roots being real.)<br>We now show the only subgroup of  containing a  -cycle and a transposition is , so . By suitable labeling of the numbers from 1 to , we may let 1 be a number moved by the transposition, so our subgroup contains a transposition . Let  be a  -cycle in the subgroup. As a  -cycle,  acts on  by a single orbit, so some  with  sends 1 to  : . This is also a  -cycle, because  has order  in  and all elements of order  in  are  -cycles, so writing  as  and suitably reordering the numbers  (which replaces our subgroup by a conjugate subgroup), we may suppose our subgroup of  contains the particular transposition (12) and the particular  -cycle . For , it is a theorem in group theory that the particular transposition (12) and  -cycle  generate , so our subgroup is .<br>
□<br>Task: Why? In , the only permutations of order  are  -cycles<br>Output:<br>
The order of a permutation written in cycle notation is the least common multiple of the lengths of its cycles. To get order , where  is prime, we need the least common multiple of the cycle lengths to be . Since  is prime, the cycle lengths must be  or . Since the lengths must add up to , we must have one cycle of length  and all the other cycles of length . Thus, we have a -cycle.<br>Task: why? in group theory that the particular transposition (12) and  -cycle  generate .<br>Output:<br>
The symmetric group  is the group of all permutations of  elements. We want to show that the transposition (1 2) and the -cycle (1 2 ... ) generate .<br>Let  and . We want to show that any permutation in  can be written as a product of  and .<br>First, we can generate any transposition of the form  for . We have<br><br>For example,<br>
<br>


<br>


<br>


<br>So we can generate any transposition of the form .<br>Next, we can generate any transposition  for . We have<br><br>Since we can generate any  and , we can generate any .<br>Finally, since any permutation can be written as a product of transpositions, and we can generate any transposition  using  and , we can generate any permutation in  using  and .<br>Therefore, the transposition (1 2) and the -cycle (1 2 ... ) generate .<br><br>Example (4.13).
The polynomial  is irreducible in  since it is irreducible mod 2 or since it is a cubic without any rational roots. It has one real root (approximately 1.3247), and one root of a cubic is all but two roots, so its Galois group over  is isomorphic to .
<br>Example (4.14).
The polynomials  and  are both irreducible in  since they are cubics without any rational roots. Each polynomial has three real roots (check!), so we can't use Theorem 4.11 to determine their Galois groups over .
<br>Example (4.15).
The quintic polynomial  is irreducible in  since it is irreducible mod 3. It has one real root, so Theorem 4.11 does not tell us the Galois group.
<br>Example (4.16).
The quintic polynomial  is irreducible in  since it is irreducible mod 3. It has three real roots, which is all but two roots, so its Galois group over  is isomorphic to .
<br><br>In general, if  with  and  such that for any divisor  of , , then the normal closure of  is . The Galois group  is always a subgroup of semidirect product .<br>In "majority" cases, the Galois group  is isomorphic to . <br>
  is a normal subgroup of , which corresponds to that  is a Galois extension of . On the other hand,  is not a normal subgroup and thus  is not normal over .
<br>Definition (transitive).
A subgroup  of the symmetric group  is said to be transitive if for every , there exists a  such that . In other words, for any two elements in the set , there is a permutation in the subgroup that maps the first element to the second.
<br><br><br>Definition (discriminant).
For a nonconstant  of degree  that factors over a splitting field as

the discriminant of  is defined to be

<br>The number disc  is nonzero if  is separable and is 0 if  is not separable.<br>When  is separable,  is a symmetric polynomial in the  's, so it is fixed by  and therefore  by Galois theory.   <br>Theorem.
Let  not have characteristic 2 and let  be a separable cubic in  with a root  and discriminant . The splitting field of  over  is . 
Note we are not assuming  is irreducible here.
<br>Theorem (Theorem 4.23).
Let  be a separable polynomial of degree . If  does not have characteristic 2, the embedding of the Galois group of  over  into  as permutations of the roots of  has image in  if and only if disc  is a square in .
<br>Proof.<br>
设 ，因此  且 。因此， 是  中的一个平方，当且仅当 。<br>对于任何 ，设  是其作为  的排列的符号。根据排列符号的定义之一，<br><br>因此 。由于  且  没有特征 。当且仅当  时，我们有 ，因此当且仅当  时，。因此， 在  上的伽罗瓦群在  中当且仅当  被伽罗瓦群固定，这与  相同。<br>
□<br>Theorem (Theorem 4.25).
Let  not have characteristic 2 and let  be a separable irreducible cubic in .
(a) If disc  is a square in  then the Galois group of  over  is isomorphic to .
(b) If disc  is not a square in  then the Galois group of  over  is isomorphic to .
<br>Remark (why require the characteristic ).
If the characteristic of the field is 2, then , which means every permutation is even since . 
<br><br>In low-degree cases, explicit formulas for discriminants of some trinomials are<br><br><br>Theorem (Dedekind).
Let  be monic irreducible over  of degree . For any prime  not dividing disc , let the monic irreducible factorization of  be

and set , so . The Galois group of  over , viewed as a subgroup of , contains a permutation of type .
<br>The nicest proof of <a data-href="#^ef1229" href="about:blank#^ef1229" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^ef1229</a><a data-href="#^ef1229" href="about:blank#^ef1229" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 21 (Dedekind)</a>  uses algebraic number theory and is beyond the scope of these notes.<br>Example.
We compute the Galois group of  over  using <a data-href="#^ef1229" href="about:blank#^ef1229" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^ef1229</a><a data-href="#^ef1229" href="about:blank#^ef1229" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 21 (Dedekind)</a> .<br>
This polynomial is irreducible , so it is irreducible over . Let its roots be . The extension  has degree 4 , so the Galois group of  over  has order divisible by 4 . Since the Galois group embeds into , its size is either 4 , 8,12 , or 24 . The discriminant of  is -283 , which is not a rational square, so the Galois group is not a subgroup of . This eliminates the possibility of the Galois group having order 12 , because the only subgroup of  with order 12 is . (Quite generally, the only subgroup of index 2 in  is  for .) There are subgroups of  with orders 4, 8 , and (of course) 24 outside of , so no other size but 12 is eliminated yet.
Using <a data-href="#^ef1229" href="about:blank#^ef1229" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^ef1229</a><a data-href="#^ef1229" href="about:blank#^ef1229" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 21 (Dedekind)</a>  with ,

This is an irreducible factorization, so <a data-href="#^ef1229" href="about:blank#^ef1229" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^ef1229</a><a data-href="#^ef1229" href="about:blank#^ef1229" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 21 (Dedekind)</a>  says that the Galois group of  over  contains a permutation of the roots with cycle type , which means the Galois group has order divisible by 3 , and that proves the Galois group is .
<br>Task: why implies irreducibility? We compute the Galois group of  over  using <a data-href="#^ef1229" href="about:blank#^ef1229" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^ef1229</a><a data-href="#^ef1229" href="about:blank#^ef1229" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 21 (Dedekind)</a>. This polynomial is irreducible , so it is irreducible over .<br>A polynomial  is irreducible over  if it cannot be factored into non-constant polynomials with rational coefficients. Reducing a polynomial modulo a prime  can be used to prove irreducibility over  because if  factors over , then it must also factor modulo  for almost all primes . Thus, if  is irreducible for some prime , then  must be irreducible over .<br>In this specific case, since  is irreducible modulo 2, it follows that  is irreducible over . This is a consequence of the fact that if  were reducible over , then it would also be reducible modulo 2, which contradicts the given information that it is irreducible modulo 2.<br><br>Let's determine the Galois group of  over , which was left unresolved in Example 4.15. Its irreducible factorization mod 2 is<br><br>Because the polynomial is irreducible over  divides the size of the Galois group. From the mod 2 factorization, the Galois group contains a permutation of the roots with cycle type , which has order 6 , so the Galois group has size divisible by . Since the Galois group is a subgroup of , its size is either 30,60 , or 120 .<br>It turns out that there is no subgroup of  with order 30 and the only subgroup of order 60 is . The discriminant of  is , which is not a rational square, so the Galois group is not in  by Theorem 4.23. Therefore the Galois group is .<br><br>We want to understand why the size of the Galois group  of the polynomial  over the rational numbers  must be divisible by .<br>This conclusion is derived from two key facts about the polynomial and fundamental theorems in Galois theory and group theory.<br>
<br>Divisibility by 5

<br>Reason: The polynomial  is irreducible over .
<br>Theorem: For an irreducible polynomial of degree  over a field , the order of the Galois group of its splitting field over  is divisible by . Since  is irreducible and has degree , the size of its Galois group  must be divisible by 5. Equivalently, the Galois group  acts transitively on the 5 roots, so  is divisible by 5.


<br>Divisibility by 6

<br>Reason: The factorization of  modulo 2 is given as:

Both factors,  and , are irreducible over the field .
<br>Theorem (Dedekind's Theorem / Frobenius Elements): If a polynomial with integer coefficients factors modulo a prime  into distinct irreducible factors of degrees , then its Galois group  contains an element  having the cycle structure . Thus, the Galois group , seen as a subgroup of , must contain a permutation  with cycle structure .
<br>The order of permutation  is . Since  contains an element  of order 6, the order of the group  must be divisible by 6.


<br>Theorem (Lagrange's Theorem).
In any finite group, the order of any element must divide the order of the group.
<br>Proof.<br>
By considering the partition of a finite group  into disjoint left cosets of a subgroup , we can deduce that the order of  divides the order of , and consequently, the order of any element  in  must also divide the order of .<br>
□<br><br>From <a data-href="#^1bb574" href="about:blank#^1bb574" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^1bb574</a><a data-href="#^1bb574" href="about:blank#^1bb574" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 10</a> and <a data-href="#^ef1229" href="about:blank#^ef1229" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^ef1229</a><a data-href="#^ef1229" href="about:blank#^ef1229" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 21 (Dedekind)</a>, we have<br>Corollary.
Let  be monic irreducible over  of prime degree . If there is a prime number  not dividing disc  such that  has all but two roots in , then the Galois group of  over  is isomorphic to .
<br>Proof.<br>
The proof of  <a data-href="#^1bb574" href="about:blank#^1bb574" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^1bb574</a><a data-href="#^1bb574" href="about:blank#^1bb574" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 10</a>  can be used again except for the step explaining why the Galois group of  over  contains a transposition. In  <a data-href="#^1bb574" href="about:blank#^1bb574" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^1bb574</a><a data-href="#^1bb574" href="about:blank#^1bb574" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 10</a>  this came from the use of complex conjugation to transpose two non-real roots, assuming there are only two non-real roots. We aren't assuming that anymore. By hypothesis the factorization of  has all linear factors except for one quadratic irreducible factor. Therefore Theorem 4.29 says the Galois group contains a permutation of the roots with cycle type , which is a transposition in .<br>
□<br>If we seek an analogue of <a data-href="#^1bb574" href="about:blank#^1bb574" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^1bb574</a><a data-href="#^1bb574" href="about:blank#^1bb574" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 10</a> for a Galois group to be isomorphic to , using 3 -cycles in place of transpositions, there is no analogue since an irreducible polynomial over  can't have all but three roots in  (the number of non-real roots is always even). But  could have all but three roots in  for some . This suggests the next result.<br>Corollary.
Let  be monic irreducible over  of prime degree  with disc  a perfect square. If there is a prime number  not dividing disc  such that  has all but three roots in , then the Galois group of  over  is isomorphic to .
<br>Proof.<br>
Let  be the Galois group, so  is a subgroup of  since  is a square. The Galois group has order divisible by , so it contains a  -cycle. From the factorization of  and <a data-href="#^ef1229" href="about:blank#^ef1229" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^ef1229</a><a data-href="#^ef1229" href="about:blank#^ef1229" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 21 (Dedekind)</a> ,  contains a 3 -cycle. It is a theorem of C. Jordan that for any prime , any  -cycle and any 3 -cycle in  generate , so .<br>
□<br>Example.
The polynomial  has discriminant . It is irreducible , so it's irreducible over . Modulo 7, its irreducible factorization is

This has all but three roots in , so the Galois group of  over  is isomorphic to .
<br>Remark.
It is a hard theorem of Chebotarev that the sufficient conditions for  to have Galois group  in <a data-href="#^8c6166" href="about:blank#^8c6166" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^8c6166</a><a data-href="#^8c6166" href="about:blank#^8c6166" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Corollary 24</a>  and  in <a data-href="#^0cc046" href="about:blank#^0cc046" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^0cc046</a><a data-href="#^0cc046" href="about:blank#^0cc046" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Corollary 25</a>  are also necessary in a strong sense: if  is monic irreducible of prime degree  with Galois group over  isomorphic to  (resp.,  ) then there are infinitely many primes  not dividing  such that
<br><br>To decompose , we want to find its roots in . We can test each element:<br>
<br>For , .
<br>For , .
<br>For , .
<br>For , .
<br>For , .
<br>Since  is a root,  is a factor. Then we can perform polynomial division to find the other factor.<br>
Note that , so we can write .<br> in .<br>Now we consider the quadratic . We want to see if it can be factored further. We can check its discriminant:<br>
.<br>
Since  is not a quadratic residue modulo  (i.e., there is no  such that ), the quadratic has no roots in . The quadratic residues modulo 5 are , , , , .<br>Thus,  is irreducible over .<br>Therefore, the decomposition of  is .<br><br>Verifying whether a polynomial is irreducible in a given field is a fundamental problem in algebra. Here are several methods and theorems that can be used:<br><br>Theorem (Eisenstein's Criterion).
Let  be a polynomial with integer coefficients. If there exists a prime number  such that:

<br> for all ,
<br>,
<br>,

then  is irreducible over .
<br>This criterion directly proves irreducibility over  by checking divisibility conditions of the polynomial's coefficients by a prime number.<br><br>
<br>Choose a prime  such that the degree of the polynomial  with integer coefficients remains the same when reduced modulo .
<br>If the reduced polynomial is irreducible over , then  is irreducible over .
<br>If the reduced polynomial is reducible, no conclusion can be made about the irreducibility of  over .
<br>This method involves reducing the polynomial modulo a prime  and checking for irreducibility in the finite field .<br><br>
<br>For a polynomial  with integer coefficients, any rational root must have the form , where  divides  and  divides .
<br>A polynomial of degree 2 or 3 with no rational roots is irreducible over .
<br>This theorem helps find potential rational roots, and if none exist for polynomials of degree 2 or 3, it confirms irreducibility.<br><br>
<br>If  is a polynomial over a field , and  is a root of  in some extension field, then  is irreducible if and only if  has degree equal to the degree of .
<br>This method checks irreducibility by examining the degree of the field extension formed by adjoining a root of the polynomial.<br><br>
<br>Algorithms like Berlekamp's algorithm determine if a polynomial is irreducible over a finite field.
<br>These algorithms provide computational methods to test for irreducibility, especially over finite fields.<br><br><br>Lemma (Gauss's Lemma).
If a polynomial with integer coefficients can be factored into two polynomials with rational coefficients, then it can be factored into two polynomials with integer coefficients.
<br><br>Suppose that  is a polynomial with integer coefficients. Assume that it can be factored into two polynomials with rational coefficients, say , where  and  have rational coefficients.<br>
<br>
Clear denominators: Multiply  and  by suitable integers  and  respectively, such that  and  have integer coefficients. Thus, we have , where  and  are polynomials with integer coefficients.

<br>
Remove common factors: Divide  and  by the greatest common divisor of their coefficients. Let  and , where  is the greatest common divisor of the coefficients of  and  is the greatest common divisor of the coefficients of . Then  and  are primitive polynomials (polynomials with integer coefficients whose coefficients have a greatest common divisor of 1). We then have .

<br>
Reduce to primitive polynomials: Let . Then . Since  and  have integer coefficients, their product  also has integer coefficients. Furthermore,  has integer coefficients. Hence  must be a rational number such that  has integer coefficients.

<br>
Show  is an integer:  Since  and  are primitive polynomials, their product  is also a primitive polynomial. This is a key step and is often proven separately. Now, since  and  is a polynomial with integer coefficients, and  is primitive, it follows that  must be an integer.

<br>
Conclude the factorization: Since  is an integer and , we have a factorization of  into two polynomials with integer coefficients: , where  and  have integer coefficients after adjusting for the constant factor. We can then rewrite  where .

<br>Thus,  can be factored into two polynomials with integer coefficients.<br>Remark.
This lemma relates irreducibility over  to irreducibility over , ensuring that if a polynomial is irreducible over the integers, it is also irreducible over the rationals.
<br><br>Theorem (Hilbert's Irreducibility Theorem).
If  is an irreducible polynomial in , then there exist infinitely many tuples  of rational numbers such that  is irreducible in .
<br>This theorem is used in advanced settings to prove the existence of irreducible polynomials by specializing variables.<br><br>Lemma (Capelli's Lemma).
Let  be a field and  be an irreducible polynomial over . Let  be a root of . If , then  is irreducible over  if and only if  is irreducible over .
<br>Given an irreducible polynomial  over a field  and a root  of , this lemma relates the irreducibility of another polynomial  over  to the irreducibility of  over .<br><br>Theorem (Irreducibility over Finite Fields).
Let  be a polynomial of degree  over . Then  is irreducible if and only if  divides  and  for all  with .
<br>A polynomial  of degree  over a finite field  is irreducible if and only if  divides  and  for all  with .]]></description><link>近世代数\galois-theory-at-work.html</link><guid isPermaLink="false">近世代数/Galois-theory-at-work.md</guid><pubDate>Sat, 17 May 2025 14:20:05 GMT</pubDate><enclosure url="lib\media\galois-theory-at-work-2025041800.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\galois-theory-at-work-2025041800.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Galois-theory-at-work-1]]></title><description><![CDATA[ 
 <br><br>Definition (trace, norm).
If  is a finite Galois extension with Galois group , the characteristic polynomial of  is . In particular,

<br><br>If  and  for a nonsquare  in , the two elements of  are determined by  and , so<br><br>and<br><br>Also<br><br><br>For ,<br><br><br>The Galois group of  is a cyclic group of order , generated by the Frobenius automorphism , where .<br><br><br>Theorem (Theorem 6.1).
Let  and  be Galois over .
a) The embedding

given by  is an isomorphism if and only if . In particular,  if and only if .
b) The image of the embedding in part a is the set of compatible pairs of automorphisms:  on .
<br>Proof.<br>
We omit the proof.<br>
□<br>Example.
Let  and . Both are Galois over , we know their Galois groups, and . Define  and  by the conditions

These agree on  since , so there is a unique  that restricts to  on  and  on .
<br>Example (the Galois hypotheses cannot be removed).
If , and , then  but . See the field diagram below on the left.
<br>If one of  and  is Galois, <a data-href="#^426887" href="about:blank#^426887" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^426887</a><a data-href="#^426887" href="about:blank#^426887" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 2 (Theorem 6.1)</a> still holds.<br>Theorem (Theorem 6.6).
Let  and  be finite extensions with  a Galois extension.

<br>
The extension  is finite Galois and  by restriction. In particular,

so  if and only if .

<br>
The sets of intermediate fields  and  are in bijection by , with inverse .


In particular, every field between  and  has the form  where , and if  and  correspond by the bijection then  is Galois if and only if  is Galois, in which case  by restriction.
<br>The extension  is Galois, with Galois group . If we translate this extension by  (which is not Galois over  ), we get the Galois extension . What is its Galois group? By <a data-href="#^f158fe" href="about:blank#^f158fe" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^f158fe</a><a data-href="#^f158fe" href="about:blank#^f158fe" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 5 (Theorem 6.6)</a>, <br><br>where . Obviously, , and since , , we have .  <br><br>Definition.
For a positive integer ,

where .<br>
Define ; it is a finite field extension of , called the th cyclotomic extension of .
A primitive th root of unity is a generator of ; it is equal to  for some . Define

it is called the th cyclotomic polynomial.
<br>Example.
We have .
<br>Lemma.
We have

Each  is a polynomial of degree  with coefficients in .
<br>Proof.<br>
The first equality is easy:<br><br>We will prove that  has coefficients in  and its coefficients have gcd . Assume that this has been proved for smaller . Then <a data-href="#^910936" href="about:blank#^910936" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^910936</a><a data-href="#^910936" href="about:blank#^910936" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a> and Gauss' lemma implies that  has coefficients in  and has coefficients' gcd .<br>
□<br><br>Theorem (Theorem 7.1).
If  has characteristic 0 and  is a finite extension such that  and  are both Galois and , then .
<br>Proof.<br>
Let . We will show this group is trivial.<br>Pick , so . Therefore<br><br>Since  and  are Galois over  and , so  and . This common difference is therefore in . Write , so<br><br>Applying  repeatedly,  for all integers . Choose  such that  is the identity (for instance, let  ). Then , so . Since we are in characteristic 0 and  is a positive integer, we must have , so  and . Therefore  is the identity on .<br>
□<br>Theorem (Theorem 7.6).
If  has characteristic 0 and  is a finite extension such that  then .
<br>Remark.
The degree hypothesis in <a data-href="#^2e605f" href="about:blank#^2e605f" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^2e605f</a><a data-href="#^2e605f" href="about:blank#^2e605f" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 10 (Theorem 7.6)</a> is equivalent to  when one of  or  is Galois over , so <a data-href="#^561cb5" href="about:blank#^561cb5" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^561cb5</a><a data-href="#^561cb5" href="about:blank#^561cb5" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 9 (Theorem 7.1)</a> is also true when only one of  or  is Galois over .
<br>Example.
 <a data-href="#^2e605f" href="about:blank#^2e605f" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^2e605f</a><a data-href="#^2e605f" href="about:blank#^2e605f" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 10 (Theorem 7.6)</a> implies  and .
<br>Example.
We know  and this example does not fit  <a data-href="#^2e605f" href="about:blank#^2e605f" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^2e605f</a><a data-href="#^2e605f" href="about:blank#^2e605f" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 10 (Theorem 7.6)</a> since  while .
<br>Example.
Letting  and  be two roots of , we can't decide if  equals  from  <a data-href="#^2e605f" href="about:blank#^2e605f" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^2e605f</a><a data-href="#^2e605f" href="about:blank#^2e605f" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 10 (Theorem 7.6)</a> since  and . The two fields are not the same since  has degree 6 over .
<br>Example.
Does  ? Since  (by Example 1.4) and , we can't answer this with  <a data-href="#^2e605f" href="about:blank#^2e605f" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^2e605f</a><a data-href="#^2e605f" href="about:blank#^2e605f" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 10 (Theorem 7.6)</a>. Since , you can check the Galois orbit of  has size 8 , so in fact . (The minimal polynomial of  over  is  .) Thus the degree hypothesis of  <a data-href="#^2e605f" href="about:blank#^2e605f" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^2e605f</a><a data-href="#^2e605f" href="about:blank#^2e605f" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 10 (Theorem 7.6)</a> is sufficient to imply  in characteristic 0 , but it is not necessary.
<br><br>Theorem (Theorem 8.1).
Every finite group is the Galois group of some finite Galois extension in any characteristic.
<br>Theorem (Theorem 8.2).
If every finite group can be realized as a Galois group over  then every finite group can be realized as a Galois group over any finite extension of .
<br><br>There are two important aspects of field extensions that are missing by a study of Galois theory of finite extensions, and we briefly address them:<br>
<br>
Galois theory for infinite extensions

<br>
transcendental extensions

<br>An example of an infinite Galois extension of  is <br><br>the union of all  -th power cyclotomic extensions of , where  is a fixed prime.]]></description><link>近世代数\galois-theory-at-work-1.html</link><guid isPermaLink="false">近世代数/Galois-theory-at-work-1.md</guid><pubDate>Wed, 07 May 2025 17:01:14 GMT</pubDate></item><item><title><![CDATA[Gauss's Lemma]]></title><description><![CDATA[ 
 <br>]]></description><link>近世代数\gauss&apos;s-lemma.html</link><guid isPermaLink="false">近世代数/Gauss&apos;s-lemma.md</guid><pubDate>Fri, 02 May 2025 08:58:54 GMT</pubDate></item><item><title><![CDATA[hw1]]></title><description><![CDATA[ 
 <br>习题1.2第11、12、16、22题
习题1.3第1、3、7(1)（2）题
<br>Exercise.
习题2．11．设  是群  的子群，且  ．证明  或者 .
<br>Assume that  and , combined with the fact that , we have an element  and an element . Since , then . If  then  for some , thus , which contradicts the fact . If  then , thus , which contradicts the fact . Hence  or .  <br>Exercise.
习题2．12．在偶数阶群  中，方程  总有偶数个解．
<br> is even. If  then , . Thus  is even. Therefore  is even too.<br>Exercise.
习题2．16．设  是群  的两个子群．试证  是  的子群当且仅当 .
<br><br>() If  then for any , let ,  thus <br><br>Let  then<br><br>Hence .<br>() If  then for any , we have  for some . Therefore for any , we have<br><br>Hence .<br>Exercise.
习题2．22．证明有理数加法群  和乘法群 不同构．
<br>If  then there is an isomorphism  from  to . Since  is isomorphism, it's a bijective homomorphism. Then there exists an element  in  such that , then <br><br>Then , which is a contradiction. Hence .<br>Exercise.
习题 3．1．设

试求  和  在  中的阶．
<br><br><br><br><br>Then .<br>Exercise.
习题 3．3．设  是群  的两个元素， 的阶是 7 且  ．证明  ．
<br><br>Exercise.
习题3．7．（1） 的任意有限阶子群均为循环群．<br>
（2）  不是循环群，但它的任意有限生成子群都是循环群．
<br>(1)<br>. For any subgroup  with finite order, pick , then  is finite. ( denotes the order of .) WLOG, let  be the element with largest order , and let . We need to show that <br><br>If  is an element in  but . If , then  while , which means . Thus , denoted by , where .  for some . Then <br><br> and , thus ,  is not the element with largest order in . <br>Hence  is cyclic.<br>(2)<br>If   is cyclic group generated by , then  is also a generator and . Hence  is not cyclic.<br>For , where , , . Obviously,<br><br> is a subgroup of a cyclic group, thus a cyclic group.]]></description><link>近世代数\hw1.html</link><guid isPermaLink="false">近世代数/hw1.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate></item><item><title><![CDATA[hw1-wrong]]></title><description><![CDATA[ 
 <br>习题1.2第11、12、16、22题
习题1.3第1、3、7(1)（2）题
<br>Exercise.
习题2．11．（1）验证  均为  的子群，且  ．<br>
（2）验证  均为  的子群。<br>
（3）验证  是  的子群。
<br>Definition.

（i） 为对角线元全为 1 的  阶上三角阵；<br>
（ii）  为  阶可逆对角阵集合；<br>
（iii） 为  阶可逆上三角阵集合。
<br>(1)<br>It suffices to show that , . Since ,  is invertible, thus . Moreover, , thus . <br>For ,<br><br>Then <br><br>Therefore<br><br>For , we have<br><br>where  are invertible in . Then<br><br>Therefore<br><br>where  because  is a field, and  is invertible. Thus . <br>For , we have<br><br>where  are invertible in . Then<br><br>Therefore<br><br>where  because  is a field, and  is invertible. Hence . <br>Since , then<br><br>(2)<br><br><br><br>For , we have . Similarly, we have . Hence .<br>For , we have<br><br>Hence .<br>For , we have<br><br>Hence .<br>(3)<br><br>For , we have<br><br>Simliarly . Hence .<br>Exercise.
习题2．12．试证群  的任意多个子群的交仍是  的子群．
<br>Let  be an index set, . For any , we have  for any . Thus , then . Hence .<br>Exercise.
习题2．16．（1）确定  的所有子群．<br>
（2）确定  的所有子群，其中  ．
<br>(1)<br>
<br>(2)<br>
<br>Exercise.
习题2．22．群  的自同构  称为没有不动点，是指对  的任意元素  ，  ．如果有限群  具有一个没有不动点的自同构  且  ，证明  一定是奇数阶阿贝尔群．
<br>Consider the pair , where  for  and . Then  is odd. <br>Consider , claim that . (othewise  for some , then ) Thus for any , we have  for some , then . , . Therefore  is abel.<br>Exercise.
习题3．1．设

试求  和  在  中的阶．
<br><br><br><br><br>Then .<br>Exercise.
习题3．3．设  是群  的两个元素， 的阶是 7 且  ．证明  ．
<br><br>Exercise.
习题3．7．设  和  是群  的元素，阶数分别是  和  且  ．试证  是  的  阶循环子群．
<br><br>If  for some  where  and , then <br><br>Since , we have , which means . Similarly , thus . Hence  is a cyclic subgroup of  of order .]]></description><link>近世代数\hw1-wrong.html</link><guid isPermaLink="false">近世代数/hw1-wrong.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate></item><item><title><![CDATA[hw2]]></title><description><![CDATA[ 
 <br>习题1.2第17，19，24题
习题1.3第8，9，13，16（1)(2)题
<br>Exercise.
习题2．17．设  和  是有限群  的两个非空子集．若  ，证明  ．特别地，如果  是  的一个子集， ．证明对任意  ，存在  使得  ．
<br>Check: , s.t.. <br>For any but fixed , let . If . Then <br><br>Contradiction! Thus , i.e. there exists , s.t., i.e.  for some , i.e. , i.e. .<br>Let , then . Therefore for any , , s.t. .<br>Exercise.
习题2．19．证明：映射  是  的自同构当且仅当  是阿贝尔群。
<br>() If  is automorphism in , then for any , we have<br><br>Therefore  is Abel.<br>() If  is Abel, then obviously  is a bijection in . It suffices to show that  is homomorphism. For any ,<br><br>Hence .<br>Exercise.
习题2．24．群  的自同构  称为没有不动点，是指对  的任意元素  ，  ．如果有限群  具有一个没有不动点的自同构  且  ，证明  一定是奇数阶阿贝尔群。
<br>Consider the pair , where  for  and . Then  is odd. <br>Consider , claim that . (othewise  for some , then ) Thus for any , we have  for some , then . , . Therefore  is Abel.<br>Exercise.
习题3．8．设  和  是群  的元素，阶数分别是  和  且  ．试证  是  的  阶循环子群．
<br><br>Denote , , . <br><br>Therefore , since , we have . Similarly, .  . Hence .<br>Exercise.
习题3．9．设  为奇素数， 是  阶整系数方阵．如果  的阶有限，证明  ．
<br><br><br>扩充数域到复数域 ，我们有 Jordan 分解<br><br>其中 ，显然这些若当块都是特征值为 0 的. 若不全是一阶若当块，必然有某个若当块  使得<br><br>但这与<br><br>矛盾，故 .<br>Exercise.
习题3．13．（1）设  是阿贝尔群， 是  中所有有限阶元素构成的集合．证明  是  的子群．<br>
（2）＊举例说明上述结论对于一般群不正确．
<br>(1)<br><br>For any , we have<br><br>Then .<br>(2)<br>
反例：无穷二面体群 <br>
考虑无穷二面体群  ，它由以下生成元和关系定义：<br><br>其中：<br>
<br> 的阶为 2 （即  ）。
<br> 具有无穷阶（即  对任何  ）。
<br>群的元素形如  或  ，其中  。
<br>列出有限阶元素：<br>
<br>所有  都是无穷阶的。
<br>仅有  和  的阶为 2，因为
<br><br>所以，所有的有限阶元素集合为：<br><br>检查封闭性：<br>
<br> ，在  中。
<br> 可能是无穷阶的，不在  中！这说明  不是封闭的，因此它不是一个子群。
<br>这个例子说明了：对于一般群，有限阶元素的集合不一定构成子群。<br>Exercise.
习题3．16．回答下列问题：<br>
（1）设  是素数， 方幂阶群是否一定含有  阶元？<br>
（2） 35 阶群是否一定同时含有 5 阶和 7 阶元素？
<br>(1)<br>
If , for any ,<br><br>Then . If , then . If  then  or , thus either  or  has order .<br>(2)<br>
If , for any ,<br><br>Then  or . If  contains an element  with order 35, then . <br>Assume there is no elements with order 35, if , then there are 34 elements with order 5. If  then  are distinct elements in  with order 5, and . But .<br>If . Then , which is not true.<br>Hence  contains element with order 5 and 7 at the same time.]]></description><link>近世代数\hw2.html</link><guid isPermaLink="false">近世代数/hw2.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate></item><item><title><![CDATA[hw3]]></title><description><![CDATA[ 
 <br>习题1.3第20题
习题1.4第3，4，6，9，11题
<br>Exercise.
<img alt="1-hw3-2025032510.png" src="lib\media\1-hw3-2025032510.png">
<br>Proof.<br>
若 ，则 ，. 故 . 同理 . 故 .<br>若 ，则<br><br>左乘 ，再右乘  得到<br><br>于是 ，同理 ，因此 .<br>□<br>
以后我们用  表示 ，即  的阶.
<br>Exercise.
<img alt="2-hw3-2025032510.png" src="lib\media\2-hw3-2025032510.png">
<br>(1) 若 ，则 ，有 ，显然 .<br>(2) 不一定，比如 <br><br>但是 .<br>Exercise.
<img alt="3-hw3-2025032510.png" src="lib\media\3-hw3-2025032510.png">
<br>Proof.<br>
(1)<br><br>Check that , <br><br>Fix , then for any ,<br><br>Therefore .<br>(2)<br>
If  with , then  can be split to two orbit<br><br>Then the left and right cosets of  are the same. <br>For any given , check that . <br>If , then . If , then . Therefore .<br>□<br>Exercise.
<img alt="4-hw3-2025032510.png" src="lib\media\4-hw3-2025032510.png">
<br>Proof.<br><br>Since  is cyclic, then<br><br>for any nontrivial .<br>Fix , check that .<br>We know that  must lie in  for some . Then  for some . Thus<br><br>Therefore  is Abel.<br>□<br>Exercise.
<img alt="5-hw3-2025032510.png" src="lib\media\5-hw3-2025032510.png">
<br><br><br><br><br><br><br>Denote that<br><br>Then<br><br><br>Thus<br><br>Then <br><br>Since , we have . Then<br><br>Exercise.
<img alt="6-hw3-2025032510.png" src="lib\media\6-hw3-2025032510.png">
<br>Proof.<br>
Since , for any , we have<br><br>Then for any ,<br><br>And <br><br>Thus <br><br>□]]></description><link>近世代数\hw3.html</link><guid isPermaLink="false">近世代数/hw3.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate><enclosure url="lib\media\1-hw3-2025032510.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\1-hw3-2025032510.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw4]]></title><description><![CDATA[ 
 <br>习题2.1第1，3，4，5，6，9，10，13题
<br><img alt="hw4-2025033113.png" src="lib\media\hw4-2025033113.png"><br><br><img alt="1-hw4-2025033113.png" src="lib\media\1-hw4-2025033113.png"><br>If  then<br><br>The number of transpositions in the factorization is . If  then  is even. If  then  is odd. <br>If  then<br><br>The number of transposition in the factorization is . If  then  is odd. If  then  is even.<br>Therefore, if ,  is odd. If ,  is even. <br><img alt="2-hw4-2025033113.png" src="lib\media\2-hw4-2025033113.png"><br>Suppose that a permutation can be decomposed into  disjoint cycles<br><br>Each  has length , then . Therefore . By the definition of , we have <br><br>Therefore  for each . Thus . Hence <br><br><img alt="3-hw4-2025033113.png" src="lib\media\3-hw4-2025033113.png"><br>先证明  中型为  的置换共有  个. 我们进行如下操作：先将  分到  个盒子中：<br><br>然后无视这些盒子的次序，再考虑每个盒子内元素的对应关系，比如对于有  个元素的盒子，要求<br><br>先从  开始考虑， 的选取有  种（）， 的选取有  种... 于是一共有  种. <br>按照上述逻辑考虑置换的种类可以知道，  中型为  的置换共有<br><br>同时我们考虑  的所有置换，按照  分类计算可得<br><br>于是<br><br><img alt="4-hw4-2025033113.png" src="lib\media\4-hw4-2025033113.png"><br>Lemma.
 () 非单.
<br>Proof.<br>
<a data-tooltip-position="top" aria-label="https://kconrad.math.uconn.edu/blurbs/grouptheory/Ansimple.pdf" rel="noopener nofollow" class="external-link" href="https://kconrad.math.uconn.edu/blurbs/grouptheory/Ansimple.pdf" target="_blank">Ansimple.pdf</a><br>
□<br>Lemma.
.
<br>Proof.<br>
Any permutation can decomposite to product of transformations.  is defined to be the permutations in  with even numbers of transformations in its decomposition.  is the kernel of <br><br>Thus .<br>
□<br> 时， 的全部正规子群为 . <br>When , evaluate all the normal subgroups of .<br><br>. There are 4 sylow 3-subgroups of :<br><br>Thus is not normal in . There is only one sylow 2-subgroup of :<br><br>Thus is normal in . C'est clair  is simple.<br> 的全部正规子群为 .<br>
<img alt="5-hw4-2025033113.png" src="lib\media\5-hw4-2025033113.png"><br><br>Since , <br><br>When , the simplicity and noncommutativity of  <a data-href="#^c6e538" href="about:blank#^c6e538" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^c6e538</a><a data-href="#^c6e538" href="about:blank#^c6e538" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Lemma 1</a>  implies  thus . When ,  maybe  or . Since <br><br>Then  is trivial. <br><img alt="6-hw4-2025033113.png" src="lib\media\6-hw4-2025033113.png"><br><img alt="hw4-2025040100.png" src="lib\media\hw4-2025040100.png"><br><img alt="7-hw4-2025033113.png" src="lib\media\7-hw4-2025033113.png"><br>由于指数为 2 的子群必然是正规子群，而且  时  的非平凡正规子群只有交错群 ， 时， 的非平凡正规子群只有  和 . 故得证！]]></description><link>近世代数\hw4.html</link><guid isPermaLink="false">近世代数/hw4.md</guid><pubDate>Fri, 09 May 2025 02:43:00 GMT</pubDate><enclosure url="lib\media\hw4-2025033113.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw4-2025033113.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw5]]></title><description><![CDATA[ 
 <br>习题2.3 第3、7、10题
习题2.4第6、8、11、14题
<br><img alt="hw5-2025041223.png" src="lib\media\hw5-2025041223.png"><br>Proof.<br>
There are 3 cases.  or .<br>If  then . Consider the homomorphism<br><br> acts on  by left multiplication,<br><br>, otherwise  then  is not simple. Thus , .<br>If  then . Consider the homomorphism <br><br> acts on  by left multiplication,<br><br>, otherwise  then  is not simple. Thus . Since  is not simple, . <br>If  then . Consider the homomorphism <br><br> acts on  by left multiplication,<br><br>, otherwise  then  is not simple. Thus , . Also,  implies that<br><br> is divisible by . Thus  or . If  then  or , not simple. If  then  or  or , not simple. If , it has a Sylow 3-subgroup, then  is not simple.<br>
□<br><img alt="1-hw5-2025041223.png" src="lib\media\1-hw5-2025041223.png"><br>
Proof.<br>
Assume that , then . Consider<br><br> acts on  by left multiplication,<br><br>Then , thus . For any , we have . For any  in ,  for some , thus , . But  which is a contradiction.<br>
□<br>
<img alt="2-hw5-2025041223.png" src="lib\media\2-hw5-2025041223.png"><br>
Proof.<br><br><img alt="hw5-2025041301.png" src="lib\media\hw5-2025041301.png"><br>
□<br><img alt="3-hw5-2025041223.png" src="lib\media\3-hw5-2025041223.png"><br>Proof.<br>
(1)  then  then . By Sylow II theorem, the Sylow 37-subgroup is normal in . Thus  is not simple.<br>(2) , then  then . By Sylow II theorem, the Sylow 5-subgroup is normal in . Thus  is not simple.<br>(3)  then . If , denote the Sylow 2-subgroups by . Then consider the homomorphism<br><br>Assume that  is simple, then , , thus . But , which is a contradiction. Therefore  is not simple.<br>
□<br><img alt="4-hw5-2025041223.png" src="lib\media\4-hw5-2025041223.png"><br>Proof.<br>
,  and  are relatively prime, then  for some . By Sylow I theorem,  contains a Sylow  -subgroup  with order .  is also a Sylow  -subgroup of . By Sylow II theorem, all Sylow  -subgroups are conjugate to , i.e. have the form  for some . NTS: . Since ,  is equivalent to , which is trivial. Hence  contains all the Sylow  -subgroups of .<br>
□<br>
<img alt="5-hw5-2025041223.png" src="lib\media\5-hw5-2025041223.png"><br>Proof.<br>
. Since , we have . Thus the Sylow  -subgroup is normal in . When , the Sylow  -subgroup si proper normal subgroup of . When , if  then  has no proper normal subgroup. If  then  is proper normal subgroup of .<br>
□<br>
<img alt="6-hw5-2025041223.png" src="lib\media\6-hw5-2025041223.png"><br>
. . <br>If , then by Sylow II theorem, the Sylow 3-subgroup  is normal in .  <br>Unsolved...<br>
下面证明仅供参考而已，不是这样证明，但我太困了，下次再补. 下面的证明完全错误！<br>
<img alt="hw5-2025041400.png" src="lib\media\hw5-2025041400.png">
]]></description><link>近世代数\hw5.html</link><guid isPermaLink="false">近世代数/hw5.md</guid><pubDate>Fri, 09 May 2025 16:52:23 GMT</pubDate><enclosure url="lib\media\hw5-2025041223.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw5-2025041223.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw6]]></title><description><![CDATA[ 
 <br>习题2.5第4题

习题2.6第1，3，7，11，13，15题
<br>Exercise.
<img alt="1-hw6-2025041815.png" src="lib\media\1-hw6-2025041815.png">
<br>Definition (product of two groups).
The (direct) product of two groups  and  is the group  whose underlying set is the Cartesian product of  and , and whose group operation is defined componentwise:

for all  and .
<br>Proof.<br>
, because  has nontrivial center<br><br>But  is trivial.<br>
□<br>Exercise.
<img alt="2-hw6-2025041815.png" src="lib\media\2-hw6-2025041815.png">
<br><img alt="1-hw6-2025041818.png" src="lib\media\1-hw6-2025041818.png"><br>
(1) For , by Sylow III theorem, . Thus  has unique Sylow 3-subgroup  and Sylow 11-subgroup , which are normal in . For any , we have , since .  is a group of order 33, since  for any . Since , , we have . Therefore  is an abelian group of 33 order. (Moreover,  is cyclic since ,  are cyclic.) By fundamental theorem of finitely generated abelian groups,<br><br>Remark.
The direct product and direct sum construct new groups from a collection of groups.
For a finite number of groups , the direct product  consists of tuples  where , with component-wise operation. The direct sum  is the same as the direct product in this case.
For an infinite collection of groups , the direct product  consists of all tuples  where . The direct sum  is a subgroup of the direct product, containing only tuples  where finitely many  are not the identity element in their respective groups .
For example, with , the direct product  can have elements like , while the direct sum  requires elements with finitely many 1s, such as .
<br>(2) For , by Sylow III theorem, , . <br>Let  be the Sylow 3-subgroup of , then it's normal in  (by Sylow ii theorem), with order 9. Pick a Sylow 2-subgroup  of . Since , ,  is a subgroup of  of order , so  and the recognition theorem for semidirect products tells us  is isomorphic to a semidirect product . The group  is isomorphic to  or . The group  is isomorphic to . Then we are going to classify all semidirect products  and .<br>To classify , let  be a homomorphism. It is determined by , which is a solution of . By listing all the conditions, . When , the homomorphism is trivial and . When , we get a semidirect product <br><br>by<br><br>It is isomorphic to , with an isomorphism <br><br>being given by . It's clearly a homomorphism. Check the relationships:<br><br><br>Thus  is an isomorphism.<br>To classify , let  be a homomorphism. It is determined by , which is a pair of solution of . The solutions are . When , the homomorphism is trivial, then . When , we get a semidirect product<br><br>by <br><br>It is isomorphic to , with an isomorphism<br><br>being given by . Similarly, when ,  is isomorphic to .<br>When , we get a semidirect product<br><br>by <br><br>There are 5 different groups with order 18:<br>
<br>
<br>
<br>
<br>
<br>, by .
<br>Exercise.
<img alt="hw6-2025041816.png" src="lib\media\hw6-2025041816.png">
<br>Definition (自由阿贝尔群的一组基).
设是一个自由阿贝尔群。的一组基是一个子集, 满足

<br>是的生成集，即。
<br>是线性无关的，即如果对于和, 使得

那么。

<br>(1) 记全体素数集合为 ，那么 ，这是因为任意  都存在素因子分解<br><br>所以 ，同时由于 ，所以 ，因此 .<br><img alt="hw6-2025041822.png" src="lib\media\hw6-2025041822.png"><br>Exercise.
<img alt="1-hw6-2025041816.png" src="lib\media\1-hw6-2025041816.png">
<br><img alt="2-hw6-2025041822.png" src="lib\media\2-hw6-2025041822.png"><br><img alt="1-hw6-2025041822.png" src="lib\media\1-hw6-2025041822.png"><br>Exercise.
<img alt="2-hw6-2025041816.png" src="lib\media\2-hw6-2025041816.png">
<br><br>不变因子为 ，初等因子为 .<br>Exercise.
<img alt="3-hw6-2025041816.png" src="lib\media\3-hw6-2025041816.png">
<br>Proof.<br><br>The only  -subgroup of  is itself. Since  is cyclic, the unique  -subgroup of  is . List all the  subgroups.<br><br>Thus  has 5  -subgroups.<br>□<br>Exercise.
<img alt="4-hw6-2025041816.png" src="lib\media\4-hw6-2025041816.png">
<br>Proof.<br>
Since  are finite abel groups, <br><br>There is an isomorphism  between  and . Restrict  to the second component by left composing , then  is an isomorphism between  and . Thus <br><br>□]]></description><link>近世代数\hw6.html</link><guid isPermaLink="false">近世代数/hw6.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate><enclosure url="lib\media\1-hw6-2025041815.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\1-hw6-2025041815.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw7]]></title><description><![CDATA[ 
 <br>习题3.1第3，10，11，12题

习题3.2第1，2，5，7，9题
<br>Exercise.
<img alt="hw7-2025042721.png" src="lib\media\hw7-2025042721.png">
<br>Definition (Integral domain).
A commutative ring  containing no zero-divisor is called an integral domain.
<br>Definition (unit).
 is called a unit in  if there exists  such that

<br>Proof.<br>
显然  是交换环. 假如  满足 . 那么<br><br>在 <a data-href="#^9a4a2a" href="about:blank#^9a4a2a" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^9a4a2a</a><a data-href="#^9a4a2a" href="about:blank#^9a4a2a" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a> 中，考虑 ，则 . 考虑 ，则 . 从而  是整环. <br>对于 ，它是单位元当且仅当存在  使得<br><br>也就是<br><br>这蕴含着<br><br>但是 ，这要求<br><br>当  非零时有<br><br>这意味着 . <br>若 ，则 . ( 否则  为零因子，非单位元.)<br>若 ，则 ，由取等条件可知 , .<br>综上：当  时，单位元群为 . 当  时，单位元群为 .<br>□<br>Exercise.
<img alt="1-hw7-2025042721.png" src="lib\media\1-hw7-2025042721.png">
<br>Proof.<br>
(1)<br><br><br>(2)<br>
<img alt="hw7-2025042722.png" src="lib\media\hw7-2025042722.png"><br>
 is a ring and  thus  is bool.<br>
□<br>Exercise.
<img alt="2-hw7-2025042721.png" src="lib\media\2-hw7-2025042721.png">
<br>Proof.<br>
An integral domain is a commutative ring with no zero-divisor. To verify that any nontrivial finite integral domain is field, it suffices to find the inverse for every . Consider the ring homomorphism of additive groups<br><br>The kernel , due to the property of integral domain. Thus  is injective, and hence is isomorphism by counting the number of elements. In particular,  is a multiplicative inverse of . Then we are done.<br>
□<br>Exercise.
<img alt="3-hw7-2025042721.png" src="lib\media\3-hw7-2025042721.png">
<br>Proof.<br>
(1) Since  are nilpotent, there exists , s.t. <br><br>Then <br><br>Either  or  happens. Then . Hence  is also nilpotent.<br>(2) The conclusion in (1) may fail when  is not commutative. Consider the nilpotent elements in the ring ,<br><br>But<br><br>is invertible, not nilpotent.<br>
□<br>Exercise.
<img alt="4-hw7-2025042721.png" src="lib\media\4-hw7-2025042721.png">
<br>A subset  is called an ideal provided that<br>
<br>, we have .
<br>, we have .
<br>Proof.<br>
Assume not, i.e. there exists an ideal . For , pick , then , which is a contradiction.<br>
□<br>Exercise.
<img alt="5-hw7-2025042721.png" src="lib\media\5-hw7-2025042721.png">
<br>Proof.<br>
If  is a ring automorphism, we have <br><br>The equation  has solution  in . If , then for any , , which means  is not automorphism. Thus .<br>Then consider , we have<br><br>Then . <br>For any ,  is determined by  and , since for any ,<br><br>Then <br><br>where .<br>(2) For , it is determined by , since for any ,<br><br>Since  is automorphism, we have . Otherwise,  is not unit, then is zero-divisor, i.e.  for some , which means .<br>We construct an isomorphism between  and ,<br><br>The kernel  is trivial. Then  is injective, and hence is isomorphism by counting the number of elements. Therefore,<br><br> □<br>Exercise.
<img alt="6-hw7-2025042721.png" src="lib\media\6-hw7-2025042721.png">
<br>Proof.<br>
Since <br><br>we have<br><br>Therefore,<br><br>Since  and , the homomorphism  is surjective. Then<br><br>Consider the dimension . And <br><br>Hence,<br><br>Any proper ideal of  containing  is generated by 2 elements, otherwise it's trivial.<br>
□<br>Exercise.
<img alt="7-hw7-2025042721.png" src="lib\media\7-hw7-2025042721.png">
<br>Proof.<br>
(1)<br>
For any , we have  for some . Since  is commutative,  is a two-side ideal. Then<br><br>Therefore, . <br>For any , we have  for some . Then<br><br>Hence  is an ideal.<br>(2)<br>
If , then it's trivial that . If , then  implies that  for some . Thus .<br>(3)<br>
Obviously, . Conversely, for any ,  for some . Then  for some . Hence . We are done.<br>(4)<br><br><br>For ,  for some . Thus . For any ,  for some , i.e. , where  for some . Thus <br><br>Therefore . Hence .<br><br>If  then  for some . Then . If  then  for some . Then , thus . Hence<br><br>□<br>Exercise.
<img alt="8-hw7-2025042721.png" src="lib\media\8-hw7-2025042721.png">
<br>Proof.<br>
For any , consider the sequence of principle ideals <br><br>Since the number of ideals is finite, we must have  for some . Then there exists  s.t. <br><br>Since  is integral domain,  is not zero-divisor, then . Since  is commutative,  is the inverse of . Due to the arbitrarity of , each nonzero element in  admits an inverse. Thus  is a field.<br>
□]]></description><link>近世代数\hw7.html</link><guid isPermaLink="false">近世代数/hw7.md</guid><pubDate>Fri, 09 May 2025 02:43:00 GMT</pubDate><enclosure url="lib\media\hw7-2025042721.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw7-2025042721.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw8]]></title><description><![CDATA[ 
 <br>习题3.3第1，2，9题

习题3.4第1，2，3，4，7，13题
<br>Exercise.
<img alt="hw8-2025051020.png" src="lib\media\hw8-2025051020.png">
<br>Proof.<br>
,  for some ; then ; thus . ,  for some ; then ; thus .  is an ideal in . <br>Consider the quotient ring ; if  is nilpotent,  for some ; then ; thus .  in the quotient ring.<br>
□<br>Exercise.
<img alt="1-hw8-2025051020.png" src="lib\media\1-hw8-2025051020.png">
<br>
 is the ring of  matrices with entries in the ring .
<br>Proof.<br>
Clearly,  is an ideal of the ring . Construct the ring homomorphisms<br><br><br>Then , . Thus<br><br>□<br>Exercise.
<img alt="2-hw8-2025051020.png" src="lib\media\2-hw8-2025051020.png">
<br>Proof.<br>
(1)<br>
The center of a ring , denoted , is defined as<br><br>Since  for any , then ; . <br>(2)<br>
Check that  is an ideal in .<br>For any  and ,<br><br>For any , <br><br>Thus  is an ideal in . Similarly,  is an ideal in .<br>Construct the mappings<br><br><br>We have<br><br><br><br><br><br><br><br><br>Thus  and  are homomorphisms. Also , . Then<br><br>□<br>Exercise.
<img alt="3-hw8-2025051020.png" src="lib\media\3-hw8-2025051020.png">
<br>Proof.<br>
We prove by induction on  that<br><br>The base case  is clear, and suppose that we have prove <a data-href="#^0166c5" href="about:blank#^0166c5" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^0166c5</a><a data-href="#^0166c5" href="about:blank#^0166c5" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a> for , and now we prove this for . By induction hypothesis, for each , we may find $x_i\in $ such that<br><br>If for some , , we have already verified <a data-href="#^0166c5" href="about:blank#^0166c5" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^0166c5</a><a data-href="#^0166c5" href="about:blank#^0166c5" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a> using this element . Now it suffices to treat the case when  for every . Then consider the element<br><br>Clearly . We show that  for every . Indeed, all elements in the sum except the  th term  belongs to . But as  is a prime ideal, this product  does not belong to . So . This completes the inductive proof.<br>
□<br>Exercise.
<img alt="4-hw8-2025051020.png" src="lib\media\4-hw8-2025051020.png">
<br>Proof.<br>
Let  be a finite commutative ring with prime ideal . Then  is an integral domain. As finite integral domain is field,  is maximal in .<br>
□<br>
<img alt="hw8-2025051100.png" src="lib\media\hw8-2025051100.png"><br>
<img alt="1-hw8-2025051100.png" src="lib\media\1-hw8-2025051100.png"><br>
<img alt="4-hw8-2025051100.png" src="lib\media\4-hw8-2025051100.png"><br>Exercise.
<img alt="5-hw8-2025051020.png" src="lib\media\5-hw8-2025051020.png">
<br>Proof.<br>
If  for some , pick , then <br><br>which is a contradiction.<br>
□<br>Exercise.
<img alt="6-hw8-2025051020.png" src="lib\media\6-hw8-2025051020.png">
<br>Proof.<br>
 for any . Claim  for some . Assume not, pick  for each , then  for each ; . But  for each , as  is prime, , which is a contradiction.<br>
□<br>Exercise.
<img alt="7-hw8-2025051020.png" src="lib\media\7-hw8-2025051020.png">
<br>Proof.<br><br><br>□<br><img alt="hw8-2025051101.png" src="lib\media\hw8-2025051101.png"><br>Exercise.
 is PID;  is its quotient domain;  is subring of . Show that  is PID.
<br>Proof.<br>
Let  be an ideal in , . Then for any ,  and , thus . For any ,  and , then .  is an ideal in . As  is PID,  for some  in . <br>Claim that . Clearly, . We need to show . For any , , . Since  is fraction field over PID, WLOG, assume that ; i.e.  for some . Then<br><br>Since  and , we have  thus  for some . Then <br><br>Therefore . Hence  is PID.<br>□]]></description><link>近世代数\hw8.html</link><guid isPermaLink="false">近世代数/hw8.md</guid><pubDate>Sun, 11 May 2025 07:04:33 GMT</pubDate><enclosure url="lib\media\hw8-2025051020.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw8-2025051020.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw9]]></title><description><![CDATA[ 
 <br>习题4.1第3，6，8题

习题4.3第6，8，9，13题
<br>Exercise.
设  为无平方因子的整数，. 

<br>证明  和  在  上均为不可约元
<br>证明  和  在  上不能同时为素元

<br>Example.
<img alt="6-hw9-2025052118.png" src="lib\media\6-hw9-2025052118.png">
<br>The mapping <br><br>is clearly a norm. , if ,  are not unit, then ,  satisfies , which cannot happen. , if , if , then , ; thus , , but  cannot happen. , if , if , then , , then , thus  is unit. Then , if  is reducible, then , which cannot happen. <br>Definition (素元).
设是一个整环，是一个非零非单位元，如果对任意的，若，则或，那么称是的一个素元.
<br>Example.
证明  和  在  上不能同时为素元。
<br>我们将分两种情况讨论： 是偶数和  是奇数。<br>情况 1： 是偶数。<br>由于  是无平方因子的偶数，且 ，所以  可以写成 ，其中  是奇数。我们有 （因为 ）。所以 。如果  是素元，那么  或者 （即 ）。<br>
<br>
 是否可能？如果 ，那么 。比较系数，我们得到  且 。这意味着  整除 。所以  或 。但我们已知 。因此  不整除 。（另一种方法是使用范数：如果 ，则 ，即 。因为  是偶数、无平方因子且 ，所以  不可能是  的因子，能满足这些条件的  不存在， 也被  排除。）

<br>
 是否可能？如果 ，那么 ，即 。这意味着 ，所以 。但  是无平方因子的，所以  不能被  整除。因此  不整除 。

<br>因为  整除乘积 ，但它既不整除  也不整除 ，所以当  是偶数（且 ，无平方因子）时， 不是素元。<br>情况 2： 是奇数。<br>我们有等式 。因为  是奇数，所以  是偶数。设 ，其中  是一个整数。于是 。<br>假设  是素元。<br>因为 ，所以  或者 。<br>
<br> 是否可能？如果 ，则  对某些整数  成立。展开得到 。比较系数，有 （所以 ）且 。代入  到第二个方程：。因为  是奇数且 ，所以 。因此  不是一个整数（因为 ）。所以  不整除 。
<br>因此，如果  是素元，它必须整除 。这意味着  对某些整数  成立。将此代入原方程 ：。因为 ，所以 。由于  是一个整环（integral domain），我们可以消去 ：。这意味着 。所以 。比较系数： 且 。这对于整数  是不可能的。<br>这个矛盾表明，如果  是奇数（且 ，无平方因子），那么  不是素元。<br>Exercise.
设  是整环. 证明多项式环  是 PID 当且仅当  是域.
<br>若  为域，那么存在 , 故  是 ED，故为 PID. 若  为 PID，那么对任意理想 ，考虑理想 ，由于  是 PID，故存在  使得 . 由于 ，故 ，，由于 ，故  为单位元. ，由于 ，故 ， 是单位，故 .  的任意理想平凡，故  是域.<br>Exercise.
<img alt="5-hw9-2025052118.png" src="lib\media\5-hw9-2025052118.png">
<br>在 PID 中，素理想都是极大理想，故  为域. <br> 是素元当且仅当  是素理想，当且仅当  是整环. <br>Exercise.
<img alt="1-hw9-2025052118.png" src="lib\media\1-hw9-2025052118.png">
<br>反证而设 , 记 . 若 , 则 <br><br>于是 , 由于  为奇数， 为偶数，故 ，于是  是  的非平凡因子，这与  不可约矛盾. 故 ,  的  前系数为 0，，于是 ，这与  不可约矛盾. <br>Exercise.
<img alt="2-hw9-2025052118.png" src="lib\media\2-hw9-2025052118.png">
<br> 是 PID,  的不可约元为一次多项式、无实根的二次多项式， 或 . 于是  的所有素理想（即极大理想）为 , ，, 其中 . <br>的素理想总结：<br>
<br>
 (零理想)。

<br>
, 其中 是 中的素数。

<br>
, 其中 是 中的非零本原不可约多项式。

<br>
, 其中 是 中的素数， 且其系数模 后得到的 是 中的不可约多项式。

<br>的极大理想总结：<br> 中的极大理想只有上述第 4 类理想：<br>, 其中 是 中的素数， 且其系数模 后得到的 是 中的不可约多项式。好的，我们来确定 和 的所有素理想和极大理想。<br>Exercise.
<img alt="3-hw9-2025052118.png" src="lib\media\3-hw9-2025052118.png">
<br><img alt="hw9-2025052200.png" src="lib\media\hw9-2025052200.png"><br>Exercise.
<img alt="4-hw9-2025052118.png" src="lib\media\4-hw9-2025052118.png">
<br>若 , , ，则 , 其中 , . 反之，若  可约，将前面的推导应用到  上，就有  可约. 故  在  中可约当且仅当  在  中可约. 故  在  中不可约当且仅当  在  中不可约. ]]></description><link>近世代数\hw9.html</link><guid isPermaLink="false">近世代数/hw9.md</guid><pubDate>Wed, 21 May 2025 16:35:09 GMT</pubDate><enclosure url="lib\media\6-hw9-2025052118.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\6-hw9-2025052118.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[integral-ring]]></title><description><![CDATA[ 
 <br><br>See 肖梁<br>Today, all rings are commutative.<br><img alt="integral-ring-2025051600.png" src="lib\media\integral-ring-2025051600.png"><br>We point out that, since the polynomial ring over a general ring is no longer a PID, we do not have the notion of “minimal polynomial” here.<br><img alt="1-integral-ring-2025051600.png" src="lib\media\1-integral-ring-2025051600.png"><br><img alt="4-integral-ring-2025051600.png" src="lib\media\4-integral-ring-2025051600.png"><br><img alt="5-integral-ring-2025051600.png" src="lib\media\5-integral-ring-2025051600.png"><br>
<img alt="6-integral-ring-2025051600.png" src="lib\media\6-integral-ring-2025051600.png"><br><br>Theorem (The Determinant Trick).
Let  be a commutative ring.<br>
Let  be an -module.<br>
Let  be an  matrix with entries .<br>
Let  be a column vector where each .
Suppose that , i.e.,<br>

Then,  for all .<br>
In other words, the determinant of the matrix  annihilates each element  of the vector .
<br>Proof.<br>
<br>
Recall the Adjugate Matrix: For any  matrix  with entries in a commutative ring , its adjugate (or classical adjoint), denoted , satisfies the property:<br>
where  is the  identity matrix. The entries of  are also in .

<br>
Multiply the System by the Adjugate:<br>
We are given the system of equations .<br>
Multiply both sides of this equation on the left by :<br>


<br>
Simplify:<br>
The right side is simply the zero vector:<br>
Using the associative property of matrix multiplication and the property of the adjugate:<br>


<br>
Conclusion:<br>
The product  is the vector:<br>
Since this vector is equal to the zero vector , each of its components must be zero:<br>


<br>□<br>
This trick is a cornerstone in various proofs in module theory, including versions of Nakayama's Lemma and the Cayley-Hamilton theorem for modules over commutative rings. It elegantly connects the "linear algebra" of matrices over a ring with the structure of modules over that ring.<br>Definition (Adjoint of  ).
Let  be a matrix with entries in a ring . The adjoint of , denoted , is the transpose of the matrix of cofactors of .
<br>In ring theory, the definition of the cofactor of a matrix is analogous to its definition in linear algebra over fields. Let  be an  matrix with entries in a commutative ring .<br>The -cofactor of , denoted as , is defined as  times the determinant of the  matrix formed by deleting the -th row and -th column of .<br>Specifically:<br>
<br>
Let  be the  matrix obtained by removing the -th row and the -th column from .

<br>
The -cofactor is .

<br>The matrix of cofactors is the matrix whose -entry is . The adjugate (or classical adjoint) of , denoted as , is the transpose of the cofactor matrix. That is, the -entry of  is .]]></description><link>近世代数\integral-ring.html</link><guid isPermaLink="false">近世代数/integral-ring.md</guid><pubDate>Thu, 15 May 2025 16:51:31 GMT</pubDate><enclosure url="lib\media\integral-ring-2025051600.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\integral-ring-2025051600.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Irreducibility-of-polnomial]]></title><description><![CDATA[ 
 <br><br><a data-tooltip-position="top" aria-label="https://kconrad.math.uconn.edu/blurbs/ringtheory/irredselmerpoly.pdf" rel="noopener nofollow" class="external-link" href="https://kconrad.math.uconn.edu/blurbs/ringtheory/irredselmerpoly.pdf" target="_blank">irredselmerpoly.pdf</a><br>For a general field  there is no simple way to determine if an arbitrary polynomial in  is irreducible. Here we will focus on the case  and describe two useful irreducibility tests in  for monic polynomials in . Let<br><br>The two tests are<br>
<br>
Reduction  : for a prime , reducing coefficients of  modulo  leads to

If  is irreducible in  for some , then  is irreducible in .

<br>
Eisenstein criterion: call  Eisenstein at  if  for all  and . If  is Eisenstein for some , then  is irreducible in .

<br>Remark.
But the converse is not true, considering . 
<br><br>Theorem (Theorem 1.1 (Selmer)).
For all , the polynomial  is irreducible in .
<br>
The proof is very classic.
<br>Proof.<br>Definition.
For nonzero  of degree , let  be its reciprocal polynomial:

<br>We call  the reciprocal polynomial because its roots are the reciprocals of the roots of . More precisely, if  has leading coefficient  and  then<br><br>The following properties of this construction will be used below without comment:<br>
<br>
if  then  and ,

<br>
if  then ,

<br>
for every nonzero constant ,

<br>
if  has degree  then the -coefficient of  is .

<br>Check all of these properties yourself. The last one is the most interesting.<br>
The proof of the theorem will be presented in three steps.<br>Step 1: For  and its reciprocal polynomial have no common root in characteristic 0 .<br>
The reciprocal polynomial is . If this shares a root with  in characteristic 0 , say , then<br><br>so . Thus . Substituting this into either equation in (2.1) gives us , which implies , so every power of  is either , or . If  then the first equation in (2.1) becomes , which is false since . If  then , which is absurd. If  then the two equations in (2.1) become  and , so , but . Thus a common root  in characteristic 0 doesn't exist.<br>Step 2: For , assume  and  and  have no common roots in characteristic 0 . If  for some nonconstant  and  in , then there is a  in  with  such that  and  or .<br>Since , both  and  are not 0 , so  and . Define<br><br>Then  and . If  and  are equal up to sign then  and  are equal up to sign, so  and  are equal up to sign, but then every root of  (it has roots since  is nonconstant) would be a common root of  and , which is a contradiction. The proof that  and  are not equal up to sign is similar with  in place of .<br>Step 3: The polynomial , for , is irreducible in .<br>
We argue by contradiction, and can assume  since the case  can be checked directly. If  is reducible in  then it factors into a product of two nonconstant polynomials in . Set . By Steps 1 and  for some  of degree  where  is not  or . Write , so . Then  in , so  and . Replacing  with  doesn't change  or , so with a sign change we can make  monic: . Then .<br>Comparing the coefficients of  in both  and ,<br><br>Since  and , we get  in , so exactly one of  is  and the rest are  with  and .<br>Let's look at the terms of  and  in degrees above  :<br><br>and<br><br>where  means terms of degree  or less. Thus<br><br>The terms on the left have distinct degrees since  (the last inequality uses  ), so there are three terms on the left with degree greater than . Therefore on the right side  (otherwise the right side would have only one term with degree above  ). If  then , so  and , so . If  then , so  and , so . Recalling that  is not  or , we have reached a contradiction.<br>□<br><br>The irreducibility argument we gave for  can be applied to nearly all trinomials of the form , in the sense that it tells us exactly when they are irreducible.<br>Theorem (Theorem A.1).
For  with , and  and  equal to , the polynomial  is irreducible in  if and only if it has no root in common with its reciprocal polynomial.
<br>Example (Example A.2.).
Let's apply <a data-href="#^09a789" href="about:blank#^09a789" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^09a789</a><a data-href="#^09a789" href="about:blank#^09a789" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 4 (Theorem A.1)</a>  to . Computer data suggest that  is reducible if and only if  with , and that in this case  is a factor of . For example,

<br>
<br> is irreducible unless  with  (e.g.,  ), when  is a factor,
<br> is irreducible unless , when  is a factor.
<br><br>Corollary (Corollary A.3).
For all  and , the polynomial  is irreducible in .
<br>Proof.<br>
The proof of <a data-href="#^fb918a" href="about:blank#^fb918a" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^fb918a</a><a data-href="#^fb918a" href="about:blank#^fb918a" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 2 (Theorem 1.1 (Selmer))</a><br>
still works when it is applied to both  and  (here the degree  is  ). Details are left to the reader.<br>
□<br>Theorem (Theorem A.4).
For  is irreducible over  if and only if  is a power of 3 and  is irreducible over  if and only if  for some nonnegative integers  and .
]]></description><link>近世代数\irreducibility-of-polnomial.html</link><guid isPermaLink="false">近世代数/Irreducibility-of-polnomial.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate></item><item><title><![CDATA[p-adic]]></title><description><![CDATA[ 
 <br><br>See <a data-tooltip-position="top" aria-label="https://w3.math.cinvestav.mx/p-adic2019/sites/default/files/Zuniga.pdf" rel="noopener nofollow" class="external-link" href="https://w3.math.cinvestav.mx/p-adic2019/sites/default/files/Zuniga.pdf" target="_blank">Zuniga.pdf</a><br>Definition (-adic norm).
Let  be a fixed prime number, and let  be a nonzero rational number. Then, , with , and . The -adic absolute value (or -adic norm) of  is defined as

<br>Definition (non-Archimedean metric).
Let  be a metric space. The metric  is called non-Archimedean if

<br>Exercise.
Let  be a valued field, where  is a non-Archimedean absolute value. Assume that  is complete with respect to . Then, the series  converges if and only if .
<br>Theorem (Ostrowski).
Any non trivial absolute value on  is equivalent to  or to the standard absolute value .
<br><br>Lemma.
Consider the set<br>
endowed with the p-adic norm . Then, the following assertions hold.

<br> is a complete metric space;
<br> is dense in ;
<br> is a field of characteristic zero;
<br>the completion of  is .

<br>(i)<br>
I don't understand.<br>(ii)<br>
We set<br>
Then any  can be written as , with  and . Given , , we have to show the existence of  such that . We take  and  satisfying .<br>(iii) omitted<br>(iv) combine (i), (ii), (iii).<br>The field of  -adic numbers  is defined as the completion of  w.r.t. the distance induced by . <br>The unit ball <br><br>is a PID. Any ideal of  has the form<br><br>Indeed, let  be an ideal. Set , and let  such that . Then . <br>From a geometric point of view, the ideals of the form , , constitute a fundamental system of neighborhoods around the origin in .<br>The residue field of  is  (the finite field with  elements). The group of units of  is<br>
<br>Exercise.
 is a unit iff . Moreover if , then , , .
<br><br>Define <br><br>as the ball with center  and radius , and<br><br>as the sphere with center  and radius .<br>The radius are always integer powers of . <br>Remark.
Notice that  and .
<br>We declare that the , , , are open subsets. These sets form a basis for the topology of . <br>Proposition.
,  are open and closed sets in the topology of .
<br>Proof.<br>
We first show that  is open. Notice that <br><br>Consequently,  is open.<br><img alt="p-adic-2025051522.png" src="lib\media\p-adic-2025051522.png"><br>□<br>Lemma.
If  then , i.e. any point of the ball  is its center.
<br>Proof.<br>
Let , then<br><br>i.e. .<br>Since  (i.e. ), we can repeat the previous argument to show that .<br>
□<br>Exercise.
Any two balls in  are either disjoint or one is contained in another.
<br>Exercise.
The boundary of any ball is the empty set.
<br>Theorem.
A set  is compact iff closed and bounded.
<br><br>We extend the  -adic norm to  by taking<br><br>We define , then .<br><br><br>Note that  but .<br>As a topological space  is totally disconnected, i.e. the only connected subsets of  are the empty set and the points.<br><br>Exercise (yau-2020-problem-5).
<img alt="p-adic-2025051523.png" src="lib\media\p-adic-2025051523.png"><br>
<img alt="1-p-adic-2025051523.png" src="lib\media\1-p-adic-2025051523.png">
<br><img alt="3-p-adic-2025051523.png" src="lib\media\3-p-adic-2025051523.png"><br>
<img alt="4-p-adic-2025051523.png" src="lib\media\4-p-adic-2025051523.png">]]></description><link>近世代数\p-adic.html</link><guid isPermaLink="false">近世代数/p-adic.md</guid><pubDate>Thu, 15 May 2025 15:30:43 GMT</pubDate><enclosure url="lib\media\p-adic-2025051522.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\p-adic-2025051522.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Permutation-Groups]]></title><description><![CDATA[ 
 <br>See 丘维声, 肖梁, dummit&amp;foote.<br>Theorem.
Any permutation can be decomposited to disjoint transpositions. (Unique without considering the order)
<br><br><br>And<br><br>Generally,<br><br>Since<br><br>Then<br><br><br>When , <br><br><br>When ,<br><br>Remark.
An element of odd order in a symmetric group is an even permutation, i.e. lies in . That's because the odd permutation can be decomposed to product of even transformations.
]]></description><link>近世代数\permutation-groups.html</link><guid isPermaLink="false">近世代数/Permutation-Groups.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate></item><item><title><![CDATA[Semidirect-product]]></title><description><![CDATA[ 
 <br><br>See <a data-tooltip-position="top" aria-label="https://kconrad.math.uconn.edu/blurbs/grouptheory/semidirect-product.pdf" rel="noopener nofollow" class="external-link" href="https://kconrad.math.uconn.edu/blurbs/grouptheory/semidirect-product.pdf" target="_blank">semidirect-product.pdf</a><br><br>Theorem (recognition theorem).
Let  be a group with subgroups  and  where

<br>; that is, every element of  has the form  for some  and ,
<br> in ,
<br> for all  and .

Then the map  by  is an isomorphism.
<br><br>In , let<br><br>Since<br><br>we have , and clearly  is trivial, but matrices in  and in  often do not commute with each other. You can find your own such matrices (nearly any random choice will work), but also observe that if elements of  and of  always commute with one another then  by <a data-href="#^0fe581" href="about:blank#^0fe581" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^0fe581</a><a data-href="#^0fe581" href="about:blank#^0fe581" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 1 (recognition theorem)</a> , but  since  is abelian (  and  are abelian) while  is nonabelian.<br><br>In , let  be a 2-Sylow subgroup and  be a 3-Sylow subgroup (so  and  is cyclic of order 3). In the Sylow theorems for  and , so  and  are not normal in . The set  can be written as -cosets  and as -cosets , so  is divisible by  and by , so . Therefore . The subgroups  and  intersect trivially. We have  since  has a nontrivial center (  and  both have nontrivial center) while  has a trivial center.<br>The center of  depends on whether  is even or odd. Recall that .<br>
<br>If  is odd, then .<br>
Proof.<br>
Suppose that . Write  or . Assume that . Then . Hence . But , so . Thus , which implies that . Thus , so  or . If , then . If , then  is even. So if  is odd, then . Now assume that . Then . Thus , so . Hence , so . Thus , so . But . Thus , so . This implies that , so  or . But  is odd and , a contradiction. Therefore, .<br>
□
<br>If  is even, then .<br>
Proof.<br>
Suppose that . Write  or . Assume that . Then . Hence . But , so . Thus , which implies that . Thus , so  or . If , then . If , then . Now assume that . Then . Thus , so . Hence , so . Thus , so . But . Thus , so . This implies that , so  or . If , then , so , a contradiction since . If , then . Thus .<br>
□
<br>In summary:<br><br><br>For subgroups  of ,   might not be a subgroup. However, if  or  is normal in , then  is a subgroup. Take , e.g.<br><br><br>Consider  induced by , then we have the natural definition:<br>Definition (semidirect product).
For two groups  and  and an action  of  on  by automorphisms, the corresponding semidirect product  is defined as follows: as a set it is . The group law on  is

<br>
Note that ,  might not be subgroups of the same group, e.g. , thus  fails to be defined, but  has definition. 
<br>Remark.
The notation  means  is normal "", and  has a "twisted" action on .
<br>Example.
In , so  if and only if  and .
<br>Example (Example 3.4).
Take , and  where  by . Note  is an automorphism of  as an additive group and  since  for all .
The group has the operation

This resembles the multiplication in , where . In the affine matrices we multiply in the upper left, while in , components multiply in the second coordinate. That suggests turning  into  by .
In the group  you have to be careful about how you decompose a matrix:

The nice decomposition puts the matrix associated to  first, before that associated to .
<br>Example (Example 3.5).
In the previous example, replace  with  and with . We have  since automorphisms of the additive group  are the mappings  for .
Let  by making  for each  be multiplication by . The semidirect product  has operation

and is isomorphic to  by .
<br>Example (Example 3.6).
Since  acts as additive automorphisms on , we have a semidirect product  where .
The homomorphism  given by  leads to a semidirect product  by .
<br>Theorem (Theorem 3.7).
Inside , we have

and . The copy of  in  is a normal subgroup with conjugation by  being described with  :

In particular,  commutes with each  if and only if , and every  and  commute if and only if  is trivial on  for all .
<br>^6742ba<br>
Proof.<br>
The proof is routine.<br>
□<br>Example (Example 3.8.).
Let , and  by . We saw in Example 3.4 that by .
<br><a data-href="#^6742ba" href="about:blank#^6742ba" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^6742ba</a><a data-href="#^6742ba" href="about:blank#^6742ba" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">^6742ba</a>  says the effect of  on  looks like conjugation in , and this is related to the affine group conjugation formula:<br><br>Example (The semiproduct isomorphic to .).
Example 3.10. Let  be an abelian group written additively, so negation neg:  is an automorphism of order 2. Let  by  and . Then  is a homomorphism (tip: when a group  contains an element  of order , we always get a homomorphism  by , and here we're using the special case  and  is inversion on . The group  has operation (3.6) . Then

Thus  and  commute in  if and only if . If all nonzero elements of  have order 2 (so negation on  is the identity) then . If some nonzero element of  does not have order 2 then  is nonabelian.
Consider the case  where . The group  has order  and the group law (3.6) in this special case is

This may look like a weird group of order , but in fact it is isomorphic to . If we identify  with  and  with  in  then  by  and . For example, (3.7) says , which matches the familiar dihedral relation . (The general multiplication rule in  is , where the exponents on  and  look like (3.7).)
<br><br>Similar to <a data-href="#^0fe581" href="about:blank#^0fe581" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^0fe581</a><a data-href="#^0fe581" href="about:blank#^0fe581" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 1 (recognition theorem)</a>, we have a recognition theorem for semidirect products.<br>Theorem (Theorem 4.1).
Let  be a group with subgroups  and  such that

<br>,
<br>,
<br>.

Let  be conjugation: . Then  is a homomorphism and the map  where  is an isomorphism.
<br>Proof.<br>
That  makes sense at all is due to (3). That it is a homomorphism means , and this is left to the reader to check. The function<br><br>where  is surjective by (1), and  is injective by (2) using the same argument for injectivity as in the proof of Theorem 2.1. To show  is a homomorphism, calculate<br><br>Hence  is an isomorphism.<br>
□<br>Example.
We will show for odd  that the direct product is isomorphic to a nontrivial semidirect product .
<br>We have met several examples of groups that are isomorphic to a semidirect product of two groups:<br>
<br>


<br>
;

<br>
;

<br>
;

<br>In these respective groups,<br>
<br>
 acts on  by multiplication maps  for ;

<br>
 is identified with  for any transposition  in ;

<br>
 is identified with  and  is identified with  in ;

<br>
 is identified with the group of matrices  (not with the matrices  );

<br><br>The case when  and  are finite with  is boring, since  has a trivial image and thus the only semidirect product  is the direct product .<br>Example.
A semidirect product  has order 15 and it must be a direct product:  has order 4 and that is relatively prime to 3. In fact, all groups of order 15 are cyclic; groups of order  will be studied below.
<br>Example (Construct a semiproduct).
Example 5.2. Is there a nontrivial ? Since  has size 20 and , there might be nontrivial examples. We seek a nontrivial homomorphism

It is necessary that  goes to a  such that . If , then , so (by testing ) . Then

Choose . Check  (in fact, if  then , so ). Let by , so  (e.g., ). We get a nontrivial semidirect product  with the group law

This is a nonabelian group of order  built from two cyclic groups of order 15 and 25.
<br><br>We'll use the Sylow theorems and semidirect products to find all groups of order  up to isomorphism.<br>Theorem (Theorem 6.1).
If primes  satisfy  then all groups of order  are cyclic.
<br>A useful lemma:<br>Lemma (Lemma 6.2).
A semidirect product  is unchanged up to isomorphism if the action  is composed with an automorphism of : for automorphisms .
<br>Moreover, if , then <br><br>e.g. if , then<br><br>Theorem (Theorem 6.3).
If primes  satisfy  then there are two groups of order  up to isomorphism: one is cyclic and one is nonabelian.
<br>Explicitly, for , a nonabelian matrix group of order  is<br><br><br>If a group  contains subgroups  and  such that  and , then  and  are called complementary subgroups. For a normal subgroup , is there always a complementary subgroup  ? If so, we'd then have .<br>The answer is no!<br>Example (Example 9.1.).
Suppose  is a cyclic -group with . Every subgroup of  is normal. Pick a subgroup  with . Suppose , so . Then  and  have subgroups of order  by Cauchy's theorem (or check this directly in cyclic -groups). The cyclic group  has at most one subgroup per size, so the subgroups of order  in  and  are the same, and thus . This contradiction shows  is not a semidirect product of two proper subgroups.
<br>Theorem (Schur-Zassenhaus).
If  and , then  has a complementary subgroup in  and all complementary subgroups to  in  are conjugate.
<br><br>Theorem.
Let  and  be isomorphisms. For each homomorphism  there is a corresponding homomorphism  such that .
]]></description><link>近世代数\semidirect-product.html</link><guid isPermaLink="false">近世代数/semidirect-product.md</guid><pubDate>Fri, 02 May 2025 09:47:45 GMT</pubDate></item><item><title><![CDATA[Simplicity-of-An]]></title><description><![CDATA[ 
 <br><br><a data-tooltip-position="top" aria-label="https://kconrad.math.uconn.edu/blurbs/grouptheory/Ansimple.pdf" rel="noopener nofollow" class="external-link" href="https://kconrad.math.uconn.edu/blurbs/grouptheory/Ansimple.pdf" target="_blank">Ansimple.pdf</a><br>Some examples of groups:<br>
<br>A finte group of prime order is simple.
<br>A finite abelian gorup  not of prime order is not simple.

<br>Let prime , by Cauchy's theorem,  contains a subgroup of order , which is abelian<a data-footref="[inline0" href="about:blank#fn-1-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a> thus normal in .


<br>When ,  is not simple since  with index 2.
<br>A meaningful result is as follows.<br>Theorem.
For ,  is simple.
<br>Proof.<br>
See <a data-tooltip-position="top" aria-label="https://kconrad.math.uconn.edu/blurbs/grouptheory/Ansimple.pdf" rel="noopener nofollow" class="external-link" href="https://kconrad.math.uconn.edu/blurbs/grouptheory/Ansimple.pdf" target="_blank">Ansimple.pdf</a>, where 5 proofs are listed.<br>
□<br>Next we show 3 useful lemmas and a theorem.<br>Lemma.
For  is generated by 3-cycles. For  is generated by permutations of type .
<br>The 3-cyclics in  are all conjugate in , since permutations of cycle type in  are conjugate. Are 3-cycles conjugate in ?<br>Lemma.
For , all 3-cycles in  are conjugate in .
<br>Lemma.
For , the only nontrivial proper normal subgroup of  is . In particular, the only subgroup of  with index 2 is .
<br>Corollary.
By <a data-href="#^c45dad" href="about:blank#^c45dad" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^c45dad</a><a data-href="#^c45dad" href="about:blank#^c45dad" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Lemma 4</a> , for  each homomorphic image of  not isomorphic to  has order 1 or 2. So there is no surjective homomorphism  for .
<br><br>Theorem.
For , no subgroup of  has index strictly between 2 and . Moreover, each subgroup of index  in  is isomorphic to .
<br>Proof.<br>
Let  be a proper subgroup of  and let , so . If  then  by Lemma 2.4. If  then we will show . The left multiplication action of  on  gives a group homomorphism<br><br>By hypothesis , so  is not injective. Let  be the kernel of , so  and  is nontrivial. Since , Lemma 2.4 says  or . Since , we get  or , which implies . Therefore we can't have .<br>Now let  be a subgroup of  with index . Consider the left multiplication action of  on . This is a homomorphism . Since  has order ,  is isomorphic to . The kernel of  is a normal subgroup of  that lies in  (why?). Therefore the kernel has index at least  in . Since the only normal subgroups of  are , and , the kernel of  is trivial, so  is an isomorphism. What is the image  in  ? Since  if and only if  is the group of permutations of  that fixes the "point"  in . The subgroup fixing a point in a symmetric group isomorphic to  is isomorphic to . Therefore .<br>
□<br>Corollary.
Let  be a field. If  and , the number of different polynomials we get from  by permuting its variables is either 1, 2, or at least .
<br>Proof.<br>
Letting  act on  by permutations of the variables, the polynomials we get by permuting the variables of  is the -orbit of . The size of this orbit is , where . By Theorem 2.7, this index is either 1, 2, or at least .<br>
□<br><br>Corollary.
For , each proper subgroup of  has index at least .
<br>
The proof is similar to <a data-href="#^93da7c" href="about:blank#^93da7c" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^93da7c</a><a data-href="#^93da7c" href="about:blank#^93da7c" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 6</a> 
<br>Proof.<br>
Let  be a proper subgroup of , with index . Consider the left multiplication action of  on . This gives a group homomorphism<br><br>Let  be the kernel of , so  (why?) and . By simplicity of  is trivial. Therefore  injects into , so  !, which implies .<br>
□<br>
<br>
<br>As  is abelian<a href="about:blank#fnref-1-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>近世代数\simplicity-of-an.html</link><guid isPermaLink="false">近世代数/Simplicity-of-An.md</guid><pubDate>Fri, 09 May 2025 13:38:13 GMT</pubDate></item><item><title><![CDATA[sylow-more]]></title><description><![CDATA[ 
 <br><br><a data-tooltip-position="top" aria-label="https://kconrad.math.uconn.edu/blurbs/grouptheory/sylowmore.pdf" rel="noopener nofollow" class="external-link" href="https://kconrad.math.uconn.edu/blurbs/grouptheory/sylowmore.pdf" target="_blank">sylowmore.pdf</a><br>It is natural to ask how the SYlow theorems can be extended to  -subgroups that are not  -Sylow subgroups. <br>Theorem (Theorem 4.1).
If  then there is a subgroup of  with size .
<br>
First we directly prove <a data-href="#^51886d" href="about:blank#^51886d" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^51886d</a><a data-href="#^51886d" href="about:blank#^51886d" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 1 (Theorem 4.1)</a> .
<br>Proof.<br>
We induct on the size of . The case when  or prime is trivial. Now suppose  and the theorem is proved for all groups of smaller size. That is, we assume each group  with  has a subgroup of size equal to an arbitrary prime power dividing .<br>Choose a prime power  dividing , with . We seek a subgroup of  with size . If  has a proper subgroup  such that , then we're done:  has a subgroup of size  by induction (since ) and this subgroup is in  too.<br>Now we suppose every proper subgroup  has size not divisible by . Since  is divisible by , we see every proper subgroup of  has index divisible by . Consider the class equation<br><br>where  represent the conjugacy classes of size greater than 1. We have  and  for each  since each subgroup  of  is proper (if  then  would be in a conjugacy class of size 1, which isn't true). Therefore . By Cauchy's theorem,  has an element of order , say . As .<br>We now consider the quotient group , which is a group with size less than that of . Since , by induction  has a subgroup with size . Its inverse image under  is a subgroup of  with size .<br>
□<br>Theorem (Cauchy's Theorem).
Let  be a finite group and let  be a prime. If  divides , then  contains an element of order .
<br>
Here is a proof: <a data-tooltip-position="top" aria-label="https://kconrad.math.uconn.edu/blurbs/grouptheory/cauchypf.pdf" rel="noopener nofollow" class="external-link" href="https://kconrad.math.uconn.edu/blurbs/grouptheory/cauchypf.pdf" target="_blank">cauchypf.pdf</a>.
<br>Theorem.
Let  be a finite group. If  and  then each subgroup of  with size  has index  in a subgroup of .
<br>From <a data-href="#^4aded7" href="about:blank#^4aded7" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^4aded7</a><a data-href="#^4aded7" href="about:blank#^4aded7" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 3</a> we can build a nested chain<br><br>where , so . <a data-href="#^51886d" href="about:blank#^51886d" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^51886d</a><a data-href="#^51886d" href="about:blank#^51886d" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 1 (Theorem 4.1)</a> is a special case of <a data-href="#^4aded7" href="about:blank#^4aded7" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^4aded7</a><a data-href="#^4aded7" href="about:blank#^4aded7" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 3</a>, so it suffices to prove <a data-href="#^4aded7" href="about:blank#^4aded7" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^4aded7</a><a data-href="#^4aded7" href="about:blank#^4aded7" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 3</a>.<br>Proof.<br>
The case  says there is a subgroup of size  in . This is Cauchy's theorem.<br>Now take . Let  be a subgroup of  with size . We want to find a subgroup  in which  has index . Consider the left multiplication action of  (not  ) on . Since  is a non-trivial -group,<br><br>The left side of the congruence is , which is divisible by . Which cosets in  are fixed points? They are<br><br>Therefore the set of fixed points of  acting on  is , which has the structure of a group since . By (4.2), , so Cauchy tells us there is a subgroup  of order . Its inverse image under  is a subgroup of  with size , and it contains  with index .<br>
□<br>Theorem (Orbit-Stabilizer Theorem).
Let  be a group acting on a set . For any , we have

where  is the orbit of  and  is the stabilizer of . In other words,

<br>Explain the reason why <a data-href="#^9fda5b" href="about:blank#^9fda5b" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^9fda5b</a><a data-href="#^9fda5b" href="about:blank#^9fda5b" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a> holds.<br>Let's consider the orbits of the action of  on . For any , the orbit of  under the action of  is given by . The size of this orbit is given by the Orbit-Stabilizer Theorem: ,<br>If  is not a fixed point, then there exists at least one  such that , which means  is a proper subgroup of . Since  is a -group of order , the size of any proper subgroup of  must be a power of  strictly less than . Therefore, the index  must be a multiple of .<br>We can partition the set  into disjoint orbits under the action of . Let  be the set of fixed points. Then,<br><br>We know that , and for every orbit  not in , its size  is a multiple of . Therefore, when we take this equation modulo , the sum on the right-hand side becomes 0 , and we are left with:<br><br>Corollary.
Let  be a -subgroup of the finite group . Then

In particular, if  then .
<br>Proof.<br>
The congruence here is (4.2). When , so .<br>
□<br>Theorem (Frobenius).
If , the number of subgroups of  with size  is .
]]></description><link>近世代数\sylow-more.html</link><guid isPermaLink="false">近世代数/sylow-more.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate></item><item><title><![CDATA[Sylow-theorems]]></title><description><![CDATA[ 
 <br><br><a data-tooltip-position="top" aria-label="https://aryamanmaithani.github.io/alg/groups/sylow-exercises/" rel="noopener nofollow" class="external-link" href="https://aryamanmaithani.github.io/alg/groups/sylow-exercises/" target="_blank">Sylow exercises | Aryaman Maithani</a><br><a data-tooltip-position="top" aria-label="https://kconrad.math.uconn.edu/blurbs/grouptheory/sylowapp.pdf" rel="noopener nofollow" class="external-link" href="https://kconrad.math.uconn.edu/blurbs/grouptheory/sylowapp.pdf" target="_blank">sylowapp.pdf</a><br><a data-tooltip-position="top" aria-label="https://kconrad.math.uconn.edu/blurbs/" rel="noopener nofollow" class="external-link" href="https://kconrad.math.uconn.edu/blurbs/" target="_blank">Expository papers by K. Conrad</a><br>Dummit&amp;Foote 4.5<br>
It should be pointed out that the definition of cosets does not require normality, but the definition of quotient group requires. What's the difference? The former (as set) admits disjoint orbits, but  need not be . The latter (as group) admits both.
<br><br>The affine group<br><br>It's defined by the transformation<br><br><br>The Heisenberg group over , denoted by , is the set of  upper triangular matrices of the form:<br><br>where:<br>
<br>, meaning they are elements of the finite field  (the integers modulo  ).
<br>The group operation is matrix multiplication.
<br><br><a data-tooltip-position="top" aria-label="https://kconrad.math.uconn.edu/blurbs/grouptheory/sylowapp.pdf" rel="noopener nofollow" class="external-link" href="https://kconrad.math.uconn.edu/blurbs/grouptheory/sylowapp.pdf" target="_blank">sylowapp.pdf</a><br>
<img alt="Sylow-theorems-2025040815.png" src="lib\media\sylow-theorems-2025040815.png"><br>
<img alt="1-Sylow-theorems-2025040815.png" src="lib\media\1-sylow-theorems-2025040815.png"><br>
<img alt="Sylow-theorems-2025040816.png" src="lib\media\sylow-theorems-2025040816.png"><br>
<img alt="1-Sylow-theorems-2025040816.png" src="lib\media\1-sylow-theorems-2025040816.png"><br>
<img alt="2-Sylow-theorems-2025040816.png" src="lib\media\2-sylow-theorems-2025040816.png"><br>
<img alt="3-Sylow-theorems-2025040816.png" src="lib\media\3-sylow-theorems-2025040816.png"><br><br><a data-tooltip-position="top" aria-label="https://aryamanmaithani.github.io/alg/groups/sylow-exercises/" rel="noopener nofollow" class="external-link" href="https://aryamanmaithani.github.io/alg/groups/sylow-exercises/" target="_blank">Sylow exercises | Aryaman Maithani</a><br>Exercise.
Prove that if  and  is a subgroup of  containing , then . Give an example to show that, in general, a Sylow -subgroup of a subgroup of  need not be a Sylow -subgroup of .
<br>Proof.<br>
We are given  with  and  such that . As , we get that  for some .<br>
Moreover,  and thus, . As , we get that .<br>
Thus,  is a Sylow -subgroup of .<br>For the second part, consider  and . Then  is a Sylow 2subgroup of  but not one of .<br>
□<br>Exercise.
Prove that if  is a subgroup of  and  then  for all .
<br>Proof.<br>
We first note that  is indeed a subgroup of .<br>
The assertion follows from the fact that  and .<br>
□<br>Exercise.
Use Sylow's theorem to prove Cauchy's theorem.
<br>Proof.<br>
Recall that Cauchy's theorem says that if  is a finite group such that  for some prime , then  has an element of order .<br>To prove this, let  and  be as above and  be a Sylow -subgroup of . (Existence of  is given by the Sylow theorems.)<br>Let  with usual meanings. Then, .<br>Consider  such that . Then, the order of  is  for some . Consider . Then, order of  is . (How? It is clear that . Thus, the only other possibility for the order is 1 but that is not possible since  as , the order of .)<br>
□<br>Exercise.
Exhibit all Sylow 2-subgroups and Sylow 3-subgroups of  and .
<br>Proof.<br>
 :<br>
Note that . Thus, the Sylow 2-subgroup(s) will have order 4 and Sylow 3-subgroup(s) will have order 3 .<br>Sylow 3:<br>
Note that a Sylow 3-subgroup must necessarily be isomorphic to . Since \underline{all elements not of the form  have order 2}, we just find powers of  which have order 3. These turn out to be  and . As , we have a unique Sylow 3-subgroup:<br><br>Sylow 2:<br>
Note that no element of  has order 4. (Any such element would have to be a power of  but 4 does not divide 6, the order of .)<br>
Thus, any Sylow 2-subgroup must be isomorphic to .<br>
Every element of this group must have order 2.  is the only power of  which has order 2. Thus, the other two elements must be of the form . Noting that the multiplication of two such elements is:<br><br>we get that . This gives us three such groups which are all the Sylow 2subgroups:<br><br>(It can be checked that all of these are distinct subgroups.)<br><br>
The order of the group is . Thus, the Sylow 2-subgroup(s) will have order 4 and Sylow 3-subgroup(s) will have order 9.<br>Sylow 2:<br>
Note that there are three subgroups of order 2 of . Let these be . (Note that these are indeed distinct.)<br>
Then, the nine products:<br><br>are subgroups of  have order 4. This gives us nine Sylow 2-subgroups. However, by the Sylow theorems,  and thus, there can't be any more.<br>Sylow 3:<br>
Let  be a Sylow 3-subgroup. Note that no element of  has order 9 . Thus, every non-identity element of  must have order 3 . Now, note that the order of an element  is the lcm of the orders of  and . This gives us that there are 8 elements of order 3 . These elements together with the identity do form a subgroup and moreover, there can't be any other. Thus, there is a unique Sylow 3-subgroup which is:<br><br>□<br>Exercise.
Show that a Sylow -subgroup of  is cyclic and normal for every odd prime .
<br>Proof.<br>
Let  as usual. As  is odd and  is even, we must have that  for some . Thus,  with .<br>Note that  has order  and hence,  has order . Hence,  is Sylow p-subgroup of <br>We now show that is normal. To do this, it is enough to work with the generators of . Clearly, . Also, . Thus,  is normal.<br>As all Sylow p-subgroups are conjugates, we get that the above Sylow p-subgroup is the unique Sylow p-subgroup. As it is cyclic and normal, we are done.<br>
□<br>Exercise.
Exhibit all Sylow 3-subgroups of  and all Sylow 3-subgroups of .
<br>Proof.<br>
 : Clearly, . We exhibit 4 such Sylow 3-subgroups now:<br><br>(Note that these are indeed distinct subgroups.)<br>These were easy to find as a Sylow 3-subgroup must have order 3 and thus, must be isomorphic to . It was then a matter of finding elements of order 3 .<br> : Same as earlier. Note that there are 8 elements of order 3. If we consider all the 8 subgroups generated by them, we see that we get \underline{only four distinct ones}, listed above.<br>
□<br>Exercise.
Exhibit all Sylow 2-subgroups of  and find elements of  which conjugate one of these into each of the others.
<br>Proof.<br>
A little bit of experimenting with elements of order 2 and 4 gives the following subgroups:<br><br>It can be verified that these are distinct. (For example, the 2 cycles listed in the generators don't appear in any of the other subgroups.) It can also be verified that all of these have order 8. Moreover, there can't be any more as .<br>As for the conjugation question, (34) conjugates the first to the second and (24) the second to the third.\footnote{Note that the conjugate of  works by transforming the places of the elements.}<br>
□<br>Exercise.
Exhibit two distinct Sylow 2-subgroups of  and an element of  that conjugates one into the other.
<br>Proof.<br>
Note that  and thus, any two of the Sylow 2-subgroups listed earlier will work again. (With the understanding that the elements are now elements of )<br>
□<br>Lemma.
The order of  is .
<br>Proof.<br>
Consider the choice of the first column. There are  choices for the first column. The second column must be a vector \underline{independent} of the first column. There are  choices for the second column.<br>
□<br>Exercise.
Exhibit all Sylow 3-subgroups of .
<br>Proof.<br>
Note that the order of  is . It can be easily shown that the order of  is half of that.<br>
Thus,  or 4 . Also, note that any Sylow 3-subgroup will have order 3 and hence, is isomorphic to .<br>
It is easy to find two distinct subgroups of order 3 by observing the following matrices to have order 3:<br><br>Also, these matrices generate distinct subgroups. Thus,  which forces . \textbf{We may now conjugate the above matrices to get the other two.} In any case, we are left with the following:<br><br>□<br>Exercise.
Prove that the subgroup of  generated by  and  is the unique Sylow 2-subgroup of .
<br>Proof.<br>
Hmm.<br>
□ <br>Exercise.
Prove that a group  of order 351 has a normal Sylow  -subgroup for some prime  dividing its order.
<br>Proof.<br>
Note that . By the Sylow theorems,  and  13. This forces . If , then we are done. Let us assume that . Thus, .<br>Thus, there are 27 Sylow 13 -subgroups of . As 13 is a prime, this forces the intersection of two distinct Sylow 13 -subgroups to be trivial. Thus, the number of elements having order 13 equals .<br>This leaves us with  remaining elements which are not part of any Sylow 13-subgroup. Now, by Sylow Theorems, we know that . However, no non-identity element can be part of a Sylow 3 as well as a Sylow 13 -subgroup. Thus, the remaining  elements form the unique Sylow 3 -subgroup which gives us that  and thus, we are done.<br>
□<br>Exercise.
Let , where , and  are primes with . Prove that G has a normal Sylow subgroup for either  or .
<br>Proof.<br>
Let , and  be distinct prime numbers. WLOG, we may assume that . Let  be a group with order .<br>We shall be appealing to the Sylow theorems without mentioning it explicitly. If any of , or  is equal to 1 , then we know that  is not simple. For sake of contradiction assume that each of the above is strictly greater than 1. As  and , we get that . (Since we have assumed that .) Thus, there are  Sylow-  subgroups of . <br>Now, note that each such Sylow-  subgroup has order , a prime and thus, the intersection of two distinct Sylow-  subgroups must be trivial, id est, (1). Thus, the number of elements having order  equals .<br>Now,  and . Thus, . However,  and thus, . This gives us that . Thus, the number of elements having order  equals .<br>Lastly, similar argument as earlier gives us that . Note that , and  are counting distinct non-identity elements and thus,<br><br>Thus, we have a contradiction as  and we are done!<br>
□<br>Exercise.
Prove that if , then  has a normal Sylow 5-subgroup and a normal Sylow 7 subgroup.
<br>Proof.<br>
Assume not. Then,  and .<br>Note that . The Sylow theorems force  and .<br>Note that the intersection of any two of these  Sylow subgroups must be trivial (by Lagrange's Theorem). Thus, their union contains exactly<br><br>This is clearly a contradiction. (As .)<br>
□<br>Exercise.
Prove that if  then  is not simple.
<br>Proof.<br>
Note that . For the sake of contradiction, let us assume that  is not simple. Thus, , and  are all strictly greater than 1 . Now, looking at the possibilities for each by considering the factors of the "complimentary part", we get that<br><br>Note that the intersection of any two of these Sylow subgroups must be trivial (by Lagrange's Theorem). Thus, their union contains exactly<br><br>This is clearly a contradiction. (As .)<br>
□<br>Exercise.
Prove that if  then  is not simple.
<br>Proof.<br>
Note that . For the sake of contradiction, let us assume that  is not simple. Thus, , and  are all strictly greater than 1<br>
.<br>
Now, looking at the possibilities for each by considering the factors of the "complimentary part", we get that<br><br>Note that the intersection of any two of these Sylow subgroups must be trivial (by Lagrange's Theorem). Thus, their union contains at least<br><br>This is clearly a contradiction.<br>
□<br>Exercise.
Prove that if  then  is not simple.
<br>Proof.<br>
Let  be a group with order 132 . We show that  is not simple.<br>Note that . Let us assume that  is simple and arrive at a contradiction. By simplicity, we know that , and .<br>By Sylow Theorem (3), it is forced that . Also,  and .<br>Note the following:<br>
<br>Intersection of any two Sylow- 11 subgroups is trivial.
<br>Intersection of any two Sylow-3 subgroups is trivial.
<br>Intersection of any Sylow-  subgroup with any Sylow-  subgroup is trivial.
<br>The above facts follow by considering the fact that the intersection would be a subgroup of the two bigger subgroups and would have to divide their orders.<br>Now, if we consider the union of all the Sylow-11 and Sylow- 3 subgroups, it contains at least  elements. Thus, the remaining elements are at most 3 . However, we do need at least 3 more elements to form a Sylow- 2 subgroup.<br>These 3 elements, along with the identity must form the unique Sylow- 2 subgroup of order 4 . However, we have reached a contradiction as we get that .<br>Thus, we are done!<br>□<br>Exercise.
Prove that if  then  is not simple.
<br>Proof.<br>
Note that . Considering the factors of 42 , we see that  is forced to be 1 .<br>
□<br>Exercise.
Prove that if  is a group of order 231 then  contains a Sylow 11-subgroup of  and a Sylow 7-subgroup is normal in .
<br>Proof.<br>
Note that . The restrictions from Sylow Theorems force that . In particular, this shows that  has a (unique) Sylow 7 -subgroup which is normal in it.<br>Now, we show that the Sylow 11-subgroup is contained in . Let us denote this subgroup by . Note that  is normal. Consider the action of  on  given by conjugation, that is, .<br>This induces a homomorphism . Note that  is cyclic and thus, . (The last equality may be manually verified by noting that  is a generator for  which has 10 elements.)<br>Thus,  is isomorphic to a subgroup of  (First Isomorphism Theorem). In particular, . Looking at the divisors of , we see that this forces  or .<br>This means that given any , the map  is the identity map. In other words,  for all  and . The above is equivalent to  or  for all  and . Thus, , by the definition of the center.<br>Remark. We didn't really require the fact that . Only  would've been sufficient (which is more straightforward as well).<br>
□<br>Exercise.
Let  be a group of order 105. Prove that if a Sylow 3-subgroup of  is normal then  is abelian.
<br>Proof.<br>
Let  be the Sylow 3-subgroup.<br>Claim 1: .<br>Note that  must divide both  and . This forces  or .<br>
(We have used the fact that  is normal in the above by considering the  defined similarly in the previous exercise.)<br>Claim 2:  is cyclic.<br>Note that  has order . Noting that  proves the claim. (See this.)<br>Claim 3:  is cyclic.<br>By the third isomorphism theorem, we have that<br><br>(Note that Claim 1 (and the fact that  ) tells us that  makes sense.) By the previous claim,  is cyclic. The claim follows as quotients of a cyclic group are cyclic.<br>Claim 4:  is abelian.<br>This is a consequence of the above claim. <br>□<br>Lemma.
 is isomorphic to . 
<br>Proof.<br>
Consider  as a 2-dimension vector in . Then  is a nondegenerate transform above .<br>
□<br>Exercise.
Let  be a group of order 315 which has a normal Sylow 3-subgroup. Prove that  contains a Sylow 3-subgroup of  and deduce that  is abelian.
<br>Proof.<br>
Let  be the normal Sylow 3-subgroup. (It must necessarily be unique.) Consider the action of  on  given by conjugation. (This is an action as  is normal.) Consider the induced homomorphism .<br>Now, note that  is a group of order 9 . Thus, it is isomorphic to either  or . Accordingly,  has order either 6 or 48.<br>As  by the first isomorphism theorem, we get that  divides 48. (6 divides 48 anyway.)<br>Also, . Thus,  is either 1 or 3.<br>If , then . However, note that  and hence  which is a contradiction as . Hence, we get that  or .<br>The above shows that the image of  is just the identity map. In other words,  for all  and . This is precisely what it means for .<br>The rest of the solution is now the same as the earlier one. We note that  has order 35 and hence, is cyclic. <br>We also have<br><br>and thus,  is cyclic. This proves that  is abelian.<br>
□<br>Exercise.
Let  be a group of order 1575 . Prove that if a Sylow 3 -subgroup of  is normal then a Sylow 5-subgroup and a Sylow 7 -subgroup are normal. In this situation prove that  is abelian.
<br>Proof.<br>
By the same arguments as earlier, we get that  is abelian. Now, by the Sylow Theorems, there do exist Sylow 5 and 7-subgroups. As  is abelian, they must be normal.<br>
□<br>Exercise.
How many elements of order 7 must there be in a simple group of order 
<br>Proof.<br>
Note that . The Sylow Theorems force  to be either 1 or 8 . If , then there is a unique Sylow 7 -subgroup which must be normal. This contradicts the assumption that the group is simple.<br>Thus, . This means that every Sylow 7 -subgroup is isomorphic to . In particular, every non-identity has order 7.<br>Moreover, two distinct Sylow 7-subgroups can only intersect trivially, by Lagrange's theorem. Thus, the total number of order 7 elements contained in these Sylow subgroups is<br><br>Now, we show that there are no more. That is, any order 7 element is contained in some Sylow 7-subgroup.<a data-footref="[inline0" href="about:blank#fn-1-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a><br>Let  be any order 7 element. Then,  is a 7-group and thus, must be contained in some Sylow 7 -subgroup, as desired. (In fact,  is itself a Sylow 7 -subgroup.)<br>
□<br>Exercise.
For , and 5 , find  and .
<br>Proof.<br>
 :<br>
Note that Sylow Theorems force  and .<br>As  is simple,  cannot be 1 for any  and hence,  and .<br>Now, we show that . Note that  is a Sylow 2-subgroup. (The way I found this was by taking a Sylow 2-subgroup from . And intersecting it with .) Note that its elements are<br><br>That is, identity along with all possible elements of the cycle type 1-2-2 formed using the numbers .<br>Recalling that all Sylow 2-subgroups are conjugates and also recalling how conjugates in  look, we see that any Sylow 2-subgroup is of this form:<br><br>(Where  are distinct elements of .)<br>This shows us that picking any four numbers from  uniquely defines Sylow 2 subgroup. (In the sense, that there's no over-counting or under-counting.) Thus, the number of such subgroups is .<br>To conclude, we have, for  :<br><br> :<br><br>For , we have the possibilities 1,10 , and 40 . Note that it can't be 1 as any Sylow 3 subgroup of  is again a Sylow 3-subgroup of  and we already had 10 there.<br>Now, if  were 40 , then there would be a total of 80 elements of order 3 . However, it can be verified that only elements of the cycle type (  ) have order 3 and there are only 20 of those. Thus, .<br>For , the discussion is even simpler as there are no new possibilities and we have  as before.<br>As before, we have . We show that  by demonstrating fifteen such subgroups. Let  be distinct. Assume that  is the smallest amongst the four.<br>Consider the subgroup:<br><br>It can be verified that the above does have 8 elements. Moreover, to determine such a subgroup, we first need to pick 4 elements from  and then from those 4 , pick an element to be paired with the smallest.<br>It can be verified that different such pickings will give different subgroups. (Simply by writing explicitly the elements of the above subgroup.)<br>This gives us  different subgroups and hence, we are done.<br>
To conclude, we have, for  :<br><br>□<br><br><a data-tooltip-position="top" aria-label="https://aryamanmaithani.github.io/alg/groups/simple/90/" rel="noopener nofollow" class="external-link" href="https://aryamanmaithani.github.io/alg/groups/simple/90/" target="_blank">Order 90 | Aryaman Maithani</a><br><a data-tooltip-position="top" aria-label="https://aryamanmaithani.github.io/alg/groups/simple/144/" rel="noopener nofollow" class="external-link" href="https://aryamanmaithani.github.io/alg/groups/simple/144/" target="_blank">Order 144 | Aryaman Maithani</a><br><br><a data-tooltip-position="top" aria-label="https://aryamanmaithani.github.io/alg/groups/simple/180/" rel="noopener nofollow" class="external-link" href="https://aryamanmaithani.github.io/alg/groups/simple/180/" target="_blank">Order 180 | Aryaman Maithani</a><br>Exercise.
Let  be a group with order 180. Show that  is not simple.
<br>Proof.<br>
Assume that  is simple, note that ; by Sylow III theorem, , . <br>Claim that . Suppose not, , then there is a homomorphism<br><br>recall that . By Sylow II theorem,  is transitive, thus . As  is simple,  is trivial, otherwise the nontrivial ; thus  is not simple. So , then<br><br>which is a contradiction. <br>Claim that . Suppose not, , then there is a homomorphism<br><br>Similarly, , then<br><br>We have , strictly between  and , which is impossible by the following lemma.<br>Lemma.
For , no subgroup of  has index strictly between 2 and . Moreover, each subgroup of index  in  is isomorphic to .
<br>Applying the idea in the proof of <a data-href="#^14333f" href="about:blank#^14333f" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^14333f</a><a data-href="#^14333f" href="about:blank#^14333f" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Lemma 27</a>, we consider the left multiplication action of  on ,<br><br>Then<br><br>Clearly, , then  is trivial or . Since  (by the definition of ), we have , thus  must be . Then<br><br>which is a contradiction. Hence .<br>Note that the intersection of any two Sylow-5 subgroups is trivial, since  is subgroup of , then ; .<br>Remark.
When , the intersection of Sylow  -subgroups may be nontrivial. A counterexample is ; consider , , which are Sylow 2-subgroups of ; but .
<br>Thus we now arrive the conclusion that  and . Then there are two cases,<br>
<br>Intersection of any two Sylow-3&nbsp;subgroups is trivial.
<br>Intersection of some two Sylow-3&nbsp;subgroups is non-trivial.
<br>In the first case, <br>
<br>The number of elements of order 9 is .
<br>The number of elements of order 5 is .
<br>; this is a contradiction.<br>In the second case, let  and  have nontrivial intersection. Note that  and thus  must contain exactly 3 elements. As groups of  order are abelian, we have . By the definition of group, the set  is contained in , as , . This gives<br><br>Thus the coset<br><br>Let  act on  by left multiplication,<br><br>Since  is simple,  is trivial; since the action is transitive, ; thus . <br><br>Therefore . But by <a data-href="#^14333f" href="about:blank#^14333f" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^14333f</a><a data-href="#^14333f" href="about:blank#^14333f" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Lemma 27</a>, , as  is a subgroup of , .<br>□<br><br>
This topic involves extensive discussion and various techniques in group theory.
<br>Let . Then  or 4 . We will show that if  then . Assume  and . Since  has no subgroup of size 18 (it would have index 2 and therefore be normal, so a 3-Sylow subgroup of it would be normal in  by Lemma 5.8, which contradicts  ). Since  is nonabelian. Our goal is to get a contradiction. We will try to count elements of different orders in  and find the total comes out to more than 36 elements. That will be our contradiction.<br>Let  be a 3-Sylow in , so . Left multiplication of  on  gives a homomorphism . Since , the kernel  is nontrivial. Since , either  or . Since  does not equal , so .<br>Since , we can make  act on  by conjugations. This is a homomorphism . If this homomorphism is onto (that is, some element of  conjugates on  in a nontrivial way) then the kernel is a subgroup of  with size 18 , which  does not have. So the conjugation action of  on  is trivial, which means every element of  commutes with the elements of , so . Then , so the size of  is one of the numbers in . Since  is nonabelian and a group is abelian when the quotient by its center is cyclic,  can't be 12,18 , or 36 . Since  there is no normal subgroup of size 9 , so . If  then the product set  is a subgroup of size 18 , a contradiction. So we must have , which means .<br>Now we start counting elements with various orders. The center is a 3 -subgroup of , so by the conjugacy of 3 -Sylow subgroups every 3 -Sylow subgroup contains . Each pair ofdifferent 3-Sylow subgroups have  as their intersection, so we can count the total number of elements of 3 -power order: .<br>Let  have order 2. Then  is a subgroup of order 6 by Lemma 4.1, and it is is abelian and in fact cyclic since . The cyclic group  has a unique element of order 2, which must be . Therefore when  and  are different elements of order 2 in , the groups  and  have  has their intersection. So each element of order 2 in  provides us with 2 new elements of order 6 . Let  be the number of elements of order 2 in , so there are at least  elements of order 6 , giving at least  elements in total with order 2 or 6 . Since we already found 27 elements with 3-power order (including the identity), , or . We can get an inequality on  in the other direction: . Indeed, no element of order 2 lies in , so some conjugate of an element of order 2 is a second element of order 2 . Thus .<br>Since  is even (by McKay's proof of Cauchy's theorem) and this number is  is odd, so . Therefore  has 3 elements of order 2 , so at least  elements of order 2 or 6 . Adding this to 27 from before gives , so each element of  has 3-power order or order 2 or 6 . In particular, the 2-Sylow subgroup of  is isomorphic to  (no elements of order 4 in . Then different 2-Sylow subgroups meet at most in a group of order 2 , which gives us 5 elements of order 2 from both subgroups. We saw before that there are only 3 elements of order 2 . This is a contradiction.<br>
<br>
<br>This is important.<a href="about:blank#fnref-1-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>近世代数\sylow-theorems.html</link><guid isPermaLink="false">近世代数/Sylow-theorems.md</guid><pubDate>Sat, 17 May 2025 14:55:41 GMT</pubDate><enclosure url="lib\media\sylow-theorems-2025040815.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\sylow-theorems-2025040815.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ture-or-false]]></title><description><![CDATA[ 
 <br><br>Exercise.
如果  是群  的正规子群，则  是  和  的半直积．<br>
If  is a normal subgroup of  ，then  is a semi-direct product of  with  ．
<br>False．It is not true in general that one can embed  back to  ．Semi－direct product requires that  can be realized as a subgroup of  ．（This is a hard  question．）<br>Simple Conclusion:<br>The statement is false because having a normal subgroup  in a group  does not guarantee that  contains a subgroup that is both isomorphic to the quotient group  and acts as a necessary "complement" to  for the semidirect product structure.<br>Exercise.
For , let  be a normal subgroup of  satisfying  and , then .
<br>False. If one wants , one needs the isomorphism  to induce the corresponding isomorphism . A typical example is to take  and  and . Clearly  and  are abstractly isomorphic, but  and .<br>Exercise.
In a UFD, every nonzero element can be uniquely written as products of prime elements.
<br>False. In a UFD, every nonzero nonunit element can be written as products of prime elements up to associates. Here "up to associates" means that the prime element factorization can be modified by units; and thus not literally unique.<br>Exercise.
Every cyclic extension  over  of degree  is of the form  for some  ．
<br>False．On needs  to contain  th roots of unity for this to be true．<br>Definition (Cyclic Extension).
A field extension  is called a cyclic extension if it is a finite Galois extension and its Galois group  is a cyclic group.
<br>Exercise.
Let  be a field extension of a field  with intermediate fields  and . Suppose that  and  are Galois over . Then .
<br>False. It is a theorem that . So the statement holds if and only if .<br>Exercise.
For any finite field  and any positive integer , there exists a unique (up to isomorphism) cyclic extension of  of degree .
<br>True. If  for  a power of a prime, then the cyclic extension of  of degree  is .]]></description><link>近世代数\ture-or-false.html</link><guid isPermaLink="false">近世代数/ture-or-false.md</guid><pubDate>Fri, 09 May 2025 06:55:17 GMT</pubDate></item><item><title><![CDATA[常微分方程周期性]]></title><description><![CDATA[ 
 <br><br><img alt="1-常微分方程周期性-2025051515.png" src="lib\media\1-常微分方程周期性-2025051515.png"><br>Exercise (yau-2020).
<img alt="2-常微分方程周期性-2025051515.png" src="lib\media\2-常微分方程周期性-2025051515.png">
<br>Proof.<br>
There exists constant , s.t.<br><br>Then  is bounded since<br><br>Then  for some . <br>If , we have , then  is monotonic.<br><br>Thus there exists , s.t. <br><br>Then<br><br><br>Therefore ; ; thus .<br>If , there exists , s.t. . There is a sequence , s.t. . Then <br><br>which has only finite solutions; thus there exists (WLOG)  s.t. <br><br>Then  and  has the same initial condition at . The solution is unique since<br><br>Let , then<br><br> is Lipschitz on , which guarantees the uniqueness. Hence  is periodic with period .<br>
□]]></description><link>偏微分方程\常微分方程周期性.html</link><guid isPermaLink="false">偏微分方程/常微分方程周期性.md</guid><pubDate>Thu, 15 May 2025 08:07:01 GMT</pubDate><enclosure url="lib\media\1-常微分方程周期性-2025051515.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\1-常微分方程周期性-2025051515.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[场论初步]]></title><description><![CDATA[ 
 <br><br><br>Definition (等值面).
设  是定义在空间区域  上的一个数量场．对其值域  中的任意一个实数  ，称点集

为  的一个等值面．
<br><img alt="场论初步-20250321.png" src="lib\media\场论初步-20250321.png"><br><img alt="1-场论初步-20250321.png" src="lib\media\1-场论初步-20250321.png"><br><img alt="2-场论初步-20250321.png" src="lib\media\2-场论初步-20250321.png"><br>Proof.<br>
证明考虑使用一大堆正交变换.<br>
□<br>Note
根据这个引理，如下定义是合理的
<br><img alt="3-场论初步-20250321.png" src="lib\media\3-场论初步-20250321.png"><br>数量场的梯度有以下性质<br>
<img alt="4-场论初步-20250321.png" src="lib\media\4-场论初步-20250321.png"><br><img alt="5-场论初步-20250321.png" src="lib\media\5-场论初步-20250321.png"><br>梯度运算的基本公式如下：<br>
<br> 为常数  ；
<br> 为常数）；
<br> ；
<br> ；
<br> ；
<br> ；
<br>更一般地，有

其中  表示函数  关于第  个变元的偏导数．
<br><br>对于封闭区面，本章总规定其单位法向量指向其外侧，即外侧为正侧，内侧为负侧.<br><img alt="6-场论初步-20250321.png" src="lib\media\6-场论初步-20250321.png"><br>以流体的速度场为例子，当流体速度场穿过  的通量大于零时，意味着流体从  所包围区域之内穿过  流向该区域之外的流量大于从其外部流向区域之内的流量，表明  所包围区域内必然有供给流体的源泉. 反之亦然. <br>因此，向量场  穿过封闭曲面  的通量反映了  所包围区域中产生向量场  的物质的正源与负源的某种代数和. <br>但我们不能了解这种源物质在局部的分布与强弱，因此我们通过取极限来达到这样的目的. 给出散度的定义. <br><img alt="7-场论初步-20250321.png" src="lib\media\7-场论初步-20250321.png"><br>当向量场  在  的散度  时，在  必有产生向量场  的物质的正源，并且  越大这种正源的强度越大，反之亦然. <br>散度不依赖于坐标系的选取.<br><img alt="8-场论初步-20250321.png" src="lib\media\8-场论初步-20250321.png"><br><img alt="9-场论初步-20250321.png" src="lib\media\9-场论初步-20250321.png"><br><img alt="10-场论初步-20250321.png" src="lib\media\10-场论初步-20250321.png"><br>散度运算具有以下基本性质：<br>
<br>（ 为常数）；
<br> ；
<br> ．
<br><img alt="11-场论初步-20250321.png" src="lib\media\11-场论初步-20250321.png"><br><br><img alt="12-场论初步-20250321.png" src="lib\media\12-场论初步-20250321.png"><br>由公式可以看出，向量场  沿封闭曲线  的环量反映了  沿  的旋转情况.<br>对于流体而言, 速度场沿封闭曲线的环量是否为零反映了曲线是否包围了漩涡的涡管; 当环量非零时, 其正负号反映了曲线的方向是否与它所包围漩涡的旋转方向一致, 其大小则反映了该漩涡的旋转强度.<br>与散度概念类似，为了了解向量场涡旋的局部分布情况，我们给出方向旋量的概念<br><img alt="13-场论初步-20250321.png" src="lib\media\13-场论初步-20250321.png"><br>方向旋量也不依赖于坐标系的选取.<br><img alt="14-场论初步-20250321.png" src="lib\media\14-场论初步-20250321.png"><br><img alt="15-场论初步-20250321.png" src="lib\media\15-场论初步-20250321.png"><br>定义<br><br>则有<br><br>Definition (旋度).
由 <a data-href="#^8f1ff8" href="about:blank#^8f1ff8" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^8f1ff8</a><a data-href="#^8f1ff8" href="about:blank#^8f1ff8" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a> 定义的向量  为向量场  在点  的旋度.
<br>旋度也记作 ，.<br><img alt="16-场论初步-20250321.png" src="lib\media\16-场论初步-20250321.png"><br>旋度运算具有以下基本性质：<br>
<br>（ 为常数）；
<br>；
<br> ．
<br>引力场和静电场都是无旋场.<br><img alt="17-场论初步-20250321.png" src="lib\media\17-场论初步-20250321.png"><br><img alt="18-场论初步-20250321.png" src="lib\media\18-场论初步-20250321.png"><br><br><br><img alt="19-场论初步-20250321.png" src="lib\media\19-场论初步-20250321.png"><br>
定义<br><br><img alt="20-场论初步-20250321.png" src="lib\media\20-场论初步-20250321.png"><br><br><img alt="21-场论初步-20250321.png" src="lib\media\21-场论初步-20250321.png"><br><img alt="22-场论初步-20250321.png" src="lib\media\22-场论初步-20250321.png"><br><br>下面推导一个重要定理 ——亥姆霍兹分解定理. 粗略地说, 这个定理告诉我们, 每个向量场都可分解为一个无源场和一个无旋场的和.<br><img alt="23-场论初步-20250321.png" src="lib\media\23-场论初步-20250321.png"><br><img alt="24-场论初步-20250321.png" src="lib\media\24-场论初步-20250321.png"><br><img alt="25-场论初步-20250321.png" src="lib\media\25-场论初步-20250321.png"><br><br>对于给定的一组标准正交基 ，对于标量场 ，定义梯度<br><br>对于 ，定义散度<br><br>定义旋度<br><br>对于 ，定义叉乘<br>]]></description><link>偏微分方程\场论初步.html</link><guid isPermaLink="false">偏微分方程/场论初步.md</guid><pubDate>Sun, 04 May 2025 16:37:03 GMT</pubDate><enclosure url="lib\media\场论初步-20250321.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\场论初步-20250321.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[分布]]></title><description><![CDATA[ 
 <br><br>参见于品数学分析讲义<br><br>我们用  表示在  上定义并且有紧支集的光滑函数所组成的集合，我们把它称作是为试验函数空间。按照定义，对于任意的  ，存在紧集 （这是  中的紧集），使得  ，即对任意的  。<br><br>以下是一些常见的闭包及其对应的函数空间：<br>
<br>在  空间中（使用  范数）：
<br>试验函数空间  在  空间中是稠密的，对于 。这意味着  在  范数下的闭包是整个  空间。<br>简单来说，任何一个  函数都可以通过一列试验函数在该范数下逼近。<br>
<br>在连续函数空间  或  中（使用一致范数 ）：
<br>试验函数是连续的，并且具有紧支集。在一致范数下，试验函数空间  的闭包是具有紧支集的连续函数空间 。这是因为任何一个紧支集连续函数都可以通过光滑的，紧支集函数（例如通过卷积光滑化）来一致逼近。<br>
<br>在 Sobolev 空间  中（使用 Sobolev 范数）：
<br>试验函数空间  在 Sobolev 空间  中是稠密的，对于  和非负整数 。这意味着  在  范数下的闭包是整个 Sobolev 空间 。Sobolev 空间是研究偏微分方程非常重要的函数空间，它包含了直到  阶的广义导数（或弱导数）存在且属于  空间的函数。<br><br>Definition (分布).
所谓 上的一个分布(也称作广义函数)指的是  上的一个线性泛函(线性映射):

满足如下两个条件

<br>对任意的 和  ，我们有


<br>对任意的紧集，存在非负整数 和正常数( 和 依赖于)，使得对任意的，都有

如果上述的  的选取不依赖于紧集  的选取，那么，我们就把最小的这样的非负整数  称作是分布  的阶。

<br>Example (Dirac 函数).
对任意的 ，我们可以定义分布 。其中，对于任意的 ，我们定义

我们来验证  实际上是分布：<br>
对任意的紧集 ，如果 ，那么，对任意的 ，我们都有

如果 ，那么，使得对任意的 ，我们有

所以，我们在分布的定义中取  即可。特别地，我们还知道  的阶为 0。
<br>Example (局部可积的函数).
给定开集 （总是装配了 Borel 代数和 Lebesgue 测度），局部可积的函数指的是在每个紧的局部上都可积的函数，即可测函数 （所对应的几乎处处相等的函数的等价类），对于任意紧集 ，函数 。我们用  表示  上局部可积的函数。
对于任意的 ，我们定义  上的线性泛函：

由于  在它的支集  上有界，所以，上面的积分是良好定义的。我们证明  是  上的阶为 0 的分布：对任意的紧集 ，对任意的 ，我们有

所以，我们在分布的定义中取  即可.
<br>Remark.
为了方便起见，我们通常把  直接写成 。
<br>Proposition.
任意选定 （我们通常偏爱之前所构造的那个  ），我们假定

对任意的  ，我们定义

那么，在分布的意义下，当  时，我们有  。
<br>Example (Radon 测度).
假设  是  上的测度，其中， 是开集， 是 Borel 代数（包含所有开集的最小 -代数）。如果每个紧集 ，我们就把这种测度称作是一个 Radon 测度。
比如说，对任意的正函数（几乎处处），对任意的 ，我们可以定义

这就是一个 Radon 测度。<br>
任意给定一个 Radon 测度 ，我们可以定义一个分布 ：对于 ，我们要求

我们证明  是  上阶为 0 的分布：<br>
对任意的紧集 ，对任意的 ，我们有

所以，我们在分布的定义中取  即可。<br>
特别地，我们可以把  中的元素看作是某个 Radon 测度的密度函数，从而，定义出了同样的分布。
<br>Remark.
利用所谓的 Riesz 表示定理，我们可以证明， 上所有的 0 阶分布都是（由如上方式给出的）Radon 测度。
<br>Proposition.
给定开集 ，我们已经定义如下的线性映射（把局部可积函数视为分布）

这是单射。
<br>Remark (广义函数的命名由来).
根据这个命题，局部可积的函数可以看做是分布的子集合。在分析中，我们把  的元素称作是  上的“函数”（这个类已经足够大了），由于某些分布不是“函数”，所以我们也经常把分布称作是“广义函数”。
<br>Lemma.
假设  并且 ，那么， 也是光滑函数。
<br>所以  是光滑函数（自然是局部可积的）。从而，当  时，上述积分的极限存在：<br><br>我们现在定义<br><br>为了证明这是分布，我们利用中值定理：对任意的紧集  ，对任意的支集在  上的光滑函数  ，我们有<br><br>所以，<br><br>所以  是一个阶不超过 1 的分布。在作业中，我们将证明  的阶恰好是 1 。<br>
 另外，vp 是法语 valeur principale 的缩略，英文文献经常用  ，因为他们把主值写为 principal value。
<br><br>在微积分的学习中，我们可以对一个函数做特定的操作，比如可以把一个函数限制到比较小的定义域上、可以对一个函数求导数、两个函数可以相乘等等。我们现在讨论如何对分布做一些特定的操作。<br>
我们通常用  表示试验函数.
<br><br>假设  是开子集，那么，我们可以定义限制映射<br><br>其中，对于每个  ，它自然可以看作是  中的元素，从而，我们可以要求<br><br><br>通过分部积分，我们有<br><br>这个计算启发我们对于  ，我们可以用下面的等式来定义它的导数：<br><br>Definition.
假设  是有界开集，给定  ，对于任意的多重指标  ，我们定义

<br>显然根据分布的定义，<a data-href="#^1d3091" href="about:blank#^1d3091" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^1d3091</a><a data-href="#^1d3091" href="about:blank#^1d3091" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Definition 1 (分布)</a>，第二条，可知分布的导数依然是分布。<br>Example.
我们计算  上的 Dirac 函数  的导数，其中  。任给  ，我们有

<br><br>对光滑函数  和分布  ，我们可以定义它们的乘积 ：<br><br>下一步验证 ，进而分布具有  -模结构.<br><br>根据 Leibniz 法则，我们有<br><br>所以，<br><br>这表明 。<br><br>对于  ，我们有如下的平移变换：<br><br>对于局部可积的函数  ，我们可以定义（这是一种特殊的变量替换）：<br><br>对一般的分布 , ，我们定义<br><br>容易验证 . （承自上一节中分布的  -模结构）<br>给定的两个开集和，我们假定<br><br>是微分同胚。对任意一个上的局部可积的函数和上的试验函数，根据换元积分公式，我们有<br><br>根据这个计算，我们定义：<br><br>其中，对于和，对于我们定义如下：<br><br>简单验证可知：. <br>Remark.
注记（记号）．因为在光滑函数情况下， 就是函数的复合，我们还把上面的拉回映射写成

<br>给定微分同胚 ，它把  上的 Dirac 函数拉回，得到  上的 Dirac 函数，这给出了 Jacobi 行列式的一个精确的解释：这是一点处体积的变化。<br><br>给定微分同胚  ，如果  是  的函数，我们可以对求导数运算运用链式法则：<br><br>对于一般的分布  ，我们实际上（后来）可以先用光滑函数逼近这个分布，然后上面的链式法则在极限的情况下仍然成立。<br>我们现在给出一个直接的证明：设  是  的逆映射。按照分布与一个微分同胚的复合的定义，我们有<br><br>另外，对任意  ，我们有<br><br>根据  到  嵌入的单射性，上面的等式等价于说<br><br>从而<br><br>这就证明如下关于分布的链式法则：<br><br><br>Theorem.
(Stokes 公式) 假设 是一个有界带边光滑区域， 为  的单位外法向量， 为  上的曲面测度。对任意的  ，我们有

<br><img alt="2-分布-2025050221.png" src="lib\media\2-分布-2025050221.png"><br>给定上面 Stokes 公式中所述的 ，它的边界  的曲面测度  在如下的意义下定义了  上一个分布：<br><br>这是一个 0 阶的分布，我们把证明的细节留给不放心的同学来验证。类似地，对每一个 ，如下的公式也定义了一个分布：<br><br>我们可以把 Stokes 公式改写成如下的形式：<br><br>所以，用分布的语言来写，我们有<br>Theorem (Stokes 公式).
假设  是一个有界带边光滑区域， 为  的单位外法向量， 为  上的曲面测度，作为分布，我们有等式

如果用向量值分布的语言（可以望文生义地定义）来写，我们有

<br>我们现在回到 1 维的情形，此时的 Stokes 公式就是 Newton-Leibniz 公式。<br>Lemma.
对于  ，我们定义其原函数为

那么， 是连续函数。在分布的意义下，我们有

<br>证明只需照章办事.（利用 Fubini 定理）<br><br>这里跳过第 60 节<br><br><br>Theorem (单位分解).
任意给定 中的紧集  ，假设  被有限个开集  所覆盖。那么，对每个  ，存在光滑函数  ，满足

<br>对任意  ，有  ；
<br>存在包含  的开集  ，对任意  ，我们有



<br>
 单位分解的证明并没有任何启发性的意义，我们只要能够运用该结论即可。
<br>我们现在证明一个分布  在（所有）小的开集上的限制决定了 ，这表明分布是可以局部定义的：<br>Theorem.
给定开集 。任意给定一族开集 ，其中对任意的 。我们假定

对每个 ，我们在  上指定一个分布 。如果这一族分布  满足如下的相容关系：

那么，存在唯一的 ，使得对任意的 ，我们都有

进一步， 当且仅当对每个 ;  当且仅当对每个 ，，其中 。
<br>
这个定理表明，在  的开集上所定义的分布可以构成  上的一个层。
<br><br>在代数几何中，仿射空间上的层通常指的是在某个拓扑空间（比如赋予通常的欧几里得拓扑）上的一个结构，它将每个开集关联到一个代数对象（比如一个环、一个模），并且这些关联满足某些相容性条件。更具体地说：<br>一个层由以下部分构成：<br>
<br>
对于每个开集，有一个代数对象，例如一个交换环。我们称为在上的截面。

<br>
对于每一对开集，有一个限制映射，它是一个代数同态。这个映射描述了如何将上的截面限制到上。

<br>这些数据需要满足以下公理：<br>
<br>
恒等性： 对于每个开集，是上的恒等映射。

<br>
传递性： 如果是中的开集，那么。换句话说，从限制到，可以直接进行，也可以先限制到再限制到，结果是一样的。

<br>
粘合性： 设是开集的一个开覆盖。如果是两个截面，并且对于每个，都有，那么。也就是说，如果两个截面在每个开覆盖的子集上都相等，那么它们在整个集合上相等。

<br>
整体截面的存在性： 设是开集的一个开覆盖。假设我们有一族截面，使得对于每一对，都有。那么存在唯一的截面，使得对于每个，都有。也就是说，如果一族截面在开覆盖的交集上相容，那么它们可以粘合成一个整体截面。

<br>最常见的例子是连续函数层，其中是上所有连续实值函数的集合，限制映射就是通常的函数限制。另一个重要的例子是全纯函数层，其中是上所有全纯函数的集合，限制映射也是通常的函数限制。<br><br>给定开集上的分布  ，我们来定义它的支集。<br>假设  是开子集，如果 ，我们就说  在  上为零，也就是说，对于每个 ，我们有<br><br>我们现在来说明，存在  中使得  在其上为零的最大开集。为此，我们定义<br><br>令<br><br>按照定义， 为开集。我们要证明 ，为此，只要证明对任意的 ，我们都有<br><br>即可。实际上，令 ，那么存在限个  覆盖 。我们取与这个覆盖相应的单位分解 。从而，<br><br>最后一步，我们用到了 。很明显， 是这种开集中最大的。<br>Definition (分布的 (紧) 支集).
我们把  称作是  的支集并仍然用符号  表示。如果  是紧集，我们就说  是有紧支集的分布。我们用  来表示  上有紧支集的分布的全体。
]]></description><link>偏微分方程\分布.html</link><guid isPermaLink="false">偏微分方程/分布.md</guid><pubDate>Sat, 03 May 2025 15:37:38 GMT</pubDate><enclosure url="lib\media\2-分布-2025050221.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\2-分布-2025050221.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[傅里叶变换的一致连续性]]></title><description><![CDATA[ 
 <br><br>Definition.
设 , 即 . 其傅里叶变换  定义为:

其中  表示  和  在  中的标准内积（点积）。
<br>我们要证明  在  上是一致连续的。也就是说，对于任意的 , 存在一个 , 使得对于所有 , 若 , 则 .<br>Proof.<br>
考虑差值 :<br><br>由于 , 我们可以得到:<br><br><br>令 . 我们的目标是证明当  时,<br><br>我们使用勒贝格控制收敛定理 (Lebesgue's Dominated Convergence Theorem)。定义函数序列（或族） .<br>
<br>
逐点收敛 (Pointwise Convergence):
对于任意固定的 , 当  时, . 因此, . 所以, . 从而,  对于几乎所有的 （在  定义的意义上）。

<br>
控制函数 (Dominating Function):
对于任意  和任意 , 我们有:<br>
. 因此, . 由于 , 函数  在  上是可积的, 即 .

<br>根据勒贝格控制收敛定理，由于  逐点收敛到  并且被一个可积函数  控制，我们有:<br><br><br>这意味着，对于任意 , 存在一个 , 使得只要 , 就有<br><br>将  代回，如果 , 则<br><br>这正是函数  在  上一致连续的定义。<br>
□<br>因此,  上的  函数的傅里叶变换是一致连续函数。这个性质也被称为 Riemann-Lebesgue 引理的一个推论或相关性质（尽管 Riemann-Lebesgue 引理本身通常指  当 ）。]]></description><link>偏微分方程\傅里叶变换的一致连续性.html</link><guid isPermaLink="false">偏微分方程/傅里叶变换的一致连续性.md</guid><pubDate>Tue, 13 May 2025 07:03:44 GMT</pubDate></item><item><title><![CDATA[高维常微分方程]]></title><description><![CDATA[ 
 <br><br>参见 Arnold，他使用了一种很高的观点.<br><br>Consider , defined by the vector field . We define the Picard mapping <br><br>Geometrically, passing from  to  means constructing w.r.t. a curve  a new curve  whose tangent for each  is parallel to a given direction field, only not on the curve  itself -- for then  would be a solution -- but at the corresponding point of the curve .<br>
<img alt="1-高维常微分方程-2025051316.png" src="lib\media\1-高维常微分方程-2025051316.png"><br>To prove convergence of the successive approximations we shall construct a complete metric space in which the Picard mapping is a contraction. <br>The mapping  satisfies a Lipschitz condition with constant  provided that <br><br>Let  be a  - mapping (). Naturally, the derivative of  at <br><br>is a linear operator. If we choose a basis for each tangent space,  has a  matrix representation. <br>
 provides the best linear approximation of  at the neighborhood of , i.e. .
<br><img alt="高维常微分方程-2025051317.png" src="lib\media\高维常微分方程-2025051317.png"><br>Remark.
By hypothesis ,  is continuous; then  attains a maximum value  on any compact set .
<br>See arnold for the proof of theorem of existence and uniqueness.<br>Next we consider the theorem on differentiablility. The motivation is as follows.<br>Associated with a differentiable mapping  is a linear operator on the tangent space<br><br>At each point , .<br>In exactly the same way with a differential equation<br><br>there is associated a system of differential equations<br><br>called the system of equations of variations for <a data-href="#^e0c026" href="about:blank#^e0c026" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^e0c026</a><a data-href="#^e0c026" href="about:blank#^e0c026" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a>, and linear w.r.t. the tangent vector .<br>
<img alt="1-高维常微分方程-2025051317.png" src="lib\media\1-高维常微分方程-2025051317.png"><br>We can correspond the unknown vector  to a unknown linear operator .<br><img alt="2-高维常微分方程-2025051317.png" src="lib\media\2-高维常微分方程-2025051317.png"><br><br>Suppose  of <a data-href="#^e0c026" href="about:blank#^e0c026" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^e0c026</a><a data-href="#^e0c026" href="about:blank#^e0c026" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a> is  in some neighborhood of . Then the solution  of  <a data-href="#^e0c026" href="about:blank#^e0c026" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^e0c026</a><a data-href="#^e0c026" href="about:blank#^e0c026" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a> with initial condition  depends on the condition  in a continuously differentiable manner as  and  vary in some neighborhood of :<br><br><img alt="3-高维常微分方程-2025051317.png" src="lib\media\3-高维常微分方程-2025051317.png"><br><img alt="5-高维常微分方程-2025051317.png" src="lib\media\5-高维常微分方程-2025051317.png"><br>
This theorem explains the meaning of the equations of variations: they describe the action of the transformation over the time from  to  on the vectors tangent to the phase space (Fig. 227).<br>
<img alt="6-高维常微分方程-2025051317.png" src="lib\media\6-高维常微分方程-2025051317.png"><br>More generally, <br><br>We prove by induction<br><br>In fact, we have<br><br><img alt="高维常微分方程-2025051318.png" src="lib\media\高维常微分方程-2025051318.png"><br>Lemma.
The solution of a linear equation

whose right-hand side depends continuously on , exists; is unique; is determined uniquely by the initial conditions ; is a continuous function of  and ; is a linear function of  and a continuously differentiable function of , thus  in  and .
<br>Lemma.
The solution of a linear equation

where  is continuous, is a continuous function of , , and .
<br>We now apply <a data-href="#^2cddf1" href="about:blank#^2cddf1" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^2cddf1</a><a data-href="#^2cddf1" href="about:blank#^2cddf1" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Lemma 3</a> to the equation of variations, <a data-href="#^90ff85" href="about:blank#^90ff85" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^90ff85</a><a data-href="#^90ff85" href="about:blank#^90ff85" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (2)</a> .<br>The system of equations of variations<br><br>has a solution uniquely determined by its initial data and depends continuously on them provided .]]></description><link>偏微分方程\高维常微分方程.html</link><guid isPermaLink="false">偏微分方程/高维常微分方程.md</guid><pubDate>Tue, 13 May 2025 10:11:31 GMT</pubDate><enclosure url="lib\media\1-高维常微分方程-2025051316.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\1-高维常微分方程-2025051316.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[缓增分布的Fourier变换]]></title><description><![CDATA[ 
 <br><br>参见于品数学分析讲义]]></description><link>偏微分方程\缓增分布的fourier变换.html</link><guid isPermaLink="false">偏微分方程/缓增分布的Fourier变换.md</guid><pubDate>Fri, 02 May 2025 10:03:11 GMT</pubDate></item><item><title><![CDATA[Diffusion]]></title><description><![CDATA[ 
 <br><br>See Partial Differential Equations in Action, Complements and Exercises.<br>The diffusion equation (heat equation) is<br><br>defined on a cylindrical domain , where  is a domain<a data-footref="[inline0" href="about:blank#fn-1-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a> of , and the Laplacian  is taken w.r.t. the spatial variables  only.<br><br><img alt="Diffusion-2025050311.png" src="lib\media\diffusion-2025050311.png"><br>
<img alt="1-Diffusion-2025050311.png" src="lib\media\1-diffusion-2025050311.png"><br>
<img alt="2-Diffusion-2025050311.png" src="lib\media\2-diffusion-2025050311.png"><br>
<img alt="3-Diffusion-2025050311.png" src="lib\media\3-diffusion-2025050311.png"><br>为了保证一个函数的傅里叶级数收敛，该函数需要满足一定的条件。以下是一些常见的条件：<br>
<br>
狄利克雷条件（Dirichlet Conditions）：<br>
一个周期为  的函数 ，如果满足以下条件，则其傅里叶级数收敛：

<br>在任何有限区间内， 只有有限个不连续点。
<br>在任何有限区间内， 只有有限个极大值和极小值。
<br> 在任何有限区间内是绝对可积的，即 。

如果  在  处连续，则傅里叶级数收敛到 ；如果  在  处有跳跃不连续点，则傅里叶级数收敛到 ，其中  和  分别表示  在  处的右极限和左极限。

<br>
更强的条件：

<br>如果  是连续的，并且  存在且连续，那么  的傅里叶级数一致收敛到 。
<br>如果  是平方可积的，即 ，那么  的傅里叶级数在均方意义下收敛到 。


<br>总的来说，狄利克雷条件是最经典和常用的判断傅里叶级数收敛的条件。<br><br><img alt="5-Diffusion-2025050311.png" src="lib\media\5-diffusion-2025050311.png"><br>
<img alt="6-Diffusion-2025050311.png" src="lib\media\6-diffusion-2025050311.png"><br>
<img alt="7-Diffusion-2025050311.png" src="lib\media\7-diffusion-2025050311.png"><br>
<img alt="8-Diffusion-2025050311.png" src="lib\media\8-diffusion-2025050311.png"><br>Definition (Bessel's equality).
令是一个希尔伯特空间，并设是的一个正交基。那么，对于中的任何，Bessel 不等式成立

<br>Definition (Bessel's equality).
Let  be a function on  such that . Then

where

<br>Theorem (Poincaré's inequality).
设  是一个有界开集。存在一个常数 ，使得对于所有 ，有

<br>Proof.<br>
设  是一个有界开集。那么存在一个 ，使得 。设 。我们可以将  延拓到  上，使得 。那么  在  上为 0。因此，我们可以将  延拓到  上，使得 。<br>对于 ，有<br><br>因此，<br><br>利用 Cauchy-Schwarz 不等式，我们有<br><br>由于  是有界的，所以 。因此，<br><br>在  上积分，我们有<br><br>因此，<br><br>取平方根，我们有<br><br>□<br>Theorem (Poincaré不等式（n=1）).
设，其中。那么

<br>Proof.<br>
通过延拓为上的奇函数，其中，我们有。因此，的傅里叶级数为<br><br>其中<br><br>Parseval恒等式给出<br><br>此外，形式上的导数为<br><br>因此<br><br>由于，我们有<br><br>或者<br><br>由于在外为零，且，我们得到<br><br>□<br><br><img alt="3-Diffusion-2025050312.png" src="lib\media\3-diffusion-2025050312.png"><br>
<img alt="4-Diffusion-2025050312.png" src="lib\media\4-diffusion-2025050312.png"><br><img alt="5-Diffusion-2025050312.png" src="lib\media\5-diffusion-2025050312.png"><br><br><img alt="Diffusion-2025050312.png" src="lib\media\diffusion-2025050312.png"><br>
<img alt="1-Diffusion-2025050312.png" src="lib\media\1-diffusion-2025050312.png"><br>
<img alt="2-Diffusion-2025050312.png" src="lib\media\2-diffusion-2025050312.png"><br><br><img alt="Diffusion-2025050315.png" src="lib\media\diffusion-2025050315.png"><br>If  on , then  reaches its maximum and minimum on the boundary .<br><img alt="1-Diffusion-2025050315.png" src="lib\media\1-diffusion-2025050315.png"><br>
<img alt="2-Diffusion-2025050315.png" src="lib\media\2-diffusion-2025050315.png"><br><br><img alt="3-Diffusion-2025050315.png" src="lib\media\3-diffusion-2025050315.png"><br>
<img alt="4-Diffusion-2025050315.png" src="lib\media\4-diffusion-2025050315.png"><br><br><img alt="6-Diffusion-2025050315.png" src="lib\media\6-diffusion-2025050315.png"><br>
<img alt="7-Diffusion-2025050315.png" src="lib\media\7-diffusion-2025050315.png"><br><br><img alt="6-Diffusion-2025050316.png" src="lib\media\6-diffusion-2025050316.png"><br>
<img alt="7-Diffusion-2025050316.png" src="lib\media\7-diffusion-2025050316.png"><br>
<img alt="8-Diffusion-2025050316.png" src="lib\media\8-diffusion-2025050316.png"><br>
<img alt="9-Diffusion-2025050316.png" src="lib\media\9-diffusion-2025050316.png"><br><br><img alt="5-Diffusion-2025050315.png" src="lib\media\5-diffusion-2025050315.png"><br><br><img alt="8-Diffusion-2025050315.png" src="lib\media\8-diffusion-2025050315.png"><br>
<img alt="10-Diffusion-2025050315.png" src="lib\media\10-diffusion-2025050315.png"><br><br>We separate the variables twice.<br><img alt="1-Diffusion-2025050316.png" src="lib\media\1-diffusion-2025050316.png"><br>
<img alt="2-Diffusion-2025050316.png" src="lib\media\2-diffusion-2025050316.png"><br>
<img alt="3-Diffusion-2025050316.png" src="lib\media\3-diffusion-2025050316.png"><br><br><img alt="4-Diffusion-2025050316.png" src="lib\media\4-diffusion-2025050316.png"><br>
<img alt="5-Diffusion-2025050316.png" src="lib\media\5-diffusion-2025050316.png"><br>
<br>
<br>connected, open subset<a href="about:blank#fnref-1-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>偏微分方程\diffusion.html</link><guid isPermaLink="false">偏微分方程/Diffusion.md</guid><pubDate>Sun, 04 May 2025 15:32:10 GMT</pubDate><enclosure url="lib\media\diffusion-2025050311.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\diffusion-2025050311.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[first-order-equation]]></title><description><![CDATA[ 
 <br>]]></description><link>偏微分方程\first-order-equation.html</link><guid isPermaLink="false">偏微分方程/first-order-equation.md</guid><pubDate>Sun, 04 May 2025 15:32:10 GMT</pubDate></item><item><title><![CDATA[Fourier 分析初步]]></title><description><![CDATA[ 
 <br><br>参见于品数学分析讲义 65,66节<br>Definition ( 函数的 Fourier 变换).
对于函数 ，我们定义它的 Fourier 变换 （或者 ) 为如下的  上的函数：

其中 。我们通常把  的定义域  称作是频率空间，它的变量通常用  来表示。
<br>我们考虑  的线性子空间<br><br>我们知道  是 Banach 空间. (取一列  内  于 ，验证  即可)<br>Lemma (引理 335).
给定赋范线性空间  和它们之间的  线性映射  。那么，如下三个论断是等价的：

<br> 在  处连续；
<br> 是连续的；
<br> 是有界，即存在  ，对每个  ，我们都有



<br>Theorem (Theorem 4.48).
对任意的 , . 特别地, 线性映射

是连续线性映射, 即存在常数 , 使得对任意的 , 我们有

<br>显然<br><br>由于  在  中稠密，故只需要证明  连续，由 Lebesgue 控制收敛定理可知：假设  中的点列 ，有<br><br>控制函数为 .<br>对于 , 我们有如下两个重要观点：<br>
<br>物理空间的求导等价于频率空间的乘法：
<br>物理空间的乘法等价于频率空间的求导：
<br>实际上，对任意的 ，对任意的正整数 ，利用第一个原则，我们有<br><br>其中  是 Laplace 算子.<br>很明显，，所以，我们有<br><br>这表明  是衰减的并且我们对于  求的导数越多，那么衰减速度就越快. 特别地，我们还证明了 . <br>通常为了说明  在无穷远处趋于 0，我们任取 ，再选取  使得<br><br>从而对于任意的 ，我们有<br><br>当  很大的时候，有 .<br>然⽽，这些过程实际上都被包装在开始的命题上，所以我们通常只对光滑有紧支集的函数（在  中稠密）来证明即可.<br><br>Theorem (卷积对应于频率空间的乘积).
对任意的  ，我们有

<br>Proposition.
假设 . 那么，

<br><br>Proposition (命题 451 （仿射坐标变换与 Fourier 变换之间的关系）).
任给  和可逆线性变换

我们有<br>
1）物理空间的平移对应频率空间乘相应的频率，即

2）频率空间应该视作是余切丛，即

<br>证明：第一部分是显然的；为了证明第二部分，我们直接利用换元公式：<br><br>命题成立。<br><br>Theorem (Gauss 函数的 Fourier 变换).
对任意的正数 ，我们有

<br>利⽤上⾯ Guass 函数的 Fourier 变换，我们可以证明关于 Fourier 逆变换的定理。<br>Definition.
对任意的 ，对任意的  我们定义

<br>Theorem (Fourier 逆变换).
给定 ，如果 ，那么，我们有

其中，上面等号成立是在  的意义下的。
<br><br>注意到,  是稠密的子空间。我们任意选取 , 很明显,  (因为光滑性意味着衰减很快, 所以可积)。另外, 我们有<br><br>所以，我们有<br><br>从而,<br><br>这表明定义在  是稠密的子空间  上的 Fourier 变换<br><br>是连续的。<br>
<img alt="Fourier分析初步-2025050219.png" src="lib\media\fourier分析初步-2025050219.png"><br>
根据连续线性映射扩张的定理，我们就证明了<br>Theorem (定理 4.55 ( 上的 Fourier 变换与 Planchrel 公式)).
我们可以定义 Fourier 变换 :

使得

是等距同构。特别地，对于 ，我们有

通过极化，我们有对任意的 ，我们有

<br>Proof.<br>
上述一切叙述对  是成立的。对一般的 ，用  中函数逼近即可。<br>
□<br>Remark.
上面的定理定义了  的Fourier变换，为了行文清楚，我们暂且把  意义下的Fourier变换记作 . 另外，对于 , 它的Fourier变换是可以用Fourier积分表示的，我们把它记做 , 也就是说

那么，对于, 我们有

<br>Example.
 考虑  上的  －函数

其中， 。很明显，我们知道  ，所以我们不能直接用 －函数的 Fourier 积分来写它的 Fourier 变换。然而，我们知道

是  的，我们可以先显式写下  的 Fourier 变换。由于序列  在  中逼近  ，所谓，我们有

<br><br><br>对任意的给定的函数  ，对任意的多重指标  ，我们采用如下的符号：<br><br>Definition (Schwartz 空间，Schwarz 函数（速降函数）).
函数  是  上的光滑函数。如果  满足如下的条件：对任意的多重指标  ，我们都有

那么，我们就称  是一个 Schwartz 函数 或者是一个 速降的函数。我们把  上所有的 Schwartz 函数所构成的线性空间称作是 Schwartz 空间，并记作  。
对于每个非负整数  ，我们定义如下的（一族）范数：

在  上，我们规定如下的收敛性（拓扑）：给定 Schwartz 函数的序列  ，它收敛到 Schwartz 函数  ，指的是对任意的非负整数  ，我们都有

我们把这个极限简写成

<br>Example.
我们已经见过很多 Schwartz 函数

<br>；
<br>；
<br>对于 Schwartz 函数 ，对它求若干次导数或者乘以一个多项式仍然是一个 Schwartz函数，即对任意的多重指标 ，我们有

上面例子的验证我们留作作业。

<br>给定一个 Schwarz 函数，我们对它有如下的估计：对于任何的多重指标  和 ，其中 ，我们有<br><br>其中， 是空间的维数。<br>从而，对任意的 ，我们有<br><br>上式右边的函数是可积的，所以，<br><br>特别地，我们可以对  用傅里叶积分来定义其傅里叶变换。作为推论，我们还知道<br><br>另外，以上的估计是常用的技巧，在后面的不少场合都会用到。<br>Theorem.
 在  中是稠密的，即对任意的  ，存在函数序列  ，使得

<br>
 意味着对于任意非负整数 ，有 .
<br>
光滑函数乘以一个函数，结果仍为光滑函数，当且仅当另一个函数也是光滑函数.
<br>Proof.<br>
我们选取有紧支集的光滑函数 ，使得<br><br>对于 ，我们令<br><br>我们只要证明，对任意的非负整数 ，我们有<br><br>即可。对于满足  的多重指标，我们有<br><br>上式的第二个求和部分有  这样的衰减因子，所以极限为 0。对于第一项，由于  在半径为 1 的球内部为 1，所以然而，我们有<br><br>这就完成了证明。<br>
□<br><br>Theorem ( 上的 Fourier 变换).
如果  是 Schwartz 函数，那么， 。在 Schwartz 函数空间上的 Fourier 变换：

满足如下的性质：对任意的  ，存在常数  ，使得对每个  ，我们都有

特别的，  是连续的线性同构，即对任意的在  中收敛的函数序列

我们有

另外，对任意的  ，我们还有公式

<br>Proof.<br>
我们首先证明叙述中的最后两个恒等式。对任意的 Schwartz 函数  ，对任意的  ，利用分部积分，我们有<br><br>第二个等式要用 Lebesgue 控制收敛的推论（积分与求导数可交换），我们有<br><br>现在证明定理中的不等式（从而证明了 Fourier 变换  的像也落在  中）。固定两个多重指标  和  ，其中  。利用已经证明的公式，我们就有<br><br>Fourier 变换的连续性可以通过这个不等式得到：对任意给定  ，我们有<br><br>按照定义，我们就有<br><br>最后，我们来说明  是同构。实际上，我们可以定义直接考虑 Fourier 变换的逆  ，因为  ，所以之前定义的  在此也是良好定义的。此时，我们已经证明了  与  互为逆映射，所以命题得证（  也是连续的）。<br>
□<br><br>Definition (缓增的分布).
假设  是一个分布。如果存在非负整数  和常数 ，使得对每个 ，我们都有

我们就说  是一个缓增的分布。我们用  来表示所有缓增分布的集合，很明显

是线性子空间。
]]></description><link>偏微分方程\fourier分析初步.html</link><guid isPermaLink="false">偏微分方程/Fourier分析初步.md</guid><pubDate>Sat, 03 May 2025 16:31:13 GMT</pubDate><enclosure url="lib\media\fourier分析初步-2025050219.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\fourier分析初步-2025050219.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Functional-Analysis]]></title><description><![CDATA[ 
 <br><br><br>Let  be a domain. The Sobolev spaces we will use most are: the Hilbert space<br><br>(all derivatives are meant in distributional sense) with the inner product<br><br>Theorem.
证明 .<a data-footref="[inline0" href="about:blank#fn-1-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a>
<br>Proof.<br>
设 。我们需要证明  在  上连续。由于 , 则  且  (弱导数) 。<br>根据Sobolev嵌入定理，如果  是一个有界开集，且  足够光滑，那么当  时，。<br>在我们的例子中，，所以 。我们有 ，因此  且 。因为 , Sobolev嵌入定理告诉我们 。<br>这意味着存在一个连续函数  使得  几乎处处成立。由于我们通常将  中的元素视为等价类（即，如果两个函数在Lebesgue测度意义下相等，则认为它们是等价的），我们可以选取这个连续的代表  作为 。<br>因此， 在  上有一个连续的代表，这意味着 。<br>□<br>Theorem (finit-dimensional space).
Let  be a normed linear space (over  or ). Then  is finite-dimensional if and only if its closed unit ball is compact.
<br><br><img alt="4-Functional-Analysis-2025051409.png" src="lib\media\4-functional-analysis-2025051409.png"><br><br>Imagine you have:<br>
<br>
A special kind of "space" where you can measure distances and angles (this is the Hilbert space, ).

<br>
A rule that takes any two items from this space and gives you a number. This rule needs to be "nice" in two ways:

<br>It doesn't blow up: The number you get isn't excessively large compared to the "size" of the two items (this is boundedness).
<br>It's "positive" in a strong way: When you use the rule with the same item twice, the number you get is significantly positive and related to the "size" of that item squared (this is coercivity). This rule is your bilinear form, .


<br>
Another rule that takes any one item from your space and gives you a number, and this rule is also "nice" (it doesn't blow up) (this is your bounded linear functional, ).

<br>The Lax-Milgram Theorem then says:<br>If your "combining rule" () is "nice" (bounded and coercive), then for any "measuring rule" () you pick, you can always find one and only one special item () in your space such that:<br>When you combine this special item () with any other item () using your rule , you get the exact same number as when you measure that other item () using your rule .<br>In short:<br>Under certain "good behavior" conditions for how you combine and measure things in a special space, a specific type of equation () is guaranteed to have exactly one solution () in that space.<br>Why it matters (the even simpler version):<br>It's a powerful math tool that tells us that certain types of problems (often coming from physics and engineering, like how heat spreads or structures bend) definitely have a unique answer, as long as the problem is "well-behaved" in a specific mathematical sense.<br><br>The Big Idea: Does My Problem Even Have an Answer?<br>Imagine you're an engineer or a scientist. You've written down a mathematical equation (often a "partial differential equation" or PDE) that you believe describes a real-world situation. Before you spend a lot of time (and computer power) trying to find the answer, you'd want to know:<br>
<br>Does an answer even exist?
<br>If it exists, is there only one unique answer? (If there are many, which one is the "right" one for your physical situation?)
<br>This is where the Lax-Milgram theorem comes in. It's a powerful mathematical tool that can answer "YES!" to both questions for a specific class of problems.<br>How it Works (Simplified):<br>
<br>Hard Problem: The original PDE is often tricky to solve directly.
<br>Easier Version (Weak Formulation): Mathematicians have a way to rephrase the hard problem into an "easier" (though still abstract) form. This easier form is an equation that looks like .
<br>Lax-Milgram's Job: If the parts of this "easier" equation ( and ) satisfy certain "good behavior" conditions (boundedness and coercivity), the Lax-Milgram theorem guarantees that there's exactly one solution  to this easier version.
<br>Good News: This "weak solution" to the easier version is often good enough for practical purposes and, in many cases, can be shown to be the actual solution to the original hard problem.
<br>Why is this "guarantee" important?<br>
<br>For Scientists/Engineers: It tells them their mathematical model of the physical world is well-posed (meaning it has a unique solution). This gives them confidence that their model makes sense.
<br>For Computer Simulations: Many complex engineering and science problems are solved using computer simulations (e.g., Finite Element Method - FEM). These methods essentially try to find an approximate solution to the "easier" weak formulation. The Lax-Milgram theorem provides the theoretical backbone, assuring us that the problem these numerical methods are trying to solve actually has a unique solution to begin with. Without this, the computer might be chasing a ghost!
<br>So, while you might not use the Lax-Milgram theorem directly in everyday calculations, it's a crucial piece of foundational mathematics that makes a lot of advanced engineering analysis and scientific computation possible and reliable. It gives a green light for many solution-seeking processes.<br><br><img alt="Functional-Analysis-2025051409.png" src="lib\media\functional-analysis-2025051409.png"><br>
<img alt="1-Functional-Analysis-2025051409.png" src="lib\media\1-functional-analysis-2025051409.png"><br>
<img alt="2-Functional-Analysis-2025051409.png" src="lib\media\2-functional-analysis-2025051409.png"><br>
<img alt="3-Functional-Analysis-2025051409.png" src="lib\media\3-functional-analysis-2025051409.png"><br><br>Exercise (非线性算子的连续性；紧性).
<img alt="Functional-Analysis-2025051312.png" src="lib\media\functional-analysis-2025051312.png">
<br>一个关键的定理是：对于线性算子 ，以下说法是等价的：<br>
<br> 在  上是连续的。
<br> 在  中的某一点  处是连续的。
<br> 在原点  处是连续的。
<br> 是有界的 (Bounded)。这是最常用和最重要的等价条件。 
<br>有界线性算子的定义：<br>线性算子  称为有界的，如果存在一个常数 , 使得对于所有的  ,都有：<br>
这个常数  称为算子  的一个界。最小的这样的  称为算子  的范数，记为 。<br><br>我们可以证明：对于任意的 , <br><br>故  良定义. 接下来直接验证连续性：对于 ,<br><br>若 , 那么 . 故  连续.<br>接下来验证紧性<br>
<img alt="1-Functional-Analysis-2025051312.png" src="lib\media\1-functional-analysis-2025051312.png"><br>Exercise.
<img alt="2-Functional-Analysis-2025051312.png" src="lib\media\2-functional-analysis-2025051312.png">
<br>
If any subsequence of a sequence converges to , then the sequence converges to . (Proved by limsup and liminf)
<br><img alt="5-Functional-Analysis-2025051312.png" src="lib\media\5-functional-analysis-2025051312.png"><br><img alt="3-Functional-Analysis-2025051312.png" src="lib\media\3-functional-analysis-2025051312.png"><br>
<img alt="4-Functional-Analysis-2025051312.png" src="lib\media\4-functional-analysis-2025051312.png"><br>Exercise (yau-22-problem 4).
Problem 4. Let  be the space of all continuous  -valued functions equipped with  -norm. Let  be a closed linear subspace. Assume that the elements of  are polynomials. Prove that .
<br>Main Idea:<br>The core strategy is to demonstrate that the closed unit ball in the subspace  is compact. A fundamental theorem in functional analysis states that a normed linear space is finite-dimensional if and only if its closed unit ball is compact. By proving the compactness of the unit ball of , the proof concludes that  must be finite-dimensional.<br>Sketch of the Proof (Logical Flow):<br>
<br>
Problem Setup: We have a closed linear subspace  of  (continuous functions on  with -norm), and all elements of  are polynomials. We want to prove .

<br>
Introduce Slope Operators:

<br>Define a family of linear operators  (where  is the complex numbers) for distinct :<br>

<br>This is essentially the slope of the polynomial  between  and .


<br>
Show Pointwise Boundedness of these Operators:

<br>For any fixed polynomial , its derivative  is continuous on  and thus bounded (i.e., ).
<br>By the Mean Value Theorem,  for some  between  and .
<br>This means for each , the set  is bounded.


<br>
Apply Banach-Steinhaus Theorem (Uniform Boundedness Principle):

<br> is a closed subspace of a Banach space (), so  itself is a Banach space.
<br>Since the family of continuous linear operators  is pointwise bounded on the Banach space , the Banach-Steinhaus Theorem implies that their operator norms are uniformly bounded.
<br>So, there exists a constant  such that  for all .


<br>
Establish Equicontinuity of the Unit Ball of P:

<br>Consider the unit ball .
<br>For any :<br>

<br>This implies  for all .
<br>This is the definition of uniform Lipschitz continuity for the functions in , which in turn implies that the family  is equicontinuous.


<br>
Apply Arzelà-Ascoli Theorem:

<br>The unit ball  is defined on the compact set .
<br> is equicontinuous (from step 5).
<br> is uniformly bounded (since for , , meaning  for all ).
<br>The Arzelà-Ascoli Theorem states that a family of functions that is equicontinuous and pointwise (or uniformly) bounded on a compact set is relatively compact. Since  is also closed (it's a closed unit ball), it is compact.


<br>
Conclude Finite Dimensionality:

<br>A normed linear space is finite-dimensional if and only if its closed unit ball is compact.
<br>Since the closed unit ball  of  has been shown to be compact,  must be finite-dimensional.


<br>In essence, the proof cleverly uses the properties of polynomials (differentiability) to construct a family of operators. The Banach-Steinhaus theorem then provides a crucial uniform bound. This bound leads to the equicontinuity of the unit ball, which, combined with its boundedness, allows the Arzelà-Ascoli theorem to establish its compactness, ultimately proving finite dimensionality.<br>
<br>
<br>This is false in dimension .<a href="about:blank#fnref-1-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>偏微分方程\functional-analysis.html</link><guid isPermaLink="false">偏微分方程/Functional-Analysis.md</guid><pubDate>Wed, 14 May 2025 04:34:06 GMT</pubDate><enclosure url="lib\media\4-functional-analysis-2025051409.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\4-functional-analysis-2025051409.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[fundamental-solution]]></title><description><![CDATA[ 
 <br><br>Okay, let's deduce the fundamental solution of the Laplacian more intuitively. The fundamental solution  is defined as the solution to the equation:<br><br>where  is the Laplacian operator and  is the Dirac delta function, representing a point source at the origin. The previous proof concerning the harmonic function  in  used the representation:<br><br>This implies that the fundamental solution satisfying  is  in . Let's see how we can arrive at this.<br><br>This approach is very physical and geometric, especially for an operator like the Laplacian.<br>a. Radial Symmetry:<br>The Dirac delta function  is a point source at the origin. It's spherically symmetric (its value depends only on whether ). We can expect the potential  generated by this point source to also be spherically symmetric. Thus,  should depend only on the distance  from the origin:<br><br>b. Laplacian in Spherical Coordinates:<br>For a radially symmetric function  in , the Laplacian is:<br><br>In  (which is the context of the original problem), , so:<br><br>c. Solution Away from the Origin ():<br>Away from the origin (, so ), the Dirac delta is zero, . So, we must have .<br><br>This implies that  must be a constant, let's call it :<br><br>So,<br><br>Integrating with respect to  gives:<br><br>where  is another constant. For potentials that vanish at infinity (which is a common physical condition, and matches  in the problem), we typically set . So, .<br>d. Determining the Constant A (using the source):<br>To find , we use the defining equation . Integrate both sides over a small ball  of radius  centered at the origin:<br><br>The right side, by definition of the Dirac delta, is .<br>
For the left side, we use the Divergence Theorem (Gauss's Law):<br><br>where  is the sphere of radius , and  is the outward unit normal vector.<br>
Since , its gradient is , where  is the radial unit vector. The outward normal  on the sphere is also .<br>
So, . At , this is .<br>
The surface area of the sphere  in  is .<br>
So the surface integral becomes:<br><br>Equating this to the integral of the Dirac delta:<br><br>Substituting this back into :<br><br>Thus, the fundamental solution in  is:<br><br>This is precisely the kernel that appeared in the integral representation for  in the problem you referenced.<br>Intuition from Flux Spreading:<br>Imagine a "flux" emanating from the point source at the origin.<br>
<br>
The term  (which is  in ) can be thought of as proportional to the total flux of  through a sphere of radius .

<br>
The condition  for  means this flux is constant for any .

<br>
The strength of the field (gradient)  must therefore decrease as  to keep the flux constant, because the surface area of the sphere is proportional to .

<br>In , surface area , so field . Potential .
<br>In , surface area (circumference) , so field . Potential .


<br>
The constant value of this flux is determined by the strength of the source , which is  when integrated. This directly gives the constant .

<br><br>This method is more algebraic and general for constant-coefficient linear PDEs.<br>Let  be the Fourier transform.<br>
The equation is .<br>
Taking the Fourier transform of both sides:<br><br>
<br>FT of Dirac Delta: .
<br>FT of Laplacian: The Fourier transform of  is .<br>
So, .
<br>Putting these together, the equation in Fourier space becomes:<br><br>So, the Fourier transform of the fundamental solution is:<br><br>Now, we need to find the inverse Fourier transform :<br><br>This integral needs to be computed.<br>For  (as in the problem):<br><br>To evaluate this, we can use spherical coordinates for . Let . By rotating coordinates, we can align  with the -axis, so , and , where  is the angle between  and . The volume element is  (where  is the azimuthal angle for ).<br><br>The inner integral is <br><br>So,<br><br>Let , then . The integral becomes <br><br>This is the Dirichlet integral, which evaluates to .<br><br>This matches the result from the radial symmetry method.<br>Intuition from Fourier Transform:<br>
<br>The Laplacian  acts as a multiplication by  in Fourier space. It heavily attenuates high frequencies.
<br>The Dirac delta  has a flat spectrum (all frequencies equally present: ).
<br> means the fundamental solution has a spectrum that decays fairly slowly for small  (it's singular at ) and faster for large . This  behavior in Fourier space is characteristic of  type potentials in real space for 3D. The singularity at  in  hints at the long-range nature of the potential .
<br>Both methods yield the same result. The radial symmetry/Gauss's law approach is often more physically intuitive for the Laplacian, while the Fourier transform method is a very powerful and general algebraic tool applicable to a wider range of constant-coefficient linear differential operators.<br><br><br>The fundamental solution  for the Laplace equation satisfies<br><br>where  is the Laplacian operator.<br>
<br>Fourier Transform:
<br>Applying the Fourier transform with respect to  to both sides:<br><br>We know that . For the left side, the derivative property of Fourier transforms gives . Thus, .<br>
So, .<br>
The transformed equation is:<br><br>Solving for :<br><br>
<br>Inverse Fourier Transform:
<br>Now we need to compute the inverse Fourier transform:<br><br>
<br>Case :
<br>We use the Schwinger parametrization . Here :<br><br>Substituting this into the integral for :<br><br>Assuming we can interchange the order of integration:<br><br>The inner integral is an -dimensional Gaussian integral. The exponent is .<br>
Completing the square for each component  : .<br><br>Since , the -dimensional integral is .<br>
Substituting this back:<br><br>Let . Then , so .<br>
The integral becomes (for , so  for convergence of  ):<br><br>So, for  :<br><br>For example, if , .<br>
<br>Case :
<br>The above derivation for the -integral requires , so it doesn't directly apply to . The direct Fourier inversion of  in 2D is subtle. The known result is:<br><br>This can be verified by showing  in the distributional sense.<br>
<br>Case :
<br>Similarly, for . Direct inversion is subtle. The known result is:<br><br>This satisfies .<br><br><br>The fundamental solution (or heat kernel)  satisfies the homogeneous heat equation with a Dirac delta initial condition:<br><br><br>where  is the thermal diffusivity.<br>
<br>Spatial Fourier Transform:
<br>Let . Applying the Fourier transform to the PDE:<br><br><br>The initial condition transforms to .<br>
<br>Solve the ODE in Time:
<br>This is a first-order ODE for  with respect to :<br><br>Using the initial condition , we find . So, for  :<br><br>
<br>Inverse Spatial Fourier Transform:

The exponent is .<br>
We complete the square for each component  :

The integral becomes:

Each 1D Gaussian integral is .<br>
Therefore:



<br><br><br>The fundamental solution  for the wave equation satisfies:<br><br>where  is the wave speed. We seek the retarded Green's function, satisfying  for .<br>
<br>Space-Time Fourier Transform:
<br>Let .<br><br><br><br>The transformed equation is:<br><br><br>
<br>Inverse Fourier Transform with respect to  (Time):

Let . The integral is .<br>
The poles are at . For the retarded Green's function, this integral evaluates to:

where  is the Heaviside step function. This ensures  for .
<br>Definition (Heaviside step function).
The Heaviside step function is defined by

<br>
<br>Inverse Fourier Transform with respect to  (Space):

The evaluation of this integral depends heavily on the dimension .
<br>
<br>
For :

The integral  if , and  if . Here .

This means  for  and , and  otherwise.

<br>
For :

The integral evaluates to .


<br>
For :

The integral can be evaluated using spherical coordinates. Let .


This can also be written as .

<br>These derivations show how Fourier transforms can be systematically used to find fundamental solutions. The main challenge often lies in evaluating the resulting inverse Fourier transform integrals, which can be quite involved depending on the dimension and the complexity of the function in Fourier space.]]></description><link>偏微分方程\fundamental-solution.html</link><guid isPermaLink="false">偏微分方程/fundamental-solution.md</guid><pubDate>Wed, 14 May 2025 07:35:34 GMT</pubDate></item><item><title><![CDATA[heat-and-Schrodinger-equation]]></title><description><![CDATA[ 
 <br><img alt="Evans Chap5-20250224.png" src="lib\media\evans-chap5-20250224.png"><br>
The irreversibility of its semiflow and the need to impose a growth condition as  in order to pick out a unique solution.<br><br>The finite-dimensional phase sapce of the ODE is replaced by the infinite-dimensional function space ; then we think of a solution of the heat equation as a parametrized curve in the vector space . <br><br><img alt="1-Evans Chap5-20250224.png" src="lib\media\1-evans-chap5-20250224.png"><br>
<img alt="Evans Chap5-20250225.png" src="lib\media\evans-chap5-20250225.png"><br><br><img alt="1-Evans Chap5-20250225.png" src="lib\media\1-evans-chap5-20250225.png"><br>
<img alt="2-Evans Chap5-20250225.png" src="lib\media\2-evans-chap5-20250225.png"><br>
<img alt="3-Evans Chap5-20250225.png" src="lib\media\3-evans-chap5-20250225.png"><br>
<img alt="4-Evans Chap5-20250225.png" src="lib\media\4-evans-chap5-20250225.png"><br><br><img alt="6-Evans Chap5-20250225.png" src="lib\media\6-evans-chap5-20250225.png"><br>
<img alt="5-Evans Chap5-20250225.png" src="lib\media\5-evans-chap5-20250225.png"><br><br><img alt="7-Evans Chap5-20250225.png" src="lib\media\7-evans-chap5-20250225.png"><br><br><img alt="8-Evans Chap5-20250225.png" src="lib\media\8-evans-chap5-20250225.png"><br>
<img alt="9-Evans Chap5-20250225.png" src="lib\media\9-evans-chap5-20250225.png"><br><br><img alt="10-Evans Chap5-20250225.png" src="lib\media\10-evans-chap5-20250225.png"><br><br><img alt="11-Evans Chap5-20250225.png" src="lib\media\11-evans-chap5-20250225.png"><br>
<img alt="13-Evans Chap5-20250225.png" src="lib\media\13-evans-chap5-20250225.png"><br>
<img alt="12-Evans Chap5-20250225.png" src="lib\media\12-evans-chap5-20250225.png"><br>Note
Formally, the Schrodinger equation is obtained by the transformation  of the heat equation to 'imaginary time.' The analytical properties of the heat and Schr¨odinger equations are, however, completely different and it is interesting to compare them.
<br><br><img alt="14-Evans Chap5-20250225.png" src="lib\media\14-evans-chap5-20250225.png"><br>
<img alt="15-Evans Chap5-20250225.png" src="lib\media\15-evans-chap5-20250225.png"><br><br><img alt="16-Evans Chap5-20250225.png" src="lib\media\16-evans-chap5-20250225.png">]]></description><link>偏微分方程\heat-and-schrodinger-equation.html</link><guid isPermaLink="false">偏微分方程/heat-and-Schrodinger-equation.md</guid><pubDate>Fri, 02 May 2025 08:58:52 GMT</pubDate><enclosure url="lib\media\evans-chap5-20250224.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\evans-chap5-20250224.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Hyperbolic-equations]]></title><description><![CDATA[ 
 <br>The prototypical example of a hyperbolic PDE is the wave equation<br><br>To begin with, consider the one-dimensional wave equation on <br><br>The general solution is the d'Alembert solution<br><br>where ,  are arbitrary functions. This solution describes a superposition of two traveling waves with arbitrary profiles, one propagating with speed one to the right, the other with speed one to the left.<br>
Let us compare this solution with the general solution of the one-dimensional heat equation<br><br>which is given for  by<br><br>Some of the qualitative properties of the wave equation that differ from those of the heat equaion, which are evident from these solutions.<br><img alt="Hyperbolic equations-20250312-005414.png" src="lib\media\hyperbolic-equations-20250312-005414.png"><br>To obtain the basic energy estimatie for the wave equation, we multiple <a data-href="#^4f0e56" href="about:blank#^4f0e56" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^4f0e56</a><a data-href="#^4f0e56" href="about:blank#^4f0e56" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a> ny  and write <br><br>to get<br><br>This is the differential form of conservation of energy. The quantity  is the energy density and  is the energy flux.<br><img alt="Hyperbolic equations-20250312.png" src="lib\media\hyperbolic-equations-20250312.png">]]></description><link>偏微分方程\hyperbolic-equations.html</link><guid isPermaLink="false">偏微分方程/Hyperbolic-equations.md</guid><pubDate>Fri, 02 May 2025 08:58:52 GMT</pubDate><enclosure url="lib\media\hyperbolic-equations-20250312-005414.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hyperbolic-equations-20250312-005414.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Laplace]]></title><description><![CDATA[ 
 <br><br>见 Evans 偏微分方程笔记<br>Remark.
这里很多证明都非常符合正常人的思考过程，其中还用到了经典的分析学思想， 中既开又闭的集合平凡。非常不错。
<br>解题参见 Partial Differential Equations in Action, Complements and Exercises]]></description><link>偏微分方程\laplace.html</link><guid isPermaLink="false">偏微分方程/Laplace.md</guid><pubDate>Sat, 03 May 2025 09:39:07 GMT</pubDate></item><item><title><![CDATA[Parabolic-equations]]></title><description><![CDATA[ 
 <br><br>Some results about the integration and differentiation of Banach-space valued functions of a single variable.<br>
Vector-valued integrals of integrable functions have similar properties, often with similar proofs, to scalar-valued  -integrals.<br>
The existence of different topologies (such as the weak and strong topologies) in the range space of integrals that take values in an infinite-dimensional Banach space introduces significant new issues that do not arise in the scalar-valued case.<br>Suppose  a real Banach space with  and dual space .<br><br><br>Definition.
<img alt="Parabolic equations-20250306.png" src="lib\media\parabolic-equations-20250306.png">
<br>Definition (strongly measurable).
<img alt="1-Parabolic equations-20250306.png" src="lib\media\1-parabolic-equations-20250306.png">
<br>Measurability is preserved under natural operations on functions.<br><img alt="2-Parabolic equations-20250306.png" src="lib\media\2-parabolic-equations-20250306.png"><br>Definition (weakly measurable).
A function  is said to be weakly measurable if the real-valued function  is measurable for every .
<br>This amounts to a 'coordinatewise' defintion of measurablility, in which we represent a vector-valued function by its ral-valued coordinate functions.<br>
For finite-dimensional, or separable, Banach spaces these definitions coincide, but for non-separable sapces a weakly measurable function need not be strongly measurable.<br>
The relationship between weak and strong measurability is given by the following Pettis theorem.<br>Definition (almost separably valued).
<img alt="4-Parabolic equations-20250306.png" src="lib\media\4-parabolic-equations-20250306.png">
<br>Theorem (Pettis theorem).
A function  is strongly measurable iff it is weakly measurable and almost separably valued.
<br>Definition (weak continuous).
<img alt="5-Parabolic equations-20250306.png" src="lib\media\5-parabolic-equations-20250306.png">
<br>Since a continuous function is measurable, every almost separably valued, weakly continuous function is strongly measurable.<br>Example (weak but not strong measurable).
<img alt="Parabolic equations-20250306-154640.png" src="lib\media\parabolic-equations-20250306-154640.png">
<br>Example ( separable but  not).
 <img alt="Parabolic equations-20250306-154653.png" src="lib\media\parabolic-equations-20250306-154653.png">
<br><br>The definition of the Lebesgue integral as a supremum of integrals of simple functions does not extend directly to vector-valued integrals because it uses the ordering properties of  in and essential way.<br>One can use duality to define  -valued integrals  in terms of the corresponding real-valued integrals  where , but we will not consider such weak definitions of an integral here.<br>Instead, we define the integral of vector-valued functions by completing the space of simple functinos with respect to the  -norm. The resulting integral is called the Bochner integral, and its properties are similar to those of the Lebesgue integral of integrable real-valued functions.<br>Definition (simple function).
<img alt="Parabolic equations-20250306-155025.png" src="lib\media\parabolic-equations-20250306-155025.png">
<br>Definition (Bochner integral).
<img alt="Parabolic equations-20250306-154834.png" src="lib\media\parabolic-equations-20250306-154834.png">
<br>The value of the Bochner integral of  is independent of the sequence  of approximating simple functions, and<br><br>Moreover, if  is a bounded linear operator between Banach spaces  and  is integrable, then  is integrable and<br><br>More generally, this equality holds whenever  is a closed linear operator and , in which case .<br>Definition (closed linear operater).
<img alt="Parabolic equations-20250306-155321.png" src="lib\media\parabolic-equations-20250306-155321.png">
<br>Example ( as an operator).
<img alt="Parabolic equations-20250306-155441.png" src="lib\media\parabolic-equations-20250306-155441.png">
<br>Theorem.
<img alt="Parabolic equations-20250306-155608.png" src="lib\media\parabolic-equations-20250306-155608.png">
<br>The DCT for Bochner integrals with proof same as the scalar-valued case omitted.<br>Theorem.
<img alt="Parabolic equations-20250306-155856.png" src="lib\media\parabolic-equations-20250306-155856.png">
<br>The definition and properties of  -spaces of  -valued functions are analogous to the case of real-valued functions.<br>Definition ().
<img alt="Parabolic equations-20250306-160128.png" src="lib\media\parabolic-equations-20250306-160128.png">
<br>As usual, functions equal pointwise a.e. are regarded equivalent.<br>Theorem.
If  is a Banach space and  then  is a Banach space.
<br>Simple functions of the form  are dense in . By mollifying these functions with respect to , we get the following density result.<br>Theorem.
<img alt="Parabolic equations-20250306-160610.png" src="lib\media\parabolic-equations-20250306-160610.png">
<br>Theorem.
<img alt="Parabolic equations-20250306-160834.png" src="lib\media\parabolic-equations-20250306-160834.png">
<br>The proof is more complicated than in the scalar case and some condition on  is required. Reflexivity is sufficient.<br><br>Definition (strong continuous and strong differentiable).
<img alt="Parabolic equations-20250306-161157.png" src="lib\media\parabolic-equations-20250306-161157.png">
]]></description><link>偏微分方程\parabolic-equations.html</link><guid isPermaLink="false">偏微分方程/Parabolic-equations.md</guid><pubDate>Fri, 02 May 2025 08:58:52 GMT</pubDate><enclosure url="lib\media\parabolic-equations-20250306.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\parabolic-equations-20250306.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Poincare Inequality]]></title><description><![CDATA[ 
 <br><br>庞加莱不等式（Poincaré Inequality）通常叙述于有界区域上。对于整个  空间，标准形式的庞加莱不等式（即 ）通常不成立，除非对函数  施加特定条件，例如具有紧支撑（compact support）或者属于特定的加权 Sobolev 空间。<br>一个在  上下文中最直接理解的庞加莱不等式版本是针对具有紧支撑的函数。我们将证明这个版本。<br>Theorem ( 上的庞加莱不等式 - 紧支撑函数版本).
设 ，即  是  上具有紧支撑的连续可微函数（也可以推广到 Sobolev 空间 ）。令  表示  的支撑集。则存在一个常数 ，使得<br>
其中常数  依赖于  的支撑集的大小（例如，其直径或包含该支撑集的某个立方体的边长）。
<br>为了简便，我们考虑  的情况。<br>
因为  具有紧支撑，所以存在一个足够大的开立方体 ，使得 。这意味着  在  的边界  上为零。立方体的边长为 。<br>对于任意 ，由于 （因为点  在  的边界上，而  在边界外为零），我们可以沿  方向使用微积分基本定理：<br>
取绝对值：<br>
由于积分区间  包含于 ，并且被积函数非负，我们可以扩大积分区间：<br>
现在，我们对  在立方体  上积分。首先固定 ，对  积分：<br>
令 。这是一个关于  的常数。<br>
所以，<br>
现在应用 Jensen 不等式（或 Hölder 不等式：，这里 ，）：<br>
对于 ，我们有<br>
由于 , 。<br>
所以，<br>
代回到关于  的积分不等式：<br>
现在，我们在  的其余维度上积分 (即对  积分)：<br>
这给出：<br>
由于 ，我们可以得到：<br>
因为 ，所以  在  之外为零， 也在  之外（几乎处处）为零。因此，积分可以扩展到整个 ：<br>
取  次根：<br>
这里的常数  是包含  支撑集的立方体的边长。更一般地，常数  可以取为  支撑集在某个方向上的最大长度，或者其直径。<br>重要说明：<br>
<br>常数的依赖性： 这个版本的庞加莱不等式的常数  依赖于函数  支撑集的大小。对于支撑集越来越大的函数序列，这个常数会趋于无穷，这与有界区域上的庞加莱不等式常数仅依赖于区域的几何性质不同。
<br>一般  情况： 如果不对  的行为（如紧支撑或在无穷远处衰减）做任何假设，标准形式的庞加莱不等式在  上是不成立的。例如，一个非零常数函数  的梯度为零，但其  范数为无穷大。
<br>相关不等式： 在  上，与函数及其梯度相关且不依赖于支撑集大小（或具有不同类型依赖）的更典型不等式是 Sobolev 不等式（例如 Gagliardo-Nirenberg-Sobolev 不等式），它通常将  空间嵌入到某个  空间中，其中  可能不等于 。
<br>上面证明的是在  上针对紧支撑函数最直接和常见的“庞加莱不等式”形式。]]></description><link>偏微分方程\poincare-inequality.html</link><guid isPermaLink="false">偏微分方程/Poincare-inequality.md</guid><pubDate>Wed, 14 May 2025 15:19:36 GMT</pubDate></item><item><title><![CDATA[Second-Order-Elliptic-Equations]]></title><description><![CDATA[ 
 <br><br>We will exploit two essentially distinct techniques:<br>
<br>Energy methods within Sobolev spaces ()
<br>Maximum principle methods ()
<br><br>We will in this chapter mostly study the boundary-value problem<br><br>where  is an open, bounded subset of , and  is the unknown, . <br><br>for given coefficient functions  ()<br>Definition (elliptic).
<img alt="Second-Order Elliptic Equations-20250319.png" src="lib\media\second-order-elliptic-equations-20250319.png">
<br>Ellipticity thus means that for each point , the symmetric  matrix  is positive definite, with smallest eigenvalue greater than or equal to .<br>An obvious example is , , , in which case the operateor  is . ]]></description><link>偏微分方程\second-order-elliptic-equations.html</link><guid isPermaLink="false">偏微分方程/Second-Order-Elliptic-Equations.md</guid><pubDate>Sat, 03 May 2025 17:05:45 GMT</pubDate><enclosure url="lib\media\second-order-elliptic-equations-20250319.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\second-order-elliptic-equations-20250319.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Sobolev-Spaces]]></title><description><![CDATA[ 
 <br>To apply ideas of functional analysis to glean information concerning PDF, theories of Sobolov spaces is developed, which is sometimes subtle and unmotivated but ultimately will prove extremely useful.<br><br> We defined the Hölder spaces and the supremum norm  and the  -Hölder seminorm of  to be <br><br>And the  -Hölder norm to be <br><br>The Hölder space  consists of all functions  for which the norm<br><br>is finite. The space of functions  is a Banach space. (left as an exercise)<br><br>If  denotes a real linear space, then a mapping  is called a norm provided<br>
<br> for all .
<br> for all .
<br> if and only if .
<br>A norm provides us with a notion of convergence: we say a sequence  converges to , written , if . <br>A Banach space is then a normed linear space which is complete, i.e. within which each Cauchy sequence converges.<br><br>Hölder spaces is not often suitable. We want other spaces containing less smooth functions. In practice we must strike a balance. <br><br> denotes the space of infinitely differentiable functions  with compact support in .  is sometimes called a test function. We have<br><br>There are no boundary terms, since  has compact support in  and thus vanishes near . Then we define the weak derivative of . <br>Let  be a multiindex. Say that  is the  -weak partial derivative of , written , provided<br><br>
The weak derivative is well-defined. (it's unique.)<br>
<img alt="Sobolev Spaves-20250315.png" src="lib\media\sobolev-spaves-20250315.png">
<br><br><img alt="1-Sobolev Spaves-20250315.png" src="lib\media\1-sobolev-spaves-20250315.png"><br> is not strongly differentiable at  but weakly differentiable.<br><br>This is an example showing that the weak derivative does not always exists. <br>Let ,  and <br><br>We assert  does not exists in the weak sense. To check this, we must show that there does not exist any function  satisfying<br><br>for all . Suppose, to the contrary, <a data-href="#^8b128d" href="about:blank#^8b128d" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^8b128d</a><a data-href="#^8b128d" href="about:blank#^8b128d" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a>   were valid for some  and all . Then <br><br>Choose a sequence  of smooth functions satisfying<br><br>Replace  by  in <a data-href="#^d52d3e" href="about:blank#^d52d3e" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^d52d3e</a><a data-href="#^d52d3e" href="about:blank#^d52d3e" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (2)</a> and send , we discover<br><br>a contradiction.<br><br>Fix  and let  be a nonnegative integer. The Sobolev space  consists of all locally summable function  such that for each multiindex  with ,  exists in the weak sense and belongs to .<br>Remark.
If , we usually write .  is a Hilbert space. Note that .
<br>If , we define its norm to be<br><br>We write <br><br>to mean <br><br>for each .  意指  为紧集即有界闭集，  且 .<br><img alt="2-Sobolev Spaves-20250315.png" src="lib\media\2-sobolev-spaves-20250315.png"><br><br>The following example shows what condition the parameters should satisfy such that .<br><img alt="3-Sobolev Spaves-20250315.png" src="lib\media\3-sobolev-spaves-20250315.png"><br>
<img alt="4-Sobolev Spaves-20250315.png" src="lib\media\4-sobolev-spaves-20250315.png"><br><br>The following example illustrates a fundamental fact of life, that although a function  belonging to a Sobolev space possesses certain smoothness properties, it can be rather badly behaved in other ways.<br><img alt="5-Sobolev Spaves-20250315.png" src="lib\media\5-sobolev-spaves-20250315.png"><br><br>We verify some certain properties of weak derivatives, which is obvious for smooth functions but relies proof solely upon the defintion of weak derivatives.<br><img alt="6-Sobolev Spaves-20250315.png" src="lib\media\6-sobolev-spaves-20250315.png"><br>We prove the Leibniz's formula by induction on . Suppose first . Choose any . Then <br><br><img alt="7-Sobolev Spaves-20250315.png" src="lib\media\7-sobolev-spaves-20250315.png"><br><img alt="8-Sobolev Spaves-20250315.png" src="lib\media\8-sobolev-spaves-20250315.png"><br><img alt="9-Sobolev Spaves-20250315.png" src="lib\media\9-sobolev-spaves-20250315.png"><br>Check  in  by checking that  in  for all . <br><br><br>In order to study the deeper properties of Sobolev spaces, we therefore need to develop some systematic procedures fo rapproximating a function in a Sobolev space by smooth functinos.<br>Fix positive integer  and . .<br><img alt="10-Sobolev Spaves-20250315.png" src="lib\media\10-sobolev-spaves-20250315.png"><br>Claim that if  then<br><br><br>Next we show that we can find smooth functions which approximate in  and not just in . Notice that the smoothness of  is not neccessary.<br><img alt="11-Sobolev Spaves-20250315.png" src="lib\media\11-sobolev-spaves-20250315.png"><br>使用了单位分解的思想。<br><br><img alt="12-Sobolev Spaves-20250315.png" src="lib\media\12-sobolev-spaves-20250315.png"><br><br>见崔尚斌<br><img alt="13-Sobolev Spaves-20250315.png" src="lib\media\13-sobolev-spaves-20250315.png"><br><img alt="14-Sobolev Spaves-20250315.png" src="lib\media\14-sobolev-spaves-20250315.png"><br><br><img alt="Sobolev Spaces-20250315.png" src="lib\media\sobolev-spaces-20250315.png"><br>Theorem (Trace Theorem).
<img alt="2-Sobolev Spaces-20250315.png" src="lib\media\2-sobolev-spaces-20250315.png">
<br>Definition (trace).
We call  the trace of  on .
<br><img alt="3-Sobolev Spaces-20250315.png" src="lib\media\3-sobolev-spaces-20250315.png"><br><br>Sobolev 空间理论的核心部分是三个嵌入定理:<br>
<br>Sobolev 嵌入定理
<br>Morrey 嵌入定理
<br>Kondrachov-Rellich 嵌入定理
<br>Theorem.
<img alt="4-Sobolev Spaces-20250315.png" src="lib\media\4-sobolev-spaces-20250315.png">
<br>只需证明对于任意  都成立上述不等式，因为由此通过取极限便可以得到这个不等式对任意  也都成立，并进而得到包含关系 .<br>当  时，把  零延拓到  上便得到 ，这样对于任意满足  的 ，有<br><br>关于  在单位球面上积分，注意到 ，就得到<br><br>记 , . 由所设条件知道 , 进而 . 注意到<br><br>以及 , 应用推广的 Holder 不等式得<br><br>其中 . 因此<br><br>这里用到 . 选取  使得 ，则对任意  有<br><br>把  代入，得<br><br>注意到  ，便从（1．8．2）得到了（1．8．1）．证毕．<br>把 <a data-href="#^c2cf0d" href="about:blank#^c2cf0d" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^c2cf0d</a><a data-href="#^c2cf0d" href="about:blank#^c2cf0d" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 4</a> 应用到  的特殊情况，就有如下著名不等式<br>Theorem (Poincare 不等式).
对任意  和有界开集  成立不等式<br>

<br>把 <a data-href="#^c2cf0d" href="about:blank#^c2cf0d" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^c2cf0d</a><a data-href="#^c2cf0d" href="about:blank#^c2cf0d" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 4</a> 应用到  的特殊情况，则有如下不等式<br>Corollary.
设 ，则对任意有界开集  有 ，且成立不等式<br>
其中 .
<br>Theorem.
<img alt="Sobolev Spaces-20250319.png" src="lib\media\sobolev-spaces-20250319.png">
<br>Remark.
我还是不大理解这个证明
<br><img alt="1-Sobolev Spaces-20250319.png" src="lib\media\1-sobolev-spaces-20250319.png"><br><a data-href="#^c2cf0d" href="about:blank#^c2cf0d" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^c2cf0d</a><a data-href="#^c2cf0d" href="about:blank#^c2cf0d" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 4</a> 和 <a data-href="#^63f437" href="about:blank#^63f437" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^63f437</a><a data-href="#^63f437" href="about:blank#^63f437" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 7</a>  说明，在关于  和  的一定条件下， 中的函数可以有比  大的某些幂次  的可积性，而且它们关于这些幂次  的  范数可以用其一阶弱导数的  范数界定。后一性质是  所特有的；当  时， 中的函数一般不具有这种性质，即  中函数的  范数一般不能被其一阶弱导数的  范数界定. 例如当  是有界开集时，非零的常值函数都属于 ；而对于这些函数，不等式  和  显然都不可能成立. 至于前一性质，则不是  中的函数所特有的，事实上  中的函数也具有类似的这种性质. 这一事实由以下定理所保证：<br>Theorem.
<img alt="4-Sobolev Spaces-20250319.png" src="lib\media\4-sobolev-spaces-20250319.png">
<br>反复使用 <a data-href="#^2bcff7" href="about:blank#^2bcff7" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^2bcff7</a><a data-href="#^2bcff7" href="about:blank#^2bcff7" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 9</a>  便可以得到<br>Theorem (Sobolev 嵌入定理).
<img alt="7-Sobolev Spaces-20250319.png" src="lib\media\7-sobolev-spaces-20250319.png"><br>
<img alt="8-Sobolev Spaces-20250319.png" src="lib\media\8-sobolev-spaces-20250319.png">
<br><img alt="10-Sobolev Spaces-20250319.png" src="lib\media\10-sobolev-spaces-20250319.png"><br><img alt="9-Sobolev Spaces-20250319.png" src="lib\media\9-sobolev-spaces-20250319.png"><br><br>本节介绍 Morrey 嵌入定理，它解释了 Sobolev 空间  到 Holder 空间  的嵌入关系。<br>Theorem.
<img alt="12-Sobolev Spaces-20250319.png" src="lib\media\12-sobolev-spaces-20250319.png">
<br>Proof.<br>
由于  是凸开集，所以其边界是 Lipschitz 连续的，进而  是可延拓开集. 因此根据定理 1.7.10 可知，只需证明上述不等式对任意  成立即可. 这时，由  的凸性可知对任意  有<br><br>关于  在  上积分并除以 ，得<br><br>令  表示把  的各个分量都作零延拓所得到的  上的向量函数，并记   ，则有<br><br>据此应用与定理 1.8.1 的证明类似的方法即可得到（1.9.1）．证毕．<br>□<br><br>Theorem (Holder 不等式).
<img alt="2-Sobolev Spaces-20250319.png" src="lib\media\2-sobolev-spaces-20250319.png"><br>
<img alt="3-Sobolev Spaces-20250319.png" src="lib\media\3-sobolev-spaces-20250319.png">
<br>Theorem (内插不等式).
<img alt="6-Sobolev Spaces-20250319.png" src="lib\media\6-sobolev-spaces-20250319.png">
]]></description><link>偏微分方程\sobolev-spaces.html</link><guid isPermaLink="false">偏微分方程/Sobolev-Spaces.md</guid><pubDate>Fri, 02 May 2025 08:58:52 GMT</pubDate><enclosure url="lib\media\sobolev-spaves-20250315.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\sobolev-spaves-20250315.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Sobolev空间基本性质]]></title><description><![CDATA[ 
 <br><br>参见于品数学分析讲义<br><br>在后面的课程中，我们会经常用所谓的 Planchrel 公式：对任意的  ，我们有<br><br>它的另外一个版本是说对任意的  ，我们有<br><br>这个公式我们之前已经证明过。<br>我们现在引入  上的 Sobolev 空间的定义。<br>Definition (指标为  的 Sobolev 空间).
给定 ，我们将把这个数称为是 Sobolev 空间的指标。我们考虑满足如下性质的缓增分布 ：

<br> 是局部可积的函数；
<br> 是平方可积的函数。

对于这样的函数，我们定义其 Sobolev 范数为：

我们把所有满足上述条件的缓增分布的集合称作是一个指标为  的 Sobolev 空间，这显然是一个复线性空间，我们用  来表示。<br>
在  上所赋予的范数与下面的内积是相容的：对任意的 ，令

所以， 是内积空间。
<br>我们注意到，当  时，我们  实际上就是  ，这由 Plancherel 公式立即就可以得到：<br><br>所以，<br><br>类似的，如果我们在频率空间  上考虑测度<br><br>那么， 当且仅当  。利用这个观察，我们现在证明：<br>Theorem.
对任意的  是 Hilbert 空间（即完备的内积空间）。
<br>Proof.<br>
假设  是 Cauchy 列，那么，根据定义， 是 Cauchy 列。利用  －空间的完备性，存在  作为上述序列的极限。我们用  表示它的 Fourier 逆变换，即<br><br>那么，<br><br>这就证明了完备性。<br>
□<br>根据Sobolev空间的定义，我们知道构成了一个下降的链，即对任意的<br><br>我们观察到，Schwartz 函数生活在所有的Sobolev空间中：<br><br>Proposition.
假设  为正整数，那么， 有如下的等价刻画：

<br>这个证明是初等的.<br><br>受到  的启发，我们定义算子 ，简记为 . 形式上， 对一个分布的作用在频率空间上看来就是乘以 .<br>Definition (Fourier 乘子).
给定频率空间上的函数 ，我们假设它是多项式增长的。对于任意的缓增分布 ，我们定义

由于  是多项式增长的，所以， 仍然是缓增分布，所以，如下的算子是良好定义的：

<br>Example.
我们先看几个简单的例子：

<br>
当  时，其中 ，我们有


<br>
当  时，我们有


<br>
给定线性微分算子

它可以被视作是一个 Fourier 乘子 ，其中


<br>
算子  表示的是函数  所对应的 Fourier 乘子。


<br>Example.
下面的Sobolev空间都定义在  上。

<br>对任意的，我们有

实际上，我们只要说明下面的积分有限即可：

这在时是成立的。同样的推理表明，当时，。
<br>常数值函数1不在任何的中。特别地，这表明



<br><br>Proposition (Sobolev 空间的映射性质).
给定多项式增长的乘子函数  ，其中，我们假设存在常数  和  ，使得对任意的  ，我们都有

那么，对任意的  ，对任意的  。这就定义出有界（连续）线性映射：

特别地，对任意的 －阶的微分算子  ，对任意的  ，我们有连续线性映射

另外，对任意的  ，我们还有连续的线性同构：

其中，上述映射的逆映射是  。
<br>Proof.<br>
对任意的  ，我们首先证明  ，其中  具有命题中所要求的多项式增长。根据 Planchrel 公式，我们有<br><br>所以，存在常数  ，使得<br><br>这表明  是从  到  的连续线性映射。<br>微分算子的情形是一个特例。为了说明  有逆，我们用<br><br>作为乘子即可，这是因为<br><br>命题得证。<br>
□<br><br>Proposition.
对每个指标 ，光滑有紧支集的函数  在  中是稠密的。
<br>Proof.<br>
我们首先证明  是稠密的，其中 ：这个论断对  是正确的，因为  在  中是稠密的。由于<br><br>是连续可逆的线性映射（是同胚）（因为 <a data-href="#^e86d38" href="about:blank#^e86d38" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^e86d38</a><a data-href="#^e86d38" href="about:blank#^e86d38" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Proposition 7 (Sobolev 空间的映射性质)</a> ），所以  在这个算子下的像也是稠密的，然而，<br><br>所以，  是稠密的。<br>
在上面的论证中， 不一定把有紧支集的函数映射为有紧支集的函数，所以，我们的推理是对  进行的。
<br>为了证明命题，我们只要说明在  的意义下，  中的任意一个函数  都可以被  的函数逼近。我们上次证明了存在常数 ，使得对任意的 ，我们有不等式<br><br>所以，对任意的 ，我们先选取 ，使得<br><br>再利用  的稠密性，选取 ，使得<br><br>此时，我们有<br><br>这就证明了命题。<br>
□<br>
我们下⾯证明著名的 Sobolev 嵌⼊定理（的⼀种形式）：<br>Theorem (Sobolev 嵌入定理).
假设指标  ，那么，每个  都落在  中。进一步，我们有连续的线性嵌入

即存在  ，使得对任意  ，我们都有

进一步， 是连续函数（可以在它的代表类中选到一个连续函数）并且在无穷远处的极限为零，即 。
<br>Remark.
证明的想法比较简单：我们只要说明  是一个  函数即可，因为 Fourier 逆变换就把它还原成一个在  处衰减的连续函数，从而是  的函数。
<br>Proof.<br>
根据  ，我们知道<br><br>我们现在说明  被  所控制。根据  ，我们可以  写成两个平方可积的函数的乘积：<br><br>前一部分根据  所以是  的；后一部分根据  所以是  的。利用 Cauchy-Schwarz 不等式，我们有<br><br>所以，<br><br>连续性的部分是明显的，因为<br><br>证明完毕。<br>
□<br>Corollary.
假设 ，其中  为非负整数，那么，对任意的 ，我们都有 。
<br>Proof.<br>
对任意的多重指标 ，如果 ，那么  是连续函数，从而， (用归纳法来证明会更严格一点)。<br>
□<br>Remark.
这个版本的 Sobolev 嵌入定理说的是，如果指标  足够大，那么，函数  就会非常光滑。
<br>Remark.
我们在作业中将构造函数局部可积的  ，使得  。换句话说，如下的嵌入并不成立：

这表明 Sobolev 嵌入的指标至少是  ，其中  可以任意小。
<br><br>下一个定理说的是如果指标  足够大，那么，两个  的函数的乘积也是  的。这个定理在证明非线性偏微分方程的解的局部存在性时很有用。<br>Theorem.
如果  ，那么， 是一个代数，即对任意的  ，我们有  

实际上，存在常数  ，使得对任意的  ，我们有

<br>
 Sobolev 不等式的⼀个重要的观点就是⽤函数以及它的导数的积分来控制函数的最⼤值.
<br>Proof.<br>
我们来计算  的 －范数。由于在 Fourier 变换下，乘积变化为卷积，所以按照定义，我们有<br><br>我们要把因子  进行拆分。首先，对任意的  ，我们显然有<br><br>所以，对任意的  ，我们有如下的不等式<br><br>所以，我们就得到了<br><br>上面的表达式中本质上是两项，它们的结构是类似的，我们只要处理一项就好。我们现在利用第一项中的卷积结构来控制它。根据  的定义，我们有<br><br>根据  ，我们在 Sobolev 不等式的证明中已经证明了  。特别地，存在常数  和  ，使得<br><br>我们观察到，上面就是控制  的  范数的大小。我们回忆上学期（5月 9 日的课程，利用 Fubini 定理）已经证明了<br><br>其中对任意的  ，我们有<br><br>我们对  和  运用这个不等式，就得到<br><br>□<br>实际上，我们还可以证明更强的结论：对任意的  是一个代数。我们之后将利用频率空间的二进分解进行证明。]]></description><link>偏微分方程\sobolev空间基本性质.html</link><guid isPermaLink="false">偏微分方程/Sobolev空间基本性质.md</guid><pubDate>Sat, 03 May 2025 16:53:38 GMT</pubDate></item><item><title><![CDATA[Yau contest]]></title><description><![CDATA[ 
 <br><br>Exercise.
<img alt="yau-contest-2025050319.png" src="lib\media\yau-contest-2025050319.png">
<br>算子的可逆性和它的范数有密切的关系。<br>一般来说，如果一个算子的范数“足够小”，那么“恒等算子+该算子”是可逆的。更具体地：<br>Theorem.
设  是巴拿赫空间  上的有界线性算子。如果 ，则算子  可逆，且<br>

<br>Theorem (Hölder's Inequality).
设 且 , 则对于任意函数  和 , 有, 且

<br>只需要证明 ：<br><br>Unsolved...]]></description><link>偏微分方程\yau-contest.html</link><guid isPermaLink="false">偏微分方程/yau-contest.md</guid><pubDate>Sun, 04 May 2025 15:32:10 GMT</pubDate><enclosure url="lib\media\yau-contest-2025050319.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\yau-contest-2025050319.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[函数空间]]></title><description><![CDATA[ 
 <br><br>参见《实变函数习题精选》徐森林<br>Remark.
当  时， in  与  互不蕴含. 当  时，前者蕴含后者.
<br>Theorem ( 空间包含关系).
设 ，且 ，则 ，且<br>

<br>Theorem ( 空间两边夹住).
设 ，则<br>
由此<br>
 
<br>Exercise (逐点收敛加上什么条件能推出  收敛).
设  在  上， . 证明： in .
<br>Proof.<br>
由于 . 于是逐点考虑<br><br>又因为 , , 故<br><br><br>注意到 ，由 Lebesgue 控制收敛定理可知<br><br>也就是<br><br>□<br>Exercise (有关 ).
设  且  ．证明：

<br>Proof.<br>
因为  ，故  ．于是<br><br>另一方面，对  ．<br><br>从而可得<br><br>又因  ，故  ，当  时，有<br><br>综上，当  时，有<br><br>因此<br><br>□<br>Exercise ( 空间的包含关系).
设 ，若  证明对于  有<br>

<br>
注意这里的包含关系和 <a data-href="#^50d515" href="about:blank#^50d515" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^50d515</a><a data-href="#^50d515" href="about:blank#^50d515" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 2 ( 空间包含关系)</a> 是相反的.
<br>Proof.<br>
先证明 . 反证而设 ，取  中无交可测子集列 ，s.t. . 作函数<br><br>易见<br><br><br>因此 . 这与  矛盾.<br>由于这个包含关系是反的，就会有一些神奇的性质，对于 ，<br><br>于是可以取  使得 ，再用 <a data-href="#^291fe9" href="about:blank#^291fe9" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^291fe9</a><a data-href="#^291fe9" href="about:blank#^291fe9" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 3 ( 空间两边夹住)</a>  得到 . 因此 . <br>
 事实上，利用 <a data-href="#^50d515" href="about:blank#^50d515" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^50d515</a><a data-href="#^50d515" href="about:blank#^50d515" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 2 ( 空间包含关系)</a> 可知这里 .
<br>□<br>Exercise (利用 Holder 不等式).
设 ，令<br>
证明：当  时，有 .
<br>Proof.<br>
对于 ，记 ，则 ，且<br><br>□<br><br>. 于是可以定义内积<br><br>定义  的夹角 (进而有垂直的概念)<br><br>Theorem ( 收敛蕴含弱收敛).
若  则 .
<br>Remark.
弱收敛不蕴含  收敛，也不蕴含几乎处处收敛，也不蕴含依测度收敛.
<br>设  是  中的规范正交系<a data-footref="[inline0" href="about:blank#fn-1-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a><a data-footref="[inline1" href="about:blank#fn-2-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[2]</a> 对于  定义  关于  的广义 Fourier 系数为<br><br>广义 Fourier 级数为<br><br><img alt="函数空间-2025040523.png" src="lib\media\函数空间-2025040523.png"><br><img alt="1-函数空间-2025040523.png" src="lib\media\1-函数空间-2025040523.png"><br><img alt="2-函数空间-2025040523.png" src="lib\media\2-函数空间-2025040523.png"><br><img alt="3-函数空间-2025040523.png" src="lib\media\3-函数空间-2025040523.png"><br>此处省略习题....（太多了😭）<br>
<br>
<br>可以证明该集合至多可数<a href="about:blank#fnref-1-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
<br>正交意味着任意两个元垂直，规范意味着模为 1.<a href="about:blank#fnref-2-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>实变函数\函数空间.html</link><guid isPermaLink="false">实变函数/函数空间.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\函数空间-2025040523.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\函数空间-2025040523.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[积分理论]]></title><description><![CDATA[ 
 <br>参见《实变函数习题精选》徐森林<br><br>Theorem (用连续函数刻画 Lebesgue 可测函数).
设  为 Lebesgue 可测集， 为  上的 Lebesgue 可测函数，则对于任意 ，存在  的闭子集 ，使得 ，且  为  上的连续函数.
<br>将  延拓到  上，我们有定理 <a data-href="#^1256bd" href="about:blank#^1256bd" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^1256bd</a><a data-href="#^1256bd" href="about:blank#^1256bd" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 1 (用连续函数刻画 Lebesgue 可测函数)</a> 的另一种表述形式：<br>Theorem.
设  为 Lebesgue 可测集， 为  上的 Lebesgue 可测函数，则对于任意 ，必有  上的连续函数 ，使得<br>
如果  (或 ) 则上述  可以同样  (或 ).
<br>Remark.
 可以被选为具有紧 <a data-footref="[inline0" href="about:blank#fn-1-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a>的支撑的函数.
<br>一个推论是:<br>Corollary.
设  为  上几乎处处有限的 Lebesgue 可测函数，则存在  上的连续函数列  使得在  上<br>

<br>连续函数  复合上 Lebesgue 可测函数  得到的  依然可测，这由 Lebesgue 可测性的“任意开集逆像为可测集”定义可得. 但  不一定可测.<br>Exercise (逼近·几乎处处有限的可测函数).
设  为测度空间， 为  上的几乎处处有限的可测函数，. 证明：对于任意 ，存在  上的有界可测函数 ，使得<br>

<br>Proof.<br>
因为  为  上的几乎处处有限的可测函数，所以<br><br><br>都是可测集，且 ， 关于  单调递减，. 由于 ，所以有测度的下连续性<br><br>因此对于任意 ，存在 ，使得当  时，, 令<br><br>即可.<br>□<br>Remark.
也可以反证. 
<br>Proof.<br>
假设存在 ，使得对于任意  上的有界可测函数  有<br><br>记 ，取<br><br>简单验证可知  有界可测. 于是<br><br>这与  几乎处处有界矛盾！<br>
□<br>Definition (Baire 函数 (Borel 可测函数)).
<img alt="积分理论-2025040600.png" src="lib\media\积分理论-2025040600.png">
<br>Exercise (Baire 函数很接近有限的 Lebesgue 可测函数).
设  是  上有限的 Lebesgue 可测函数，则一定存在全直线  上的 Borel 可测函数  使得<br>

<br>Proof.<br>
<img alt="1-积分理论-2025040600.png" src="lib\media\1-积分理论-2025040600.png"><br>
□<br><br>Theorem (Levi 定理).
设  为测度空间， 为  上的非负广义可测递增函数列，且 . 则<br>

<br>Exercise.
 为 Lebesgue 可测集  上的几乎处处大于零的 Lebesgue 可测函数，且满足<br>
证明：.
<br>Proof.<br>
考虑反证，我们知道<br><br>由题意 ，若  则存在  使得 ，那么<br><br>矛盾！<br>□<br>Exercise.
设  为  上非负 Lebesgue 可积函数<br>
证明：.
<br>Proof.<br>
记 , 则 ，于是<br><br>□<br>Exercise.
设  为  上的 Lebesgue 可测函数， ．证明：<br>
 为  上的 Lebesgue 可积函数  ．如果  ，举例说明充分性不成立．
<br>Proof.<br>令  ，则<br><br>由此推得<br>
 在  上 Lebesgue 可积  ．<br>举出反例：. 于是  但是 .<br>
□<br>Exercise.
设<br>
证明：.
<br>Proof.<br>
设 . 则当  时，<br><br>于是<br><br>于是 .<br>□<br><br>Theorem (勒贝格微分定理).
设 , 则对于几乎处处的 , 我们有

<br>Definition (Lebesgue 点).
设 . 对  中的 , 如果

那么称  为  的 Lebesgue 点.
<br>若  ，那么  几乎处处为  的 Lebesgue 点.<br>
<br>
<br>在  中，由海涅定理，等价于有界闭集.<a href="about:blank#fnref-1-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>实变函数\积分理论.html</link><guid isPermaLink="false">实变函数/积分理论.md</guid><pubDate>Thu, 15 May 2025 06:44:13 GMT</pubDate><enclosure url="lib\media\积分理论-2025040600.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\积分理论-2025040600.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[可测函数列的收敛]]></title><description><![CDATA[ 
 <br><br>See Royden.<br>Theorem (Egoroff's Theorem).
Assume  has finite measure. Let  be a sequence of measurable functions on  that converges pointwise on  to the real-valued function . Then for each , there is a closed set  contained in  for which

<br>Proof.<br>Lemma (Lemma 10).
Under the assumptions of Egoroff's Theorem, for each  and , there is a measurable subset  of  and an index  for which

<br>Proof.<br>
For each , the function  is properly defined, since  is real-valued, and it is measurable, so that the set  is measurable. Therefore<br><br> is ascending. And , since  converges pointwise to  on . We infer from the continuty of measure that<br><br>Since , we may choose an index  for which . Define , then we are done.<br>
□<br>
In the preceding lemma, let  and , i.e. <br><br>Define , then<br><br>For any , pick  such that , then<br><br>There exists closed  s.t.  . Therefore,<br><br>Thus  converges to  uniformly on .<br>
□<br>Theorem (Lusin's Theorem).
Let  be a real-valued measurable function on . Then for each , there is a continuous function  on  and a closed set  contained in  for which

]]></description><link>实变函数\可测函数列的收敛.html</link><guid isPermaLink="false">实变函数/可测函数列的收敛.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate></item><item><title><![CDATA[细节]]></title><description><![CDATA[ 
 <br>Theorem (Theorem  in Rudin).
If  and if  is a Cauchy sequence in  with limit , then  has a subsequence which converges pointwise almost everywhere to .
<br>This occurs in many proofs, e.g.<br>Theorem (the inversion theorem (Rudin  )).
If  and  and if<br>
then  and  a.e.
<br>, then <br><br>The integrands on the right side are bounded by , and since  as , the right side converges to  for every , by the dominated convergence theorem.<br>
If we combine theorem  and , we see that there is a sequence  such that  and <br><br>Hence  a.e. That  follows from theorem .]]></description><link>实变函数\细节.html</link><guid isPermaLink="false">实变函数/细节.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate></item><item><title><![CDATA[周民强]]></title><description><![CDATA[ 
 <br><br>参见周民强<br>]]></description><link>实变函数\周民强.html</link><guid isPermaLink="false">实变函数/周民强.md</guid><pubDate>Fri, 02 May 2025 08:58:52 GMT</pubDate></item><item><title><![CDATA[Cardinality]]></title><description><![CDATA[ 
 <br><br>Theorem (theorem 2.12 in baby rudin).
Let  be a sequence of countable sets, and put<br>
Then  is countable.
<br><img alt="Cardinality-20250312.png" src="lib\media\cardinality-20250312.png"><br><a data-href="#^d81540" href="about:blank#^d81540" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^d81540</a><a data-href="#^d81540" href="about:blank#^d81540" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 1 (theorem 2.12 in baby rudin)</a> can be written as<br><br>Theorem (theorem 2.13 in baby rudin).
Let  be a countable set, and let  be the set of all  -tuples , where  () and the elements  need not be distinct. Then  is countable.
<br><a data-href="#^c78d3f" href="about:blank#^c78d3f" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^c78d3f</a><a data-href="#^c78d3f" href="about:blank#^c78d3f" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 2 (theorem 2.13 in baby rudin)</a> is proved by induction from <a data-href="#^d81540" href="about:blank#^d81540" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^d81540</a><a data-href="#^d81540" href="about:blank#^d81540" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 1 (theorem 2.12 in baby rudin)</a>, which means<br><br>But <br><br>In particular, we have<br>Theorem (theorem 2.14 in baby rudin).
Let  be the set of all sequences whose elements are the digits  and . This set  is uncountable.<br>
The elements of  are sequences like 
<br>The proof is very classic to show that  is uncountable.<br>Let  be a countable subset of , and let  consist of the sequences . We construct a sequence  as follows. If the  th digit in  is , we let the  th digit of  be , and vice versa. Then the sequence  differs from every member of  in at least one place; hence . But clearly , so that  is a proper subset of .<br>We have shown that every countable subset of  is a proper subset of . It follows that  is uncountable (for otherwise  would be a proper subset of , which is absurd).<br><br>It should be noted that the mapping<br><br>is surjective but not injective. We denote the sets by<br><br><br>It's easy to check that  are countable. Then <br><br>is injective, thus bijective. Therefore<br>]]></description><link>实变函数\cardinality.html</link><guid isPermaLink="false">实变函数/Cardinality.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\cardinality-20250312.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\cardinality-20250312.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Construction-of-measure]]></title><description><![CDATA[ 
 <br><br> is a countable collection of nonempty open, bounded intervals that covers . Define the outer measure of  to be <br><br>The proof of countably subadditivity is very classic, i.e. check that<br><br>By the definition of outer measure, for any given , there is a collection  for each , such that<br><br>Then  is a open cover of , thus by the definition of , <br><br><br>A set  is said to be measurable provided for any set ,<br><br>Clearly, , it suffices to check that<br><br>Clearly any set of outer measure 0 is measurable, since , .<br>The proof of measurablity preserving under countable union is classic. Let  be a countable union of measurable sets . WLOG, assume that  are disjoint, then the proof is routine.<br>The collection  of measurable sets is a sigma-alegbra containing all the Borel sets, i.e. each  and  sets. <br><br>If  is a measurable set of finite outer measure contained in , then<br><br><br><img alt="Construction of measure-2025032810.png" src="lib\media\construction-of-measure-2025032810.png"><br><br>If  is a measurable set then its Lebesgue measure is defined by<br><br>i.e.<br><br><br>It's natural to be interested about the sets that is not measurable.<br>Theorem (Vitali).
Any set  of real numbers with positive outer measure contains a subset that fails to be measurable.
<br><img alt="1-Construction of measure-2025032811.png" src="lib\media\1-construction-of-measure-2025032811.png"><br><img alt="2-Construction of measure-2025032811.png" src="lib\media\2-construction-of-measure-2025032811.png"><br><br><br><img alt="3-Construction of measure-2025032811.png" src="lib\media\3-construction-of-measure-2025032811.png"><br><br><img alt="4-Construction of measure-2025032811.png" src="lib\media\4-construction-of-measure-2025032811.png"><br>
<img alt="5-Construction of measure-2025032811.png" src="lib\media\5-construction-of-measure-2025032811.png"><br>
<img alt="6-Construction of measure-2025032811.png" src="lib\media\6-construction-of-measure-2025032811.png"><br><br><img alt="7-Construction of measure-2025032811.png" src="lib\media\7-construction-of-measure-2025032811.png"><br><br><img alt="8-Construction of measure-2025032811.png" src="lib\media\8-construction-of-measure-2025032811.png"><br>
For example,  is  -finite under the Lebesgue measure on .<br>
<img alt="9-Construction of measure-2025032811.png" src="lib\media\9-construction-of-measure-2025032811.png"><br>
The Lebesgue measure restricted to Borel sets on  is not complete, since a Borel sets with measure zero contains a subsets that is not Borel, see royden page 52.<br><br>See evans 偏微分方程笔记 Chap 3 Appendix Measures.<br><br>We now define the general concept of an outer measure and of measurability of a set with respect to an outer measure, and show that the Carathéodory strategy for the construction of Lebesgue measure on the real line is feasible in general.<br><br><img alt="10-Construction of measure-2025032811.png" src="lib\media\10-construction-of-measure-2025032811.png"><br><img alt="11-Construction of measure-2025032811.png" src="lib\media\11-construction-of-measure-2025032811.png"><br>The union of a countable collection of measurable sets is measurable.<br><br><img alt="12-Construction of measure-2025032811.png" src="lib\media\12-construction-of-measure-2025032811.png"><br><br>The definition of outer measure before in this section is by properties, while the following is by construction. We can construct  by a set function (not measure) .<br>
<img alt="13-Construction of measure-2025032811.png" src="lib\media\13-construction-of-measure-2025032811.png"><br><br><img alt="14-Construction of measure-2025032811.png" src="lib\media\14-construction-of-measure-2025032811.png"><br><br><img alt="15-Construction of measure-2025032811.png" src="lib\media\15-construction-of-measure-2025032811.png"><br>
<img alt="16-Construction of measure-2025032811.png" src="lib\media\16-construction-of-measure-2025032811.png"><br>
<img alt="20-Construction of measure-2025032811.png" src="lib\media\20-construction-of-measure-2025032811.png"><br><br><img alt="18-Construction of measure-2025032811.png" src="lib\media\18-construction-of-measure-2025032811.png"><br>
<img alt="19-Construction of measure-2025032811.png" src="lib\media\19-construction-of-measure-2025032811.png"><br><br>We show that a semiring  has the property that every premeasure on  has a unique extension to a premeasure on a collection of sets that is closed with respect to the formation of relative complements.<br>
<img alt="21-Construction of measure-2025032811.png" src="lib\media\21-construction-of-measure-2025032811.png"><br><br><img alt="22-Construction of measure-2025032811.png" src="lib\media\22-construction-of-measure-2025032811.png">]]></description><link>实变函数\construction-of-measure.html</link><guid isPermaLink="false">实变函数/Construction-of-measure.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\construction-of-measure-2025032810.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\construction-of-measure-2025032810.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw1]]></title><description><![CDATA[ 
 <br><img alt="hw1-20250307.png" src="lib\media\hw1-20250307.png"><br>(1) <br><br>(2)<br><br>(3) take completion of both side of (1)<br><br>(4) take completion of both side of (2)<br><br>(5) for any ,  means that for any , there exists a  such that . In the set language,<br><br>(6) for any ,  means that for any , there exists a  such that . In the set language,<br><br>(7) combining with the result in (2) and (5) yields<br><br>(8) similar to (7)<br><br>(9)<br><br>(10) similar to (9)<br><br>(11)<br><br>(12) Since : , combining with the results of  yields the desired conclusion.<br><br><img alt="1-hw1-20250307.png" src="lib\media\1-hw1-20250307.png"><br>
Find an error of the question above.<br>Errata:<br>
If  for , , show that for each fixed ,  exists and<br><br>Fix  then  exists iff  and  exists and equals.<br><br><br>Since  exists,  thus . Hence  exists and equals to . Obviously, .<br><img alt="2-hw1-20250307.png" src="lib\media\2-hw1-20250307.png"><br><br>Then <br><br><br>If  then  for . Therefore .<br>For <br><br>Then <br><br><br>Claim that <br><br><br>For <br><br>Then <br><br><br>Claim that <br><br><br><img alt="3-hw1-20250307.png" src="lib\media\3-hw1-20250307.png"><br>Denote that<br><br>For , we have . Since  is dense in , there exists  for some , thus . Therefore .<br>For , we have  for some  then , i.e. . Therefore . Hence .<br><img alt="4-hw1-20250307.png" src="lib\media\4-hw1-20250307.png"><br>For any , denote that<br><br>Since  on  pointwisely and  ,we know that for any fixed , we have  i.e. there exists  such that  for all . <br><br><br>Therefore  exists and equals to .<br><img alt="5-hw1-20250307.png" src="lib\media\5-hw1-20250307.png"><br><br>Since  for any , . Therefore .<br>If , then there exists  such that . By the definition of , we have  for some  thus . Therefore . Hence . <br>For , there exists  such that . For any ,  then . Therefore , i.e. .<br><img alt="6-hw1-20250307.png" src="lib\media\6-hw1-20250307.png"><br>(4) 对任意  有 .<br>(1) means  is one-one. Since  is defined to be onto, then (1) means if  for  then . In other words, if  then .<br>(1)=&gt;(2): for any , we have  and  then  and  thus . Therefore . <br>It suffices to show that . We argue by contradiction. If there is an element  not containd in , then there exists  and  such that , . Since  is one-one, we have . Therefore , , which is a contradiction. Hence . <br>(2)=&gt;(3): Trivial.<br>(3)=&gt;(4): For fixed  and , , subtract  from . Since ,  then we have . But , so  i.e. .<br>(4)=&gt;(1): Pick , , and let , then  means , which implies  i.e. .<br><img alt="7-hw1-20250307.png" src="lib\media\7-hw1-20250307.png"><br>原题有误， 应改为 .<br> does not always hold. A conterexample is as follow.<br>Let  be groups,  is a subgroup of  and  is a subgroup of . The relation  on groups is defined to be group isomorphism. Then we have  and . Since  is set minus,  or  is not a group! (without the identity) Therefore . ]]></description><link>实变函数\hw1.html</link><guid isPermaLink="false">实变函数/hw1.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\hw1-20250307.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw1-20250307.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw2]]></title><description><![CDATA[ 
 <br><img alt="hw2-20250312.png" src="lib\media\hw2-20250312.png"><br>Exercise.
若  是无穷集， 是可数集，则  ．
<br>只需要建立一个一一映射，用来说明  和  的元素个数一样多。<br>Theorem.
<img alt="2-hw2-20250312.png" src="lib\media\2-hw2-20250312.png">
<br>不妨设 . 由于  可数，不妨设为 ，由于  是无穷集，根据 <a data-href="#^a6b345" href="about:blank#^a6b345" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^a6b345</a><a data-href="#^a6b345" href="about:blank#^a6b345" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 2</a> 我们知道 ，其中 ， 是一个可数集。那么我们构造映射如下<br><br>显然 ，. 因此  是一一映射，故 .<br>Exercise.
证明：可列集  的所有有限子集构成的集合  是可列集．
<br>不妨设 ，构造一个嵌入映射<br><br>其中  有限，显然  是一个单射，因此  是一个一一映射，由于 ，所以  至多可数，故  至多可数。由于 ，所以  不可能有限，因此  可数。<br>Exercise.
所谓代数数，是指满足某个整系数多项式方程的复数．显然所有的有理数都是代数数，但代数数也可能是无理数，甚至虚数，例如  和  都是代数数。证明：全体代数数构成的集合是可列集．
<br>设全体代数数构成的集合为 ，全体  次整系数多项式构成的集合为 ，全体满足  次整系数多项式方程的代数数构成的集合为 ，我们构造如下的映射<br><br>显然 ，由于可数集的可数并也是可数集，故只需要证明  都是至多可数集即可。由代数数的定义可知， 是一个满射，由于  可数，所以  至多可数。得证！<br>Exercise.
设  ．证明：<br>
（1）若存在常数  ，使得  中任意有限个不同的数之和都不超过  ，则  是可数集；<br>
（2）若  是无穷集，且  中任意选取可列个不同的数所组成的正项级数都收敛，则  是可列集．
<br>(1) 显然 ，不妨设 ，否则用  代替 。由于  中任意有限个不同的数之和不超过 ，那么 ，又因为<br><br>是一列至多可数集的可数并，故  至多可数。<br>
(2) 考虑<br><br>由 (1) 可知：存在常数  使得  中任意有限个不同的数之和都不超过 ，于是  是至多可数集。由于至多可数集的可数并可数。所以  可数。<br>Exercise.
证明： 上的凸函数  的不可导的点只有可数个．
<br>根据凸函数的定义，对于任意 ，对于任意 ，我们有<br><br>任意给定 ，考虑函数<br><br>显然  在  和  上分别单调递减，显然  在  上单调递减且有下界 ，于是  存在，由于  在  上单调递减且有上界 ，于是  存在。定义集合<br><br>由于  的凸性，我们知道 。因此，对于 ，考虑区间 ，由于  在  中稠密，，任取  的一个代表元 ，我们得到如下的嵌入映射<br><br>显然这是一个单射，那么 ，于是  至多可数。<br>Exercise.
证明： 上的函数  的局部极小值只有可数个．
<br>考虑集合<br><br>由局部极小值的定义可知， 是  的全部局部极小值构成的集合，显然 . 只需证明集合  至多可数即可。<br>
对于任意的 ，将  中离  最近的极小值点记作 ，将  中离  最近的极小值点记作 . 由于  是一个局部极小值点，所以存在  的一个充分小的邻域 ，使得 。让  取遍  中的所有元素，这样得到的所有  两两无交。对于任意给定的 ，由于  在  中稠密，可以任取一个  作为代表元，构造如下嵌入映射<br><br>这显然是一个单射，于是 ，于是  至多可数。<br>Exercise.
是否存在集合  ，使得  是可列集？
<br> 表示  的幂集，这是一个  代数，若  有限，那么显然  有限。若  无限，假设  是  的一个可数子集，不是一般性，我们不妨假设  中集合两两无交，否则令<br><br>由于  表示  的幂集，必然有 。断言  不可数，我们现在考虑  的任意一列子集 ，构造一个新的子集 ：若 ，则 ，否则 。于是 ，但 . 这意味着  的任意一个可数子集都是真子集，若  可数，那么  便是它自身的真子集，这与真子集的定义矛盾！故  不可数，因此  包含一个不可数集，故也不可数。<br>
综上，不存在集合  使得  可列。<br>Exercise.
 证明： 上的函数  的第一类间断点只有可数个．
<br>记<br><br>固定 ，记  是  左侧最近的第一类间断点， 是  右侧最近的第一类间断点。，根据有理数的稠密性，任取 ，构造如下映射<br><br>这显然是一个单射，于是  至多可数。<br>Exercise.
证明： 上的函数  的不可导但单侧可导的点只有可数个．
<br>记<br><br>固定 ，记  是  左侧最近的不可导但单侧可导的点， 是  右侧最近的不可导但单侧可导的点。，根据有理数的稠密性，任取 ，构造如下映射<br><br>这显然是一个单射，于是  至多可数。<br>Exercise.
教材第一章习题第 19 题．<br>
19．设  且为可数集，试构造  的一个分解  ，使得平行于  轴的直线与  的交点为可数个，平行于  轴的直线与  的交点为可数个．
<br>这是显然的！]]></description><link>实变函数\hw2.html</link><guid isPermaLink="false">实变函数/hw2.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\hw2-20250312.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw2-20250312.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw3]]></title><description><![CDATA[ 
 <br>Exercise.
1．判断下列集合的基数是  ，还是  ，并说明理由：<br>
（1）所有  维开矩体＊构成的集合  ；<br>
（2）所有以有理点（即坐标皆为有理数的点）为顶点的  维开矩体构成的集合  ；
<br>(1)<br><br>(2)<br><br>Exercise.
2．是否存在集合族  ，使得对任意集合  ，都存在  ，使得  ？
<br>I don't understand.<br>Exercise.
3．设  且  ．证明：  中存在经过  和  两点且不含有理点的圆周．
<br>Proof.<br>
假设任意经过  两点的圆周都包含有理点，考虑  的中垂线 ，这是一条直线，上面全部点的势为 . 取任意  为圆心，作过  的圆，可以找到一个不同于  的点 ，我们有如下自然映射<br><br>这显然是个单射，因为任意两个不完全重合的圆至多有两个交点，而刚才取的圆都交于 ，故 . 因此<br><br>矛盾！<br>
□<br>Exercise.
4．设  是可数集．证明：存在  ，使得  ．
<br>Proof.<br>
Assume, for contradiction, that for any , there exists  such that <br><br>That is<br><br>Construct the following map<br><br>which is 1-1, sisnce . Thus<br><br>which is a contradiction.<br>
□<br>Exercise.
5．教材第一章习题第 42 题（1）（2）．<br>
<img alt="hw3-20250323.png" src="lib\media\hw3-20250323.png">
<br>Proof.<br>
(1)<br>
If  then  which means that  is a limit point of . By definition,<br><br>Errata: . <br><br>(2)<br>
For any , check that<br><br>Denote that<br><br>Then  s.t.<br><br>Pick , then <br><br>Thus <br><br>Since  is arbitrary, we have<br><br>WLOG, assume that  is bounded (otherwise we replace  by )<br>Pick  in each  for . Since  is closed and bounded, thus compact, thus sequentially compact. Then  for some . Obviously, . We have<br><br>That is<br><br>Hence<br><br>□<br>Exercise.
6．教材第一章习题第 43 题．<br>
<img alt="hw3-2025032323.png" src="lib\media\hw3-2025032323.png">
<br>Since open set remains open under any union. That is, for any set ,  is open. <br>Now we consider . <br>If  is open, pick any , then  for some . There exists  for some , then . Thus  is an interior point of . Hence  is open.<br>If  is closed. Check that  is open.<br>Pick , then . Pick  in each , then  for some , thus . Let , then .  is an interior point of . Hence  is open.<br>If  then  is neither open nor closed.<br>Exercise.
7．若  都是  的闭集，是否一定存在  ，使得  ？予以证明或举出反例．
<br>不妨设  为有界闭集，则  为紧集，故列紧. 由  的定义可知，存在  使得 ，其中 .<br>Exercise.
8．试构造下列各函数（列）．<br>
（1）设  是  中互不相交的非空闭集．试作  上的连续函数  ，使得<br>
（i）  ；<br>
（ii） ；<br>
（iii） ．<br>
（2）设  ，且满足  ．试作  上的连续函数  ，使得<br>
（i） ；<br>
（ii） ．<br>
（3）设  是  的闭集．试作  上的连续函数序列  ，使得  ，  ．<br>
（4）设  是  的开集．试作  上的连续函数序列  ，使得  ， .
<br>(1) <br><br>(2)<br><br>(3)<br><br>(4)<br><br>Exercise.
9．教材第一章习题第 44 题．<br>
<img alt="hw3-2025032400.png" src="lib\media\hw3-2025032400.png">
<br>Note that all the sets must lies in a metric space. And the property  satisfy is called Normal separation property.<br>Let<br><br><br>Then . <br>Exercise.
10．教材第一章习题第 45 题．<br>
<img alt="1-hw3-2025032400.png" src="lib\media\1-hw3-2025032400.png">
<br>证不出来<br>Exercise.
11．教材第一章习题第 46 题．<br>
<img alt="2-hw3-2025032400.png" src="lib\media\2-hw3-2025032400.png">
<br>必要性显然，考虑充分性，假设  不是闭集，则存在一个包含在  中的极限点 ，于是存在  使得<br><br>于是 ，矛盾！<br>Exercise.
12．教材第一章习题第 48 题．<br>
<img alt="3-hw3-2025032400.png" src="lib\media\3-hw3-2025032400.png">
<br>下面证明  是开集. 任意给定 ，记<br><br>对于任意给定的 ，存在 ，使得<br><br>那么对于任意的 ，有<br><br>因此<br><br>故 . 得证！<br>再用  表示  的连续点集，显然 . 另一方面，对于任意 ，<br><br>也就是说，对于任意 ，存在 ，使得<br><br>这就是  在  处连续的定义.]]></description><link>实变函数\hw3.html</link><guid isPermaLink="false">实变函数/hw3.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\hw3-20250323.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw3-20250323.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw4]]></title><description><![CDATA[ 
 <br><img alt="hw4-2025032809.png" src="lib\media\hw4-2025032809.png"><br><img alt="1-hw4-2025032809.png" src="lib\media\1-hw4-2025032809.png"><br>(1) yes, yes.<br>(2) ,  s.t.. Since  is dense in , then . Construct<br><br> is clearly one-one, then<br><br>Thus  is at most countable.<br><img alt="2-hw4-2025032809.png" src="lib\media\2-hw4-2025032809.png"><br>(1) .<br>(2) .<br>(3) pick   then , , .<br>(4) , .<br><img alt="3-hw4-2025032809.png" src="lib\media\3-hw4-2025032809.png"><br>
Claim that .<br>First to show that . Let <br><br>Denote<br><br>. Therefore . Pick  in . It must lie in  for some . Then pick the sequence , which lies in , with limit point  which is the nearest point in . So is  for the sequence . Therefore .<br>If , then there is a point  in  with a sequence  in  convergent to , but . Since each  is midpoint of  then  can be any closed to the points in , as . Hence  which is a contradiction.<br><img alt="hw4-2025032810.png" src="lib\media\hw4-2025032810.png"><br>
Clearly:  and .<br>, for . Suppose that  and . Then<br><br><br>By induction, we have<br><br><img alt="1-hw4-2025032810.png" src="lib\media\1-hw4-2025032810.png"><br>Counterexample:<br><br>Pick ,  then  is constant on each , thus continuous. But  is not continuous on . <br><img alt="2-hw4-2025032810.png" src="lib\media\2-hw4-2025032810.png"><br>Denote , . Construct a sequence <br><br>Since , it suffices to chech that  for each . Clearly, . When ,<br><br>Since , then  covering  such that<br><br>. WLOG  are positive or negative. Let<br><br>Then ,  must lie in  for some . Then  lies in , which means that  covers , thus<br><br>Thus <br><br><img alt="hw4-2025032812.png" src="lib\media\hw4-2025032812.png"><br>Denote that<br><br>Then  is continuous thus uniformly continuous on . For any given , let<br><br>Then  is an open cover of . Since  is closed and bounded, thus compact. Then there exists  such that <br><br>Then <br><br>Then <br><br>Since  is arbitrary, . Therefore<br><br><img alt="hw4-2025032819.png" src="lib\media\hw4-2025032819.png"><br>It suffices to check that . By the definition of outer measure, since , then  covering , s.t.<br><br>Pick  covering  s.t. <br><br>Put , then  is a cover of , then<br><br>Since  is arbitrary, thus<br><br>Therefore<br><br>Since , then <br><br><img alt="1-hw4-2025032819.png" src="lib\media\1-hw4-2025032819.png"><br>Since , then<br><br>Since  then<br><br>Thus<br><br><img alt="2-hw4-2025032819.png" src="lib\media\2-hw4-2025032819.png"><br><br>NTS: . , check that . <br>NTS: . <br>Fix , NTS: . <br><br>Therefore .<br><br>Hence <br>]]></description><link>实变函数\hw4.html</link><guid isPermaLink="false">实变函数/hw4.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\hw4-2025032809.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw4-2025032809.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw5]]></title><description><![CDATA[ 
 <br><img alt="hw5-2025040310.png" src="lib\media\hw5-2025040310.png"><br>
(1) false. Let , where  denotes the cantor set.<br>(2) false. Let .<br>(3) false. Let .<br>(4) true. By the definition of outer measure,<br><br>Then for any , there exists a collection of nonempty open, bounded intervals  covering , with<br><br>In the general definition of outer measure defined on a sigma-algebra and by a set function,  can be chosen to be closed. But here we construct a closed set from each . Denote  by , let<br><br>Then<br><br>Thus  is a collection of open bounded nonempty intervals that covers . Therefore<br><br>Since  is arbitrary, we have<br><br>Since , , <br><br>(5) false. Let , then  is countable thus has measure zero, but  has measure .<br><img alt="2-hw5-2025040310.png" src="lib\media\2-hw5-2025040310.png"><br>
Pick , then  such that . Therefore<br><br><img alt="hw5-2025040311.png" src="lib\media\hw5-2025040311.png"><br><br><img alt="1-hw5-2025040311.png" src="lib\media\1-hw5-2025040311.png"><br>Since <br><br>Then for any set ,<br><br><br>Therefore<br><br>Thus .<br><img alt="2-hw5-2025040311.png" src="lib\media\2-hw5-2025040311.png"><br>
<img alt="3-hw5-2025040311.png" src="lib\media\3-hw5-2025040311.png"><br>Errata: . <br>For any set ,<br><br><br>Therefore<br><br>Hence .<br><img alt="4-hw5-2025040311.png" src="lib\media\4-hw5-2025040311.png"><br>
<img alt="5-hw5-2025040311.png" src="lib\media\5-hw5-2025040311.png"><br>If , then the equality is trivial. If , since , then<br><br><br>Hence<br><br><img alt="6-hw5-2025040311.png" src="lib\media\6-hw5-2025040311.png"><br>
<img alt="7-hw5-2025040311.png" src="lib\media\7-hw5-2025040311.png"><br>Errata: .<br>Since , then<br><br>Then <br><br><img alt="8-hw5-2025040311.png" src="lib\media\8-hw5-2025040311.png"><br>
<img alt="9-hw5-2025040311.png" src="lib\media\9-hw5-2025040311.png"><br>For any set ,<br><br><img alt="10-hw5-2025040311.png" src="lib\media\10-hw5-2025040311.png"><br><br><img alt="11-hw5-2025040311.png" src="lib\media\11-hw5-2025040311.png"><br><br><br>When  exists, we have , then<br><br>Thus , and<br><br><img alt="12-hw5-2025040311.png" src="lib\media\12-hw5-2025040311.png"><br>
(1)<br>
Claim that:<br>
<br>.
<br>.
<br>Firstly,  is trivial. , since  is bijection,  s.t. ,  s.t.. But the preimage of  is unique, thus , thus . Therefore .<br>Secondly, ,  for some , then , then , . , . Since  is bijection,  s.t.. Clearly , thus , . Therefore .<br>Then for any set , its preimage is , i.e.. Then<br><br>Thus  is measurable.<br>(2) Since the outer measure  is invariant under translation, the measure  is also invariant under translation.]]></description><link>实变函数\hw5.html</link><guid isPermaLink="false">实变函数/hw5.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\hw5-2025040310.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw5-2025040310.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw6]]></title><description><![CDATA[ 
 <br><img alt="hw6-2025041520.png" src="lib\media\hw6-2025041520.png"><br>
<img alt="1-hw6-2025041520.png" src="lib\media\1-hw6-2025041520.png"><br>
<img alt="2-hw6-2025041520.png" src="lib\media\2-hw6-2025041520.png"><br>Exercise.
设  为可测集，若  ，试证  ；若  ，试证  ．
<br>Proof.<br>
反证而设, ，则存在 ， 并非  的聚点，故存在区间  使得 . 故 ， 矛盾！<br>若 ，则对于 ，存在  的邻域（某个区间），使得 ，于是  矛盾！<br>
□<br>Exercise.
<img alt="hw6-2025041600.png" src="lib\media\hw6-2025041600.png">
<br>Proof.<br>
(1)<br><br>又因为<br><br>故 <br><br>(2)<br><br>(3)<br><br>要使得  只需要 . <br>要使得  只需要 .<br>
□<br>Exercise.
<img alt="1-hw6-2025041600.png" src="lib\media\1-hw6-2025041600.png">
<br>
开集和闭集的边界可能有正测度！
<br>Proof.<br><br>若  可测，由于 ，所以 . <br>若  可测，不会证明！<br>□<br>Exercise.
<img alt="2-hw6-2025041600.png" src="lib\media\2-hw6-2025041600.png">
<br>Proof.<br>
不一定. 当 ，考虑 ，显然 ，故  可测，，对于任意包含  的开集 ，对于任意 ， 的某个充分小小邻域都在  内，由于  在  内稠密，故对于充分小的 ，，从而 <br><br>于是 <br><br>故<br><br>□<br>Exercise.
<img alt="3-hw6-2025041600.png" src="lib\media\3-hw6-2025041600.png">
<br>Proof.<br>
(1) 只需要验证对于任意集合 ，满足<br><br>我们知道 . 于是<br><br>又因为 <br><br>故<br><br>由  任意性，. 因此  可测.<br>(2) 只需要验证对于任意集合 ，满足<br><br>因为<br><br><br>所以<br><br>由  任意性，<br><br>故  可测.<br>(3) 充分性由 (2) 显然，下面证明必要性.<br>假设  可测，则对于任意给定的 ，可作开集  且 , 从而<br><br>此外<br><br>取  充分大使得<br><br>于是<br><br>得证！<br>
□<br>Exercise.
<img alt="hw6-2025041601.png" src="lib\media\hw6-2025041601.png">
<br>Proof.<br>Lemma.
<img alt="1-hw6-2025041608.png" src="lib\media\1-hw6-2025041608.png">
<br>Proof.<br>
若 ，根据可测的定义，存在一列开区间  , 使得  (开集的任意并还是开集)，且<br><br>于是<br><br>于是<br><br>若 ，定义  (有限测度)，则对于任意给定的 ， 存在开集  使得<br><br>那么定义  (仍然是开集)，则 <br><br>故得证！<br>接下来对于集合 ，考虑 ，对于任意给定的 ，存在开集 ，使得 . 现在令 ，由于 ，所以 . 故得证！<br>
□<br>(1)<br>
若  有限，只需要证明：若  可测，那么对于任意给定的 ，存在有界闭集 ，使得 <br><br>也就是<br><br>对于任意给定的 ，存在 ，使得 . 由 <a data-href="#^336926" href="about:blank#^336926" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^336926</a><a data-href="#^336926" href="about:blank#^336926" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Lemma 7</a> 可知，存在闭集 ，使得<br><br>由于<br><br>于是<br><br>若 ，那么定义 ，于是<br><br>由于 ，那么根据 <a data-href="#^336926" href="about:blank#^336926" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^336926</a><a data-href="#^336926" href="about:blank#^336926" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Lemma 7</a> ，存在 ，使得 ，于是<br><br>(2) 由 <a data-href="#^336926" href="about:blank#^336926" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^336926</a><a data-href="#^336926" href="about:blank#^336926" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Lemma 7</a> 可知，对于任意给定的  存在包含  的开集 ，使得 .<br>与此同时，，从而存在有界闭集  ,使得<br><br>从而 ，且 . 由 <a data-href="#^5c15b8" href="about:blank#^5c15b8" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^5c15b8</a><a data-href="#^5c15b8" href="about:blank#^5c15b8" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Exercise 5</a> (1) 可知  可测.<br>□<br>Exercise.
<img alt="hw6-2025041608.png" src="lib\media\hw6-2025041608.png">
<br>Proof.<br>
由 <a data-href="#^336926" href="about:blank#^336926" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^336926</a><a data-href="#^336926" href="about:blank#^336926" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Lemma 7</a> 可知，对于任意 ，存在集合  使得<br><br>记 ，那么  是  集，且<br><br>令 ，那么 ，且 .  是  的等测包，存在！<br>
□<br>Exercise.
<img alt="hw6-2025041609.png" src="lib\media\hw6-2025041609.png">
<br>Proof.<br>Lemma (From Royden).
<img alt="1-hw6-2025041609.png" src="lib\media\1-hw6-2025041609.png">
<br>(1)<br>
 确实可能严格大于零，因为  不一定可测，而  等价于  可测. 该等价性的证明如下：<br><br>其中  可测， 由于零外测集一定可测，所以 ，由于 ，所以 . 反之，若有  可测，则根据 <a data-href="#^336926" href="about:blank#^336926" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^336926</a><a data-href="#^336926" href="about:blank#^336926" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Lemma 7</a> 可知，存在 ，，使得 .<br>接下来考虑  的任意可测子集 ，有 ，由于 ，那么 . 由于 ，所以 . 由于 ，所以 ，由于 ，于是<br><br>(2) 作  的等测包 ，于是 ，故 ，于是 . 故  是  的等测包.<br>(3) 对于  的等测包 ，考虑  的任一可测子集 ，那么<br><br>故 ，由 <a data-href="#^0e7d37" href="about:blank#^0e7d37" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^0e7d37</a><a data-href="#^0e7d37" href="about:blank#^0e7d37" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Exercise 9</a>  (2) 可知，.<br>□<br>Exercise.
<img alt="hw6-2025041611.png" src="lib\media\hw6-2025041611.png">
<br>Proof.<br>
(1) 对每个  作等测包  满足<br><br>从而<br><br>(2) 由于 , 所以 . 从而<br><br><br>因此  存在. 由 (1) 可知：<br><br>同时，因为 ，所以<br><br>因此<br><br>故<br><br>□<br>Exercise.
<img alt="1-hw6-2025041611.png" src="lib\media\1-hw6-2025041611.png">
<br>Proof.<br>
设  分别是  的等测包，那么<br><br>由于 <br><br><br>从而<br><br>由于 ，所以<br><br>因此<br><br>从而<br><br>□<br>Exercise.
<img alt="hw6-2025041612.png" src="lib\media\hw6-2025041612.png">
<br>
<img alt="1-hw6-2025041612.png" src="lib\media\1-hw6-2025041612.png">
<br><img alt="2-hw6-2025041612.png" src="lib\media\2-hw6-2025041612.png"><br>
<img alt="3-hw6-2025041612.png" src="lib\media\3-hw6-2025041612.png"><br>
<img alt="4-hw6-2025041612.png" src="lib\media\4-hw6-2025041612.png"><br>
<img alt="5-hw6-2025041612.png" src="lib\media\5-hw6-2025041612.png"><br>
<img alt="6-hw6-2025041612.png" src="lib\media\6-hw6-2025041612.png"><br>Exercise.
<img alt="7-hw6-2025041612.png" src="lib\media\7-hw6-2025041612.png">
]]></description><link>实变函数\hw6.html</link><guid isPermaLink="false">实变函数/hw6.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\hw6-2025041520.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw6-2025041520.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw7]]></title><description><![CDATA[ 
 <br>Exercise.
<img alt="2-hw7-2025042112.png" src="lib\media\2-hw7-2025042112.png">
<br>Proof.<br>
 for some , let <br><br>For , we have<br><br><br>Thus . We have . Applying the intermediate value theorem to , for any , there exists  s.t. , i.e.  . Let  then we are done.<br>
□<br>Exercise.
<img alt="4-hw7-2025042112.png" src="lib\media\4-hw7-2025042112.png">
<br>Proof.<br>
Since  and  are measurable functions over , we have  for any . Then <br><br>Similarly, <br><br>Then <br><br><br><br>□<br>Exercise.
<img alt="5-hw7-2025042112.png" src="lib\media\5-hw7-2025042112.png">
<br>Proof.<br>
(1) Since  is open in , we have disjoint  s.t. <br><br>(2) For  open or closed in , we have <br><br>Then<br><br><br><br>Therefore for any Borel set ,<br><br>□<br>Exercise.
<img alt="6-hw7-2025042112.png" src="lib\media\6-hw7-2025042112.png">
<br>Proof.<br>
.<br>
<img alt="15-hw7-2025042112.png" src="lib\media\15-hw7-2025042112.png"><br>
If  is countable, then for any ,  is countable, thus measurable. Hence  is measurable.<br>
□<br>Exercise.
<img alt="7-hw7-2025042112.png" src="lib\media\7-hw7-2025042112.png">
<br>Proof.<br>
<img alt="16-hw7-2025042112.png" src="lib\media\16-hw7-2025042112.png"><br>
Since  is measurable, then . For , . Since , then<br><br><br>Then <br><br>Therefore for any , we have <br><br>Hence  is measurable.<br>
□<br>Exercise.
<img alt="8-hw7-2025042112.png" src="lib\media\8-hw7-2025042112.png">
<br>Proof.<br>
There is a  set  contained in  for which .  is measurable on  (it's trivial). For any ,<br><br>Thus , <br><br>□<br>Exercise.
<img alt="9-hw7-2025042112.png" src="lib\media\9-hw7-2025042112.png">
<br>Proof.<br>
Suppose that  is measureable, then  for any . Conversely,  for any  then for any , there is a rational sequence  with . Then <br><br>Therefore  is measurable on .<br>
□<br>Exercise.
<img alt="10-hw7-2025042112.png" src="lib\media\10-hw7-2025042112.png">
<br>Proof.<br>
当指标集  为不可数集， 的上确界函数  不一定可测，反例可取  为不可数集，对 ，作函数<br><br>则  并不可测. <br>如果加上了  连续的条件，那么对于任意的 ,<br><br>由于 ，故  是开集，开集的任意并也是开集，故  是开集，于是  是  集，故可测. 于是  可测.<br>
□<br>Exercise.
<img alt="11-hw7-2025042112.png" src="lib\media\11-hw7-2025042112.png">
<br>Proof.<br>
(1)<br>Remark (Royden Chap 3 Ex 8).
<img alt="1-hw7-2025042211.png" src="lib\media\1-hw7-2025042211.png">
<br><a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV1Wq4y1P7d3?spm_id_from=333.788.videopod.episodes&amp;vd_source=b55594d2ba73cdd7666e94ca2cf2fe93&amp;p=8" rel="noopener nofollow" class="external-link" href="https://www.bilibili.com/video/BV1Wq4y1P7d3?spm_id_from=333.788.videopod.episodes&amp;vd_source=b55594d2ba73cdd7666e94ca2cf2fe93&amp;p=8" target="_blank">3.8_哔哩哔哩_bilibili</a><br>Lemma.
If  is Lebesgue measurable, and  is a Borel set, then . 
<br>Proof.<br>
For any open interval , we have . Given , open, then . In open interval <br><br>Let . Every open set in  is contained in . In particular, .  is closed under completion and coutable union. (left as an exercise) Hence the conclusion follows.<br>
□<br>
To prove that  is Lebesgue measurable function, it suffices to check that  for any open set . Note that<br><br>Since  is Borel function and  is Borel set, . By <a data-href="#^1d07c0" href="about:blank#^1d07c0" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^1d07c0</a><a data-href="#^1d07c0" href="about:blank#^1d07c0" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Lemma 11</a>, , which yields the conclusion.<br>(2) For any open set ,<br><br>Hence the conclusion follows.<br>
□<br>Exercise.
<img alt="12-hw7-2025042112.png" src="lib\media\12-hw7-2025042112.png">
<br>Proof.<br>
Let<br><br>Then <br><br>Since ,  is measurable on . Thus  is measurable. <br>For any  ,<br><br>Lemma.
设 ，若存在  中可测集 , 使得 ，则 , 且有 .
<br>Proof.<br>
Trivial.<br>
□<br>
Put  and , then<br><br>By <a data-href="#^0feb41" href="about:blank#^0feb41" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^0feb41</a><a data-href="#^0feb41" href="about:blank#^0feb41" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Lemma 13</a>, we have . Hence the conclusion follows. <br> □<br>Exercise.
<img alt="13-hw7-2025042112.png" src="lib\media\13-hw7-2025042112.png"><br>
<img alt="14-hw7-2025042112.png" src="lib\media\14-hw7-2025042112.png">
<br>Proof.<br>
(1)<br><br>That is, for any , there exists  s.t. <br><br>Let  and , then , and .<br>(2) No. Consider  and<br><br>If , then . Thus , .<br>
□]]></description><link>实变函数\hw7.html</link><guid isPermaLink="false">实变函数/hw7.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\2-hw7-2025042112.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\2-hw7-2025042112.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw8]]></title><description><![CDATA[ 
 <br>Exercise.
<img alt="1-hw8-2025042920.png" src="lib\media\1-hw8-2025042920.png">
<br>Proof.<br>
Denote , . Then for any open set <br><br>□<br>Exercise.
<img alt="2-hw8-2025042920.png" src="lib\media\2-hw8-2025042920.png"><br>
<img alt="3-hw8-2025042920.png" src="lib\media\3-hw8-2025042920.png">
<br>(1)<br>Theorem (Egoroff's Theorem).
Assume  has finite measure. Let  be a sequence of measurable functions on  that converges pointwise on  to the real-valued function . Then for each , there is a closed set  contained in  for which

<br>By Egoroff's theorem, for each , there exists closed  s.t. <br><br>Thus<br><br>Let  then<br><br>(2) The reasoning is wrong. <br><img alt="hw8-2025042923.png" src="lib\media\hw8-2025042923.png"><br>
<img alt="1-hw8-2025042923.png" src="lib\media\1-hw8-2025042923.png"><br>Exercise.
<img alt="4-hw8-2025042920.png" src="lib\media\4-hw8-2025042920.png">
<br>Let , then . Apply Egoroff's theorem to , for any , there exists  s.t. <br><br>There exists  s.t. <br><br>Since  is finite a.e. on , there exists  s.t. <br><br>And<br><br>There exists  s.t. <br><br>Therefore <br><br>where . Define<br><br>Then<br><br>Then we are done.<br>Exercise.
<img alt="5-hw8-2025042920.png" src="lib\media\5-hw8-2025042920.png">
<br> 意味着几乎处处收敛，但依测度收敛并不蕴含几乎处处收敛.<br>
<img alt="hw8-2025043009.png" src="lib\media\hw8-2025043009.png"><br>Exercise.
<img alt="6-hw8-2025042920.png" src="lib\media\6-hw8-2025042920.png">
<br>由 Riesz 定理，存在  的子列 ，使得  在  上几乎处处收敛于 . 也就是说 <br><br>也就是对于任意给定的 ，存在 , 使得对于任意 ，有<br><br>由于 ,  a.e. 于 ，我们有<br><br>从而对于任意给定的 ，<br><br>从而<br><br>于是对于任意 ，我们有<br><br>因此<br><br>Exercise.
<img alt="7-hw8-2025042920.png" src="lib\media\7-hw8-2025042920.png">
<br>Proof.<br>
By <a data-href="#^723813" href="about:blank#^723813" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^723813</a><a data-href="#^723813" href="about:blank#^723813" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Exercise 8</a>,  iff ,  a.e., that is,  a.e. <br>Suppose that , then  a.e., i.e. for any , there exists  s.t. <br><br>Then for any , we have <br><br>Thus  a.e. <br>Suppose that  a.e. For any given , we have to find its subsequence  a.e. There exists  with measure 0, s.t.  on . There exists  s.t.  on , for any . Thus <br><br>Thus  as  on , i.e.  a.e. Then we are done!<br>
□<br>Exercise.
<img alt="8-hw8-2025042920.png" src="lib\media\8-hw8-2025042920.png">
<br>Proof.<br>
若 ，则 ，由 Riesz 定理，存在  a.e. <br>若 ,  a.e. 假设 ，也就是存在 ，使得<br><br>于是  存在子列 , 其中 . 又由于  a.e. 那么 ，但是<br><br>矛盾！<br>
□<br>Exercise.
<img alt="9-hw8-2025042920.png" src="lib\media\9-hw8-2025042920.png"><br>
<img alt="10-hw8-2025042920.png" src="lib\media\10-hw8-2025042920.png">
<br>(1)<br>
If , then for any , by Riesz's theorem,  a.e. That is,  with measure 0, s.t.  on . Since  is continuous, we have  on . Thus  a.e. By <a data-href="#^723813" href="about:blank#^723813" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^723813</a><a data-href="#^723813" href="about:blank#^723813" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Exercise 8</a> we are done. <br>If  is uniformly continuous on , then , , s.t. <br><br>which means  implies  and  implies . Since , we also have , as . Then <br><br>If  is uniformly bounded on , i.e. , s.t. , . We restrict  to , then , and  is uniformly continuous on the closed interval . Apply (2), we have . For any , <br><br>(2)<br>(3)<br>
Since  then ,  as . Due to the inequality,<br><br>We have the inclusion of sets.<br><br>Thus<br><br>Let , then . Hence .<br>By Riesz's theorem, there exists a subsequence  a.e. Since  a.e. on , we have <br><br>Then <br><br>Therefore<br><br>Hence  a.e. on .<br>Exercise.
<img alt="11-hw8-2025042920.png" src="lib\media\11-hw8-2025042920.png"><br>
<img alt="12-hw8-2025042920.png" src="lib\media\12-hw8-2025042920.png">
<br>并不一定. <br>Exercise.
<img alt="13-hw8-2025042920.png" src="lib\media\13-hw8-2025042920.png">
<br>(1) 若  有一者为零，则显然. 若  非零，则<br><br>(2)<br>
利用 Riesz 定理，我们有对于任意 ，存在  a.e.，存在  a.e. 从而  a.e. 再利用  <a data-href="#^723813" href="about:blank#^723813" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^723813</a><a data-href="#^723813" href="about:blank#^723813" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Exercise 8</a> 可知 .<br>(3)<br>
 时存在反例.<br>
<img alt="1-hw8-2025043012.png" src="lib\media\1-hw8-2025043012.png"><br>
 时存在反例，但  时结论成立，证明如下<br><br>(4)<br>
利用 Riesz 定理，我们有对于任意 ，存在  a.e.，存在  a.e. 从而  a.e. 再利用  <a data-href="#^723813" href="about:blank#^723813" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^723813</a><a data-href="#^723813" href="about:blank#^723813" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Exercise 8</a> 可知 .<br>(5)<br><br>断言：，这是因为<br><br>再结合 (1) 可知，, .]]></description><link>实变函数\hw8.html</link><guid isPermaLink="false">实变函数/hw8.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\1-hw8-2025042920.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\1-hw8-2025042920.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw9]]></title><description><![CDATA[ 
 <br>Exercise.
<img alt="hw9-2025050523.png" src="lib\media\hw9-2025050523.png">
<br>Proof.<br>
If , then given , for any , there exists , s.t. <br><br>Then <br><br>Thus <br><br>Conversely, suppose that <br><br>i.e. for any , there exists , s.t. <br><br>Then there exists  s.t. <br><br>Therefore,<br><br>Given , for any , we have <br><br>Therefore<br><br>□<br>Exercise.
<img alt="1-hw9-2025050523.png" src="lib\media\1-hw9-2025050523.png">
<br>Proof.<br>
Obviously,  is finte a.e. Since , then for given , for any , there exists  s.t. <br><br>For any , we have<br><br>Then for any ,<br><br>Thus  is Cauchy in measure.<br>
□<br>Exercise.
<img alt="2-hw9-2025050523.png" src="lib\media\2-hw9-2025050523.png">
<br>结论：这两种说法既不等价，也不存在蕴含关系。<br>Proof.<br>
<br>
证明 <br>
（即：几乎处处连续 不能 推出 几乎处处等于某个连续函数）

<br>反例：考虑函数  定义在  上：


<br>分析（1）：函数  在  上是连续的，因为它是由连续函数复合而成的。它仅在  处不连续，因为当 时，  在 -1 和 1 之间振荡，极限不存在。因此，间断点集合  。点集的勒贝格测度为零，所以  。故函数  满足说法（1）。
<br>分析（2）：假设存在一个在  上连续的函数  ，使得  几乎处处成立。这意味着集合  的测度为零， 。因为  和  都在  上几乎处处相等，并且它们都在  上连续 (  在整个  连续，因此在  连续； 在  连续），那么它们必须在整个  上都相等。（如果存在  使得  ，由连续性，必然存在  的一个邻域  使得  ，这个区间的测度为  ，与  几乎处处矛盾）。因此，必然有  对所有  成立。但是，函数  在 时极限不存在，所以不可能将它在  处定义某个值  使得  在  处连续。这与  是  上的连续函数的前提相矛盾。所以，不存在这样的连续函数  。故函数  不满足说法（2）。
<br>结论：（1）不能推出（2）。


<br>
证明 <br>
（即：几乎处处等于某个连续函数 不能 推出 几乎处处连续）

<br>反例：考虑狄利克雷函数（Dirichlet function） 定义在  上：


<br>分析（2）：令  对所有  。显然  是  上的连续函数。集合   。有理数集合  是可数集，其勒贝格测度为零，即  。因此， 与连续函数  几乎处处相等。故函数  满足说法（2）。
<br>分析（1）：狄利克雷函数  在  上的每一点都不连续。对于任意  ，其任意小的邻域内都既包含有理数（  值为 1 ）也包含无理数（  值为 0 ）。因此  不存在。所以，间断点集合  。该集合的勒贝格测度  。故函数  不满足说法 （1）。
<br>结论：（2）不能推出（1）。


<br>□<br>Exercise.
<img alt="3-hw9-2025050523.png" src="lib\media\3-hw9-2025050523.png">
<br>Proof.<br>
There exists  with measure 0, s.t.  is continuous thus measurable on .  is clearly measurable. For any open set , <br><br>Since  and , then<br><br>Thus we are done!<br>□<br>Exercise.
<img alt="4-hw9-2025050523.png" src="lib\media\4-hw9-2025050523.png">
<br>Proof.<br>
Let <br><br>List these functions<br><br>Then  on , because for any , <br><br>Thus<br><br>But  disconverges everywhere on , since for given , then for any ,  lies in  for some  large enough (), there exists , s.t. <br><br><br>Thus  does not converges at , by Cauchy's criterion.<br>We are done!<br>
□<br>Exercise.
<img alt="6-hw9-2025050523.png" src="lib\media\6-hw9-2025050523.png">
<br>Proof.<br>
For any given , there exists closed  with , s.t.  is continuous on . Then for any open set , we have<br><br>Note that <br><br>For any , we have <br><br>Note that<br><br><br>Then<br><br>Since  is arbitrary, we have<br><br>for any open , thus we are done!<br>□<br>Exercise.
<img alt="7-hw9-2025050523.png" src="lib\media\7-hw9-2025050523.png"><br>
<img alt="8-hw9-2025050523.png" src="lib\media\8-hw9-2025050523.png">
<br>错误在于  并不在  上连续，反例考虑<br><br>令 ，显然  在  上连续，但<br><br>，并不连续.<br>接下来，我们讨论 Lusin 定理的结论是否能改为：存在  的可测子集 ，使得  且  在  上连续。并给出反例。<br>Lusin 定理原文保证存在闭集  使得  且  连续。修改后的版本要求：<br>
<br> 是可测集 (比闭集更弱的要求)。
<br> (比  更强的要求)。
<br> 在  上连续。
<br>这个修改后的命题不成立。我们可以举出反例。<br>Example.
令 。构造一个 "Fat Cantor set" (胖康托集) 。这种集合具有以下性质：

<br> 是闭集 (因此是可测集)。
<br> 是无处稠密的 (不包含任何区间)。
<br> 的勒贝格测度 。 (例如，在康托三分集的构造中，每次去掉中间  长度的开区间，改为去掉长度为  的开区间，其中  足够小，使得 ，则剩余集合的测度为 ）。

现在定义函数 ，即

由于  是可测集， 是  上的可测函数。且 。
<br>证明  不满足修改后的命题：<br>假设存在一个可测集  使得  且  在  上连续。<br>
<br>由于 ，这意味着 。
<br>因为  且 ，所以  必须与  相交，且交集  的测度 。(因为 ，所以 。又因为 。故 ）。
<br>同样地，因为  且  (假设 )，所以  必须与  相交，且 。
<br>取一个点 。因为  在  上连续，所以  在点  连续。这意味着： 由于 ，我们有 。所以必须有 。<br>然而， 是无处稠密的。这意味着在点  的任意小邻域  内都存在不属于  的点。也就是说，存在序列  使得 。<br>由于 ，集合  不能包含一个测度为  的集合  的 "大部分"。更确切地说，对于 ，由于  无处稠密， 是  的极限点。因为 ，所以  不可能是空集，并且它必须在  附近积累。因此，我们可以找到一个序列 ，其中 。<br>对于这样的序列 ：<br>
<br>
<br>，所以 。
<br>
<br>根据  在  处连续的要求，我们必须有 。 但是 ，而 。 这导致 ，产生矛盾。<br>这个矛盾说明，我们最初的假设（存在满足条件的可测集 ）是错误的。<br>结论： 对于 （其中  是胖康托集），不存在可测子集  使得  且  在  上连续。这表明 Lusin 定理的结论不能简单地将“闭集 , ”替换为“可测集 , ”。关键在于 Lusin 定理保证的集合  必须是闭集，这提供了更强的拓扑性质，使得限制在其上的函数得以连续。<br>Exercise.
<img alt="11-hw9-2025050523.png" src="lib\media\11-hw9-2025050523.png">
<br>Definition (近一致收敛).
任给 ，存在  的可测子集 ，使在  上  一致收敛于 ，而 .
<br>(1)<br>
只需要  是可测函数列.
<br>反证而设  a.e. 则存在集合  ，  于 ，且 . 由于  近一致收敛于 ，故存在集合 ，使得<br><br>且 . 断言 ，这是因为若 ，那么 ，故<br><br>矛盾. 故存在 ，这意味着<br><br><br>矛盾！故近一致收敛蕴含几乎处处收敛.<br>Remark.
注意：当  时，几乎处处收敛并不蕴含依测度收敛.
<br>反证而设 , 则存在 ，使得 ，也就是存在 ，使得<br><br>由于  近一致收敛于 ，故存在集合 ，使得<br><br>且 . 也就是存在 ，使得<br><br>我们任取 ，固定  ，由于 , ，那么 , 于是存在 ，故<br><br><br>矛盾！故近一致收敛蕴含依测度收敛.<br>Exercise.
<img alt="9-hw9-2025050523.png" src="lib\media\9-hw9-2025050523.png">
<br>判断：不一定存在这样的连续函数 。<br>Proof.<br>
(举反例) 考虑  的情况。令可测集 。<br>令 为一个“胖”康托集（generalized Cantor set）。这样的集合  具有以下性质：<br>
<br> 是闭集。
<br> 是无处稠密集（nowhere dense），即  的闭包（就是  本身）不包含任何开区间。因此其内部为空。
<br> 的勒贝格测度 。
<br>定义  上的可测函数  为 ，即  的特征函数。<br><br>这个函数  在  上显然是可测的（因为  是闭集，故为可测集），并且几乎处处有限（实际上处处有限，其值仅为0或1）。<br>现在，我们假设存在一个在  上连续的函数 ，使得  与  在  上几乎处处相等。这意味着集合  的勒贝格测度为0。<br>
即 。<br>令 。由于  是闭集且 ，所以  是  中的一个开集（它是一些互不相交的开区间的并集）。<br>
对于 ，我们有 。<br>
由于  在  上几乎处处相等，所以  对于几乎所有  成立。<br>
设 。则 ，所以 。<br>
因此， 在  上成立，其中 。<br>
由于  是连续函数，且  是开集，若  在  的一个具有全测度的子集上为0，则  必须在整个  上为0。<br>
（详细说明：假设存在一点  使得 。由于  连续，存在一个以  为中心的小开区间  使得  对所有  成立。但这意味着 ，这与  对几乎所有  矛盾。因此， 对所有  成立。）<br>因为  是  中的无处稠密集，所以  在  中是稠密的。这意味着  (  在  中的闭包) 包含 。更准确地说， (因为  不包含任何区间，且 )。<br>
对于任何一点 ，由于  是无处稠密集， 是  的一个聚点。因此，存在一个序列 ，其中 ，使得 。<br>
由于  是连续函数，且  对于所有 ，我们有：<br><br>这表明  对于所有  成立。<br>结合  对所有  和  对所有 ，我们得到  对所有  成立。<br>
由于  在  上是连续的，所以  对所有  成立。<br>
也就是说， 对所有  成立。<br>现在我们比较  和  在  上的差异：<br>
<br>
 对于所有 。<br>
那么， 当且仅当 ，这意味着当且仅当 。<br>
所以，集合 。<br>
为了使得  和  在  上几乎处处相等，这个集合的测度必须为0，即 。<br>
但这与我们选择  为一个具有正测度（）的胖康托集相矛盾。<br>因此，我们的初始假设（即存在这样的连续函数 ）是错误的。<br>
所以，不一定存在  上的连续函数  与  在  上几乎处处相等。<br>这个反例可以推广到  ()。例如，取 。令  为如上定义的胖康托集。令 。则  是  中的闭集、无处稠密集，且其  维勒贝格测度 。定义 。通过与上述类似的论证，可以证明不存在满足题设条件的连续函数 。核心步骤是证明若  存在，则  必须在  上为0，进而利用  的连续性推广到  在  上为0，从而导致 ，产生矛盾。<br>
□<br>Exercise.
<img alt="10-hw9-2025050523.png" src="lib\media\10-hw9-2025050523.png">
<br>Proof.<br>
由于  可测，则由 Lusin 引理，存在闭集  和  上的连续函数 ，使得<br><br>于是<br><br>这样构造出一列 ，从而<br><br>由  的任意性可知<br><br>□]]></description><link>实变函数\hw9.html</link><guid isPermaLink="false">实变函数/hw9.md</guid><pubDate>Tue, 06 May 2025 07:17:17 GMT</pubDate><enclosure url="lib\media\hw9-2025050523.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw9-2025050523.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw10]]></title><description><![CDATA[ 
 <br>Exercise.
<img alt="hw10-2025051210.png" src="lib\media\hw10-2025051210.png">
<br>Proof.<br>
Assume that . Since every point in  belongs to at least  of , we have<br><br>Then<br><br><br>By the linearity of integral, <br><br>which is a contradiction.<br>
□<br>Exercise.
<img alt="1-hw10-2025051210.png" src="lib\media\1-hw10-2025051210.png">
<br>Proof.<br>
(1)<br>
, denote , then <br><br>Since ,<br><br>(2)<br><br>□<br>Exercise.
<img alt="3-hw10-2025051210.png" src="lib\media\3-hw10-2025051210.png">
<br>Proof.<br>
Let , then<br><br><br>Since , we have ; and<br><br><br>It suffices to show<br><br>For any , , as  is monotonically increasing, . Similarly, for any , . Thus<br><br>We are done!<br>
□<br>Exercise.
<img alt="4-hw10-2025051210.png" src="lib\media\4-hw10-2025051210.png">
<br>
It's similar to the proof of Egorov theorem.
<br>Proof.<br>
WLOG, assume that  on , and  on , for any ; thus  on . Denote , then <br><br> is measurable, as  are measurable. Construct sets<br><br>Note that given , we have  for any , thus  is descending for each ; then<br><br>Recall the continuity of measure for descending chain, we just need  to show that<a data-footref="[inline0" href="about:blank#fn-1-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a><br><br>
If , then , which is Egorov theorem; if , but  is controlled by , we can also prove .
<br><br>The following steps are routine. <br>For any , there exists  for each , s.t. <br><br>Let , then<br><br>Let , then , we verify that  on .<br>For any given , pick  s.t. . For any ,  for any ; thus ; , i.e. <br><br>i.e.  on . We are done!<br>
□<br>Exercise.
<img alt="5-hw10-2025051210.png" src="lib\media\5-hw10-2025051210.png">
<br>Proof.<br><br><br><br>Then <br><br>□<br>Exercise.
<img alt="6-hw10-2025051210.png" src="lib\media\6-hw10-2025051210.png"><br>
<img alt="7-hw10-2025051210.png" src="lib\media\7-hw10-2025051210.png">
<br>Proof.<br>
(1) false, consider , , . This is true when <br><br>(2) fasle, consider , , . This is true when <br><br>(3) true, if , then <br><br>(4) true, from (3) we know that  a.e. and  a.e. thus  a.e.<br>
□<br>Exercise.
<img alt="8-hw10-2025051210.png" src="lib\media\8-hw10-2025051210.png">
<br>Proof.<br><br>Then <br><br>By Beppo Levi's theorem,<br><br>i.e. <br><br><br>Therefore,<br><br>□<br>Exercise.
<img alt="9-hw10-2025051210.png" src="lib\media\9-hw10-2025051210.png">
<br>Proof.<br><br>□<br>
<br>
<br>we haven't use   till now<a href="about:blank#fnref-1-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>实变函数\hw10.html</link><guid isPermaLink="false">实变函数/hw10.md</guid><pubDate>Mon, 12 May 2025 10:52:52 GMT</pubDate><enclosure url="lib\media\hw10-2025051210.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw10-2025051210.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw11]]></title><description><![CDATA[ 
 <br>Exercise.
<img alt="hw11-2025052017.png" src="lib\media\hw11-2025052017.png">
<br>Proof.<br>
When , , <br><br><br>□<br>Exercise.
<img alt="1-hw11-2025052017.png" src="lib\media\1-hw11-2025052017.png">
<br>Proof.<br>
(1)<br><br>Let , then<br><br>(2)<br>
Claim that<br><br>Case 1: <br>If , then by the definition of the indicator function, .<br>By the definition of the limit inferior of sets, this means there exists a natural number  such that for all <br>If  for all , then  for all <br>Now consider :<br><br>For , we have  Since  for all , the infimum of these values is 1.<br>So, <br>Then,  must be at least 1. Since  values are at most 1, their infima and suprema are also at most 1.<br>Therefore, <br>Thus, if , then <br>Case 2: <br>If , then <br>By the definition of the limit inferior of sets, this means that for every natural number , there exists some  such that .(ie,  is not in all  from any index  onwards; for any  we can find a later  that does not contain <br>If for any , there exists a  such that , then for any , there exists a  such that <br>This implies that for any  (Because if the infimum were 1, all  for  would have to be 1, which contradicts that there's one equal to 0)<br>Now consider <br><br>Since  for all , the supremum of a sequence of zeros is 0.<br>So, <br>Thus, if , then <br><br>By Fatou's lemma,<br><br>Similarly, <br><br>Hence,<br><br>(3)<br>
As  exists, by <a data-href="#^94ba73" href="about:blank#^94ba73" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^94ba73</a><a data-href="#^94ba73" href="about:blank#^94ba73" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a>, <br><br>□<br>Exercise.
<img alt="2-hw11-2025052017.png" src="lib\media\2-hw11-2025052017.png">
<br>Proof.<br>
(1)<br>
By <a data-href="#^94ba73" href="about:blank#^94ba73" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^94ba73</a><a data-href="#^94ba73" href="about:blank#^94ba73" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a>, if , <br><br>which is a contradiction.<br>(2)<br>
If ,<br><br>Then <br><br>which is a contradiction.<br>Exercise.
<img alt="3-hw11-2025052017.png" src="lib\media\3-hw11-2025052017.png">
<br>(1)<br><br>(2)<br><br>Let , then<br><br>Thus<br><br>□<br>Exercise.
<img alt="4-hw11-2025052017.png" src="lib\media\4-hw11-2025052017.png">
<br>Proof.<br>
By the definition of , there exists  s.t. <br><br>, then , thus there exists  s.t.  a.e. by Fatou's lemma,<br><br>□<br>Exercise.
<img alt="5-hw11-2025052017.png" src="lib\media\5-hw11-2025052017.png">
<br>Proof.<br>
By <a data-href="#^5b171e" href="about:blank#^5b171e" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^5b171e</a><a data-href="#^5b171e" href="about:blank#^5b171e" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Exercise 5</a> ,<br><br>As  a.e. on ,<br><br>Then<br><br>On the other hand, as  a.e., we have<br><br>Thus <br><br>exists.<br><br>□<br>Exercise.
<img alt="6-hw11-2025052017.png" src="lib\media\6-hw11-2025052017.png">
<br>Proof.<br>
(1)<br><br>Let  then<br><br>On the other hand, since ,<br><br>Let , then<br><br>Hence,<br><br>(2)<br><br>As  is integrable,  is finite a.e. <br><br>Therefore<br><br>(3)<br><br>□<br>Exercise.
<img alt="7-hw11-2025052017.png" src="lib\media\7-hw11-2025052017.png">
<br>Proof.<br>
For , we have , thus . We need to show that <br><br>By Levi's theorem,<br><br>If , then  or . If , then<br><br>Thus<br><br>If , then<br><br>Thus<br><br>If , then for ,  for any ,  is integrable on . By Lebesgue dominant theorem,<br><br>Then<br><br>□<br>Exercise.
<img alt="8-hw11-2025052017.png" src="lib\media\8-hw11-2025052017.png">
<br>Proof.<br><br>Hence .<br>
□<br>Exercise.
<img alt="9-hw11-2025052017.png" src="lib\media\9-hw11-2025052017.png"><br>
<img alt="hw11-2025052023.png" src="lib\media\hw11-2025052023.png">
<br>Proof.<br>
(1)<br>
The integration of  is defined as<br><br>It makes sense iff the integration of  and  make sense. WLOG, we suppose that  is nonnegative. For ,  on  iff  on . Therefore, by the linearity of the integral of bounded functions of finite support, . <br>If , then . For , , then . By the definition of integral of negative function, . <br>(2)(3)<br>
<img alt="4-hw11-2025052023.png" src="lib\media\4-hw11-2025052023.png"><br>
<img alt="5-hw11-2025052023.png" src="lib\media\5-hw11-2025052023.png"><br>
<img alt="6-hw11-2025052023.png" src="lib\media\6-hw11-2025052023.png"><br><img alt="7-hw11-2025052023.png" src="lib\media\7-hw11-2025052023.png"><br><img alt="8-hw11-2025052023.png" src="lib\media\8-hw11-2025052023.png"><br>□]]></description><link>实变函数\hw11.html</link><guid isPermaLink="false">实变函数/hw11.md</guid><pubDate>Tue, 20 May 2025 15:43:28 GMT</pubDate><enclosure url="lib\media\hw11-2025052017.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw11-2025052017.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw12]]></title><description><![CDATA[ 
 <br>Exercise.
<img alt="hw12-2025052108.png" src="lib\media\hw12-2025052108.png"><br>
<img alt="1-hw12-2025052108.png" src="lib\media\1-hw12-2025052108.png">
<br>(1)<br>
If  on , , then<br><br>Contradiction!<br>(2)<br>
Apply (1).  a.e. on ,  a.e. on ; thus  a.e. on .<br>(3)<br>
Put  in (2), then  a.e. on .<br>Exercise.
<img alt="2-hw12-2025052108.png" src="lib\media\2-hw12-2025052108.png">
<br> iff . As , <br><br><br>, then . <br><br>By DCT,<br><br>Exercise.
<img alt="3-hw12-2025052108.png" src="lib\media\3-hw12-2025052108.png"><br>
<img alt="5-hw12-2025052108.png" src="lib\media\5-hw12-2025052108.png">
<br>(1) 对任意  上可测的 , , 由于 ，则 ，故 ，故  和  不同时为 ，故  有定义. 由于 ，故 ,  有定义. 由于  于 ,  任意，故 ，对右边关于  取下极限，得到 . <br>(2) 考虑 , , . 于是 ,  有定义，其中 , . 因此  不同时为 ,  不同时为 , 故  有意义. 由 (1) 可知 . 故<br>
.<br>(3) 对于数列  ，显然有 ，根据 ,  ，结合 (1)(2) 可知<br><br>Exercise.
<img alt="6-hw12-2025052108.png" src="lib\media\6-hw12-2025052108.png">
<br>类似 <a data-href="#^c2dff9" href="about:blank#^c2dff9" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^c2dff9</a><a data-href="#^c2dff9" href="about:blank#^c2dff9" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Exercise 3</a> 中的讨论，可知  在  上积分有意义，对于非负递增可测函数列 ，我们有 Levi 定理可知 . 由积分的线性性可知<br><br>Exercise.
<img alt="7-hw12-2025052108.png" src="lib\media\7-hw12-2025052108.png">
<br>由比值判别法， 可积. 记  几乎处处收敛于 ，则 , 故 . 令 ，则 , 由比值判别法，. 考虑非负可测函数列 ，它几乎处处收敛于 . 利用 Fatou 引理，, 于是<br><br>于是 . 再考虑非负可测函数列  得到 . 因此 . <br>若 ，对于任意子列 ，存在子列  a.e. 于 . 从而 , . 对于数列 ，它的任意子列  都含有子列 ，不妨考虑  的上下极限序列，它们都含有子列收敛于 ，故 . <br>若 , 同样考虑  的任意子列，再选取子列  使得  a.e. 于 , 重复上述论述即可得证.<br>Exercise.
<img alt="8-hw12-2025052108.png" src="lib\media\8-hw12-2025052108.png">
<br>令 ，于是 ，利用 <a data-href="#^1fa9d0" href="about:blank#^1fa9d0" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^1fa9d0</a><a data-href="#^1fa9d0" href="about:blank#^1fa9d0" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Exercise 5</a> 立得 , 也就是 . <br>Exercise.
<img alt="9-hw12-2025052108.png" src="lib\media\9-hw12-2025052108.png">
<br>若 ，则 . 若 , 注意到 ，由 DCT<br><br>Exercise.
<img alt="10-hw12-2025052108.png" src="lib\media\10-hw12-2025052108.png">
<br>考虑反证，假设 , 则存在  使得<br>
<br>
<br>
<br>
<br>记 . 于是 , 从而存在  使得 ，故<br><br>令 ，就有 , 存在  使得 ，故<br><br>矛盾！<br>Exercise.
<img alt="11-hw12-2025052108.png" src="lib\media\11-hw12-2025052108.png">
<br>, then<br><br>Then . Let , then<br><br>Thus  a.e. on . As , by BCT, <br><br>Since  is nonnegative measurable,  is integrable.]]></description><link>实变函数\hw12.html</link><guid isPermaLink="false">实变函数/hw12.md</guid><pubDate>Wed, 21 May 2025 10:00:16 GMT</pubDate><enclosure url="lib\media\hw12-2025052108.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw12-2025052108.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Invariance of measure]]></title><description><![CDATA[ 
 <br>See royden Chapter 22.]]></description><link>实变函数\invariance-of-measure.html</link><guid isPermaLink="false">实变函数/Invariance of measure.md</guid><pubDate>Fri, 02 May 2025 08:58:52 GMT</pubDate></item><item><title><![CDATA[Lebesgue测度-可测集-测度-Borel集]]></title><description><![CDATA[ 
 <br><br>参见《实变函数解题指南》·周民强.<br><br>Definition (Lebesgue outer measure).
Let . If  is a countable collection of open rectangles in , and

then  is called an -covering of  (obviously there are many such coverings, and each -covering  determines a non-negative generalized real value  (can be ,  represents the volume of ), we call

the Lebesgue outer measure of the point set .
<br>Exercise.
（5）设  ，则存在  的子集  ，使得  ．
<br>Proof.<br>
Let . Then  . Consider  and . Without loss of generality, assume that . Then, by<br><br>we have , that is,<br><br>Similarly, for , we can also prove similar inequalities. In summary, we have<br><br>This indicates that . According to the intermediate value theorem for continuous functions, for , there must exist  such that . Thus, taking  yields the desired result.<br>
□<br>Definition (可数覆盖空间).
设  是一个拓扑空间. 如果存在一个可数集 , 使得  的任何开覆盖都有一个子覆盖, 其元素个数不超过  的元素个数, 那么  被称为可数覆盖空间.
<br>一个拓扑空间  被称为可数覆盖空间, 如果存在一个可数子集 , 使得  的任何开覆盖都有一个子覆盖, 其元素个数不超过  的元素个数. 换句话说, 存在一个可数集合 , 使得对于  的任何开覆盖, 都可以从中选择一个可数子覆盖.<br>
由于  具有可数基, 因此  是第二可数空间. 根据定义, 第二可数空间是 Lindelöf 空间, 这意味着  的每个开覆盖都有一个可数子覆盖. 因此,  是一个可数覆盖空间.<br>Exercise.
（5）设  ．若对任意的  ，存在开球  ，使得  ，则  ．
<br>Proof.<br>
(5) By assumption, there exists a countable cover of  by balls  such that , and . It follows that<br><br>□<br>Proposition.
设  ，且  ，则

<br>Definition (Limit superior and Limit inferior of sets).
Let  be a sequence of sets. The limit superior is defined by

The limit inferior is defined by

<br>Exercise.
（2）设  ．若  ，则  ．
（3）设定义在  上的函数列  满足 

则存在  且  ，使得  ．
<br>Proof.<br>
（2）注意  ，且依题设知，对任给  ，存在  ，使得  ．从而对任意  ，有<br><br>由此知  ．证毕．<br>（3）令  ，则由题设知  ．因此当  时，必存在  ，使得  ．从而有  ．<br>
□<br><br>Definition (Lebesgue 可测集，Carathéodory 条件).
设  ．若对任意的点集  ，有

则称  为 Lebesgue 可测集（或  －可测集），简称为可测集，其中  称为试验集 （这一定义可测集的等式也称为 Carathéodory 条件）；可测集的全体称为可测集类，简记为  ．
<br>Proposition.
设  是可测集列，则  ．
<br>Exercise.
设 ,  的充要条件是：对任给 , 存在可测集 : , 使得 .
<br>Exercise.
（3）设  是  中的可测集列，且满足  ，试证明对任意的  ，必存在  ，使得  ．
<br>Proof.<br>
（3）由题设知，对任意的  ，存在  ，使得<br><br>由此知  ．从而得到<br><br>故有  ．<br>
□<br>Exercise.
（5）设有  中可测集列  ，且当  时， ．若存在  ，试证明： ．
<br>Proof.<br><br>□<br>Exercise.
构造零测的第二纲集.
<br>Proof.<br>
（2）令  ，以及<br><br>则点集  在  中无处稠密. 我们有<br><br> 是第二纲集.<br>
□<br>Exercise.
（3）在  中作点集<br>
 在十进位小数表示式  中的所有  都不出现 10 个数字中的某一个  ，<br>
试证明  是不可数集，且  ．
<br>Proof.<br>
Let  be a set defined as follows:<br><br>where .<br>The set  is constructed by iteratively removing intervals from . In the first step, the interval  is divided into 10 equal subintervals, and the -th subinterval  is removed. This ensures that the remaining points have a decimal expansion where the first digit is not equal to .<br>In the second step, each of the remaining 9 subintervals is divided into 10 equal subintervals, and the -th subinterval is removed from each. This process continues indefinitely.<br>The total length of the removed intervals can be calculated as the sum of a geometric series:<br><br>Since the total length of the intervals removed is 1, the measure of the remaining set  is:<br><br>□<br>Exercise.
（5）将  中的点用十进位小数展开，令

试问：（i） 是闭集？（ii） 是开集？（iii） 是可数集？（iv）  ？ （v） 是可测集？ ？
<br>Proof.<br>
(5) (i) Suppose , and let . If , then  or 7. Hence , i.e.,  is a closed set.<br>(ii) Noticing (i) and , we know that  is not an open set.<br>(iii) .<br>(iv) Since  is a closed set and , we know that  is not dense in .<br>(v)  is a measurable set (see  ). .<br>□<br>Exercise.
（1）设  ，且存在  ，使得对任一区间  ，都有开区间列  ：

则  ．
<br>Proof.<br>
证明（1）因为  ，所以只需指出对任意的  ，有  ．由题设知，存在   ，使得  ．再对每个  作覆盖，其总长度小于  ．依此程序继续作下去，可得 （对任意  ）<br><br>由此易知  ．<br>□<br>Exercise (yau-21-analysis-problem-3).

<br>
For , , show that their convolution  is a well-defined continuous function.

<br>
Let  be a Lebesgue measurable set with Lebesgue measure . Prove that

contains an open neighborhood of .


<br>Proof.<br>
(a) This is standard: In fact, we have . Therefore, by the continuity argument, it suffices to prove the theorem for . In this case, we have<br><br><br>Now let , the integrand converges to 0 uniformly. This yields (a).<br>(b) It suffices to consider the case where . We take , , thus  is a continuous function. In particular, . Therefore, there exists an open set  such that  and  for some . For , by definition,<br><br>Therefore, there must be some , such that . This implies . Hence .<br>
□]]></description><link>实变函数\lebesgue测度-可测集-测度-borel集.html</link><guid isPermaLink="false">实变函数/Lebesgue测度-可测集-测度-Borel集.md</guid><pubDate>Wed, 14 May 2025 14:39:29 GMT</pubDate></item><item><title><![CDATA[Positive definite function]]></title><description><![CDATA[ 
 <br><br>验证：对于正定函数 <br>
<br>.
<br>非负  函数的 Fourier 变换函数是正定函数.
<br>好的，我们来分别验证这两个属性。<br>Definition (正定函数 (Positive Definite Function)).
一个函数  被称为正定函数（或半正定函数，因为通常定义为 ），如果对于任意有限个点  和任意复数 ，都有：<br>
其中  是  的复共轭。
<br>
<br>验证正定函数的复共轭性：
<br>设  是一个正定函数。<br>(a) 首先证明  是实数且 。<br>在正定函数的定义中，取 。则对于任意  和任意 ：<br><br><br>取 ，得到 。由于和式的结果必须是实数（因为它 ），并且  是实数，所以  必须是实数。<br>(b) 证明 。<br>在正定函数的定义中，取 。则对于任意  和任意 ：<br><br><br>令 ，则 。<br><br>因为  是实数，且  和  都是实数（因为  是实数），所以  也必须是实数。即 。<br><br><br>设 ，则 。上式变为：<br><br>现在我们选择特定的  (从而选择特定的 )：<br>
<br>
情况 1： 取 。则 。

令  和 。



所以 。这意味着虚部是奇函数。

<br>
情况 2： 取 。则 。 。

除以 ：



比较实部：


这意味着实部是偶函数。

<br>结合  和 ，我们得到：<br><br>证毕。<br>
<br>验证  函数的傅里叶变换是正定函数 (在  的条件下)
<br>设 。其傅里叶变换定义为：<br><br>我们要验证  是否为正定函数。即，对于任意有限个点  和任意复数 ，验证：<br><br>将  的定义代入：<br><br>由于  且求和是有限的，我们可以交换求和与积分的顺序（Fubini定理）：<br><br>现在处理括号内的双重求和：<br><br><br>注意到 。<br>
所以括号内的和可以写作：<br><br>令 。则上式变为 。<br>
所以，<br><br>这个平方项显然是非负的。<br>
代回到积分表达式  中：<br><br>为了使  对于任意  和  成立，我们需要被积函数  几乎处处成立。<br>
由于  总是成立的，因此，如果  对于几乎所有的  都成立，那么 。<br>结论：<br>
如果  并且  (几乎处处)，那么它的傅里叶变换  是一个正定函数。<br>重要注记：<br>
如果  不满足非负条件，那么  不一定是正定函数。例如，如果  (几乎处处)，那么  将是负定函数（即 ）。Bochner 定理更精确地指出，一个连续函数是正定函数当且仅当它是一个有限非负 Borel 测度的傅里叶变换。对于  且  的情况， 就是这样一个测度。<br>所以，原命题“函数的傅里叶变换是正定函数”需要加上条件“该  函数几乎处处非负”。]]></description><link>实变函数\positive-definite-function.html</link><guid isPermaLink="false">实变函数/positive-definite-function.md</guid><pubDate>Tue, 13 May 2025 06:55:53 GMT</pubDate></item><item><title><![CDATA[Topological preliminaries]]></title><description><![CDATA[ 
 <br><br><br><img alt="Topological preliminaries-20250322.png" src="lib\media\topological-preliminaries-20250322.png"><br><br><img alt="1-Topological preliminaries-20250322.png" src="lib\media\1-topological-preliminaries-20250322.png"><br>
<img alt="2-Topological preliminaries-20250322.png" src="lib\media\2-topological-preliminaries-20250322.png"><br>
Open sets remains to be open under arbitrary unions, while closed sets remains to be closed under arbitrary intersections. Imagine the special case of intervals to remember it.<br>The definition of compact is not technique to prove a set compact but a property.<br><img alt="10-Topological preliminaries-20250322.png" src="lib\media\10-topological-preliminaries-20250322.png"><br>
<img alt="11-Topological preliminaries-20250322.png" src="lib\media\11-topological-preliminaries-20250322.png"><br>Another definition of closure:<br>
<img alt="16-Topological preliminaries-20250322.png" src="lib\media\16-topological-preliminaries-20250322.png"><br><br><img alt="6-Topological preliminaries-20250322.png" src="lib\media\6-topological-preliminaries-20250322.png"><br>
<img alt="8-Topological preliminaries-20250322.png" src="lib\media\8-topological-preliminaries-20250322.png"><br>Definition (relatively open).
Suppose , where  is a metric space. Motivated by the idea that  can also be a metric space, we say  is open relative to  if to each  there is associated an  such that  whenever  and .
<br>A set may be open relative to  without being an open subset of , e.g. .<br>Theorem.
Suppose . A subset  of  is open relative to  iff  for some open subset  of .
<br><a data-href="#^27f07d" href="about:blank#^27f07d" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^27f07d</a><a data-href="#^27f07d" href="about:blank#^27f07d" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 2</a>  can be another definition of relatively open.<br><br>
<br>Every neighborhood is an open set.
<br>If  is a limit point of a set , then every neighborhood of  contains infinitely many points of .
<br>A finite point set has no limit points.
<br>Closed subsets of compact sets are compact.
<br>Perfect set in  is uncountable.
<br>If  is a collection of compact subsets of a metric space  such that the intersection of every finite subcollection of  is nonempty, then  is nonempty.
<br>If  is a decreasing sequence of nonempty compact sets, then  is not empty.
<br><br><img alt="9-Topological preliminaries-20250322.png" src="lib\media\9-topological-preliminaries-20250322.png"><br><br>Theorem (Heine-Borel theorem).
The compact subsets of a enclidean space  are precisely those that are closed and bounded. 
<br>Moreover, the theorem is true for any locally compact Hausdorff space. Note that metric spaces are locally compact Hausdorff space.<br>Theorem (Closed subsets of compact sets are compact.).
Suppoes  is compact and  is closed, in a topological space . If  then  is compact.
<br>Proof.<br>
If  is an open cover of  and  then  covers ; hence there is a finite collection  such that <br><br>Then .<br>
□<br>Corollary.
If  and if  has compact closure, so does .
<br>Theorem.
 hausdorff, ,  compact, and . Then there are open sets  and  such that , , and .
<br>Proof.<br>
If , the Hausdorff separation axiom implies the existence of disjoint open sets  and  such that  and . Since  is compact, there are points  such that<br><br>Our requirements are then satisfied by the sets<br><br>□<br>Corollary.
Compact subsets of Hausdorff spaces are closed. (the inverse is not true.)
<br>Corollary.
If  closed,  compact in a Hausdorff space, then  is compact.
<br><img alt="4-Topological preliminaries-20250322.png" src="lib\media\4-topological-preliminaries-20250322.png"><br>
Use the definition of compact set.<br><img alt="5-Topological preliminaries-20250322.png" src="lib\media\5-topological-preliminaries-20250322.png"><br>
Use the definition of compact set.<br><br>See Royden Chapter 11.<br><br><img alt="12-Topological preliminaries-20250322.png" src="lib\media\12-topological-preliminaries-20250322.png"><br>
<img alt="13-Topological preliminaries-20250322.png" src="lib\media\13-topological-preliminaries-20250322.png"><br>
<img alt="15-Topological preliminaries-20250322.png" src="lib\media\15-topological-preliminaries-20250322.png"><br><br>
<br>The Tychonoff Separation Property:

<br>For each two points  and  in , there is a neighborhood of  that does not contain  and a neighborhood of  that does not contain .


<br>The Hausdorff Separation Property: 

<br>Each two points in  can be separated by disjoint neighborhoods.


<br>The Regular Separation Property: 

<br>The Tychonoff separation property holds and, moreover, each closed set and point not in the set can be separated by disjoint neighborhoods.


<br>The Normal Separation Property: 

<br>The Tychonoff separation property holds and, moreover, each two disjoint closed sets can be separated by disjoint neighborhoods.


<br><img alt="17-Topological preliminaries-20250322.png" src="lib\media\17-topological-preliminaries-20250322.png"><br>Proposition.
A topological space  is a Tychonoff space iff every set consisting of a single point is closed.
<br>Proposition.
Every metric space is normal.
<br>Proposition.
Let  be Tychonoff. Then  is normal iff whenever  is a neighborhood of a closed subset  of , there is another neighborhood of  whose closure is contained in , that is, there is an open set  for which<br>

<br><br><img alt="18-Topological preliminaries-20250322.png" src="lib\media\18-topological-preliminaries-20250322.png"><br>
<img alt="19-Topological preliminaries-20250322.png" src="lib\media\19-topological-preliminaries-20250322.png"><br>In a topological space that is not first countable, it is possible for a point to be a point of closure of a set and yet no sequence in the set converges to the point.<br><img alt="20-Topological preliminaries-20250322.png" src="lib\media\20-topological-preliminaries-20250322.png"><br>
<img alt="21-Topological preliminaries-20250322.png" src="lib\media\21-topological-preliminaries-20250322.png"><br><br><img alt="22-Topological preliminaries-20250322.png" src="lib\media\22-topological-preliminaries-20250322.png"><br>
<img alt="23-Topological preliminaries-20250322.png" src="lib\media\23-topological-preliminaries-20250322.png"><br>
<img alt="24-Topological preliminaries-20250322.png" src="lib\media\24-topological-preliminaries-20250322.png"><br><br><img alt="25-Topological preliminaries-20250322.png" src="lib\media\25-topological-preliminaries-20250322.png"><br>
In view of the definition of the subspace topology, a subset  of  is compact provided every covering of  by a collection of open subsets of  has a finite subcover.<br>Definition (finite intersection property).
A collection of sets is said to be finite intersection property provided every finite subcollection has nonempty intersection.
<br><img alt="26-Topological preliminaries-20250322.png" src="lib\media\26-topological-preliminaries-20250322.png"><br><img alt="27-Topological preliminaries-20250322.png" src="lib\media\27-topological-preliminaries-20250322.png"><br><img alt="28-Topological preliminaries-20250322.png" src="lib\media\28-topological-preliminaries-20250322.png"><br><img alt="29-Topological preliminaries-20250322.png" src="lib\media\29-topological-preliminaries-20250322.png"><br><img alt="30-Topological preliminaries-20250322.png" src="lib\media\30-topological-preliminaries-20250322.png"><br><img alt="31-Topological preliminaries-20250322.png" src="lib\media\31-topological-preliminaries-20250322.png"><br>Additionally, homeomorphism requires continuous inverse, so hypothesis upon space is neccessary.<br><img alt="32-Topological preliminaries-20250322.png" src="lib\media\32-topological-preliminaries-20250322.png"><br>Regard a compact set as a compact topological space...<br>
<img alt="33-Topological preliminaries-20250322.png" src="lib\media\33-topological-preliminaries-20250322.png"><br>Definition (countably compact).
A topological space is said to be countably compact provided every countable open cover has a finite subcover.
<br><br>Definition (separate).
Two nonempty open subsets of a topological spaces  are said to separate  if they are disjoint and their union is . 
<br>Definition (connected).
A topological space which cannot be separated by such a pair is said to be connected. 
<br>Connectness is preserved under continuous mapping.<br>
<img alt="34-Topological preliminaries-20250322.png" src="lib\media\34-topological-preliminaries-20250322.png"><br>For a set  of real number, the following are equivalent:<br>
<br> is an interval.
<br> is convex.
<br> is connected.
<br><img alt="35-Topological preliminaries-20250322.png" src="lib\media\35-topological-preliminaries-20250322.png"><br>
<img alt="36-Topological preliminaries-20250322.png" src="lib\media\36-topological-preliminaries-20250322.png"><br>]]></description><link>实变函数\topological-preliminaries.html</link><guid isPermaLink="false">实变函数/Topological-preliminaries.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\topological-preliminaries-20250322.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\topological-preliminaries-20250322.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[二叉树]]></title><description><![CDATA[ 
 <br><br><br>好的，我们来解释一下完全二叉树（Complete Binary Tree）。<br>在了解完全二叉树之前，先回顾一下满二叉树（Full Binary Tree）和完美二叉树（Perfect Binary Tree）：<br>
<br>满二叉树： 除了叶子节点外，所有节点都有两个子节点。
<br>完美二叉树： 是一种特殊的满二叉树，所有叶子节点都在同一层，并且所有内部节点都有两个子节点。完美二叉树的形状是一个完全对称的三角形。
<br>现在来说完全二叉树：<br>完全二叉树是指这样一种二叉树：<br>
<br>除最后一层外，所有层都是完全填满的。
<br>最后一层上的节点从左到右依次排列，不能有空缺。也就是说，如果最后一层不满，那么节点必须连续地靠左排列。
<br>关键特点：<br>
<br>它的节点分布非常紧凑，除了最后一层，每一层都达到最大节点数。
<br>最后一层的节点尽可能靠左。
<br>举例说明：<br>这是一个完全二叉树：<br>      A
     / \
    B   C
   / \ /
  D   E F
<br>解释：第0层 (A) 是满的，第1层 (B, C) 是满的，第2层 (D, E, F) 是最后一层，虽然不满，但节点从左到右是连续排列的 (D、E 在左子树，F 在右子树且靠左)。<br>这不是一个完全二叉树（因为最后一层有空缺，且不是最右边的空缺）：<br>      A
     / \
    B   C
   / \   \
  D   E   G
<br>解释：节点 F 缺失了，导致最后一层的节点 E 和 G 之间有空缺。<br>这不是一个完全二叉树（因为倒数第二层不满）：<br>      A
     /
    B
   / \
  C   D
<br>解释：第1层只 B 一个节点，没有右子节点 C 的位置（如果是完全二叉树，C 应该在 B 的右边或者 B 的左子树被填满后才到 C），直接跳到了第2层。<br>为什么完全二叉树很重要？<br>完全二叉树的一个重要特性是它们可以非常高效地用数组来表示，而不需要使用指针。<br>
<br>如果根节点存储在数组索引 0 (或 1) 的位置，那么它的左子节点将存储在索引 2 * i + 1 (或 2 * i) 的位置，右子节点存储在索引 2 * i + 2 (或 2 * i + 1) 的位置（取决于数组从 0 还是 1 开始索引）。
<br>反过来，对于索引为 i 的非根节点，其父节点存储在索引 (i - 1) / 2 (或 i / 2) 的位置。
<br>这种基于数组的表示使得完全二叉树成为实现堆（Heap）数据结构的最佳选择，因为堆需要快速访问父子节点，并且需要紧凑地存储数据。<br>简而言之，完全二叉树是一种结构紧凑、节点靠左排列的二叉树，它非常适合用数组存储，常用于实现堆。完美二叉树和满二叉树都是完全二叉树的特例。<br><br>对于二叉树：<br>    A
   / \
  B   C
 / \
D   E
<br>
<br>前序遍历：根左右

<br>对于上述二叉树，前序遍历的结果是：A, B, D, E, C


<br>中序遍历：左根右

<br>对于上述二叉树，中序遍历的结果是：D, B, E, A, C


<br>后序遍历：左右根

<br>对于上述二叉树，后序遍历的结果是：D, E, B, C, A


<br>
前序遍历加上中序遍历序列，可以唯一确定一颗二叉树.
<br><br>好的，将一颗完全二叉树存储到数组（或 C++中的 std::vector）中，利用了完全二叉树的紧凑性，使得节点位置和数组索引之间存在固定的数学关系。<br>最常用的映射方式是：<br>
<br>如果根节点存储在索引 i (通常是 0 或 1) 的位置。
<br>那么它的左子节点存储在索引 2 * i + 1 的位置（如果从 0 开始索引）。
<br>它的右子节点存储在索引 2 * i + 2 的位置（如果从 0 开始索引）。
<br>反过来，对于非根节点存储在索引 i 的位置，它的父节点存储在索引 (i - 1) / 2 的位置（如果从 0 开始索引，且 i &gt; 0）。
<br>由于完全二叉树除了最后一层外都是满的，且最后一层节点靠左排列，这意味着如果一棵完全二叉树有 N 个节点，那么它们可以恰好填满数组的前 N 个位置，而不会有空缺（前提是按照层序从左到右排列）。<br>因此，将完全二叉树存入数组最直接的方法就是进行层序遍历（Level-Order Traversal），并依次将遍历到的节点值存入数组。层序遍历通常使用队列（Queue）来实现。<br>下面是一个使用 C++ 语言，将一个给定根节点的完全二叉树存储到 std::vector 中的程序示例：<br>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;cmath&gt; // for calculating parent/child index if needed, but direct level-order filling is easier

// 定义二叉树的节点结构
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

// 函数：将完全二叉树存储到 vector 中
std::vector&lt;int&gt; storeCompleteBinaryTree(TreeNode* root) {
    std::vector&lt;int&gt; result; // 用于存储节点值的vector
    if (root == NULL) {
        return result; // 如果树为空，返回空vector
    }

    // 使用队列进行层序遍历
    std::queue&lt;TreeNode*&gt; q;
    q.push(root);

    while (!q.empty()) {
        TreeNode* current = q.front();
        q.pop();

        // 将当前节点的值存入 vector
        result.push_back(current-&gt;val);

        // 将当前节点的左孩子入队
        // 对于完全二叉树的数组表示，即使某个位置理论上是左孩子，
        // 但如果原始树中该节点不存在，我们也不会将其加入队列或vector。
        // 这里我们假设输入的TreeNode结构已经代表了一棵完全二叉树的结构。
        if (current-&gt;left != NULL) {
            q.push(current-&gt;left);
        }

        // 将当前节点的右孩子入队
        if (current-&gt;right != NULL) {
            q.push(current-&gt;right);
        }
    }

    return result;
}

// 辅助函数：创建一个示例完全二叉树
// 结构:
//       1
//      / \
//     2   3
//    / \ /
//   4   5 6
TreeNode* createExampleCompleteBinaryTree() {
    TreeNode* root = new TreeNode(1);
    root-&gt;left = new TreeNode(2);
    root-&gt;right = new TreeNode(3);
    root-&gt;left-&gt;left = new TreeNode(4);
    root-&gt;left-&gt;right = new TreeNode(5);
    root-&gt;right-&gt;left = new TreeNode(6);
    // 注意：这里特意不创建右子树的右孩子(7)，使其成为非完美的完全二叉树
    return root;
}

// 辅助函数：释放树的内存
void deleteTree(TreeNode* root) {
    if (root == NULL) return;
    deleteTree(root-&gt;left);
    deleteTree(root-&gt;right);
    delete root;
}


int main() {
    // 创建一个示例完全二叉树
    TreeNode* root = createExampleCompleteBinaryTree();

    // 将完全二叉树存储到 vector
    std::vector&lt;int&gt; treeArray = storeCompleteBinaryTree(root);

    // 打印存储在 vector 中的节点值
    std::cout &lt;&lt; "完全二叉树存储在数组中的顺序 (层序遍历): ";
    for (int i = 0; i &lt; treeArray.size(); ++i) {
        std::cout &lt;&lt; treeArray[i] &lt;&lt; (i == treeArray.size() - 1 ? "" : " ");
    }
    std::cout &lt;&lt; std::endl;

    // 验证数组索引和节点位置的关系 (例如，索引0的左孩子在索引1，右孩子在索引2)
    if (!treeArray.empty()) {
         std::cout &lt;&lt; "--- 验证索引关系 (0-based) ---" &lt;&lt; std::endl;
         std::cout &lt;&lt; "节点 " &lt;&lt; treeArray[0] &lt;&lt; " (索引 0):" &lt;&lt; std::endl;
         if (2*0 + 1 &lt; treeArray.size()) {
             std::cout &lt;&lt; "  左孩子 (索引 1): " &lt;&lt; treeArray[2*0 + 1] &lt;&lt; std::endl;
         }
         if (2*0 + 2 &lt; treeArray.size()) {
             std::cout &lt;&lt; "  右孩子 (索引 2): " &lt;&lt; treeArray[2*0 + 2] &lt;&lt; std::endl;
         }

         if (treeArray.size() &gt; 1) {
             std::cout &lt;&lt; "节点 " &lt;&lt; treeArray[1] &lt;&lt; " (索引 1):" &lt;&lt; std::endl;
              std::cout &lt;&lt; "  父节点 (索引 0): " &lt;&lt; treeArray[(1 - 1) / 2] &lt;&lt; std::endl;
              if (2*1 + 1 &lt; treeArray.size()) {
                  std::cout &lt;&lt; "  左孩子 (索引 3): " &lt;&lt; treeArray[2*1 + 1] &lt;&lt; std::endl;
              }
              if (2*1 + 2 &lt; treeArray.size()) {
                  std::cout &lt;&lt; "  右孩子 (索引 4): " &lt;&lt; treeArray[2*1 + 2] &lt;&lt; std::endl;
              }
         }
          if (treeArray.size() &gt; 2) {
             std::cout &lt;&lt; "节点 " &lt;&lt; treeArray[2] &lt;&lt; " (索引 2):" &lt;&lt; std::endl;
              std::cout &lt;&lt; "  父节点 (索引 0): " &lt;&lt; treeArray[(2 - 1) / 2] &lt;&lt; std::endl;
              if (2*2 + 1 &lt; treeArray.size()) {
                  std::cout &lt;&lt; "  左孩子 (索引 5): " &lt;&lt; treeArray[2*2 + 1] &lt;&lt; std::endl;
              }
              if (2*2 + 2 &lt; treeArray.size()) {
                  std::cout &lt;&lt; "  右孩子 (索引 6): " &lt;&lt; treeArray[2*2 + 2] &lt;&lt; std::endl; // 这里会输出 6
              }
         }
           if (treeArray.size() &gt; 3) {
             std::cout &lt;&lt; "节点 " &lt;&lt; treeArray[3] &lt;&lt; " (索引 3):" &lt;&lt; std::endl;
              std::cout &lt;&lt; "  父节点 (索引 1): " &lt;&lt; treeArray[(3 - 1) / 2] &lt;&lt; std::endl;
              // Left and Right children checks...
         }
    }


    // 释放内存
    deleteTree(root);

    return 0;
}
<br>代码解释：<br>
<br>TreeNode 结构体： 定义了二叉树节点的基本结构，包含一个值 (val) 和指向左右子节点的指针 (left, right)。
<br>storeCompleteBinaryTree 函数：

<br>接收 TreeNode* root 作为输入（树的根节点）。
<br>创建一个 std::vector&lt;int&gt; 叫做 result 用来存放遍历结果。
<br>如果输入的 root 是 NULL (空树)，直接返回空的 result。
<br>创建一个 std::queue&lt;TreeNode*&gt; 队列 q，用于实现层序遍历。
<br>将根节点 root 入队。
<br>进入 while 循环，当队列不为空时继续：

<br>取出队列头部的节点 (current) 并出队。
<br>将 current 节点的值 (current-&gt;val) 添加到 result 向量的末尾。
<br>如果 current 的左子节点 current-&gt;left 不为空，将其入队。
<br>如果 current 的右子节点 current-&gt;right 不为空，将其入队。


<br>循环结束后，result 向量中就按层序从左到右存储了完全二叉树所有节点的值。
<br>返回 result 向量。


<br>createExampleCompleteBinaryTree 函数： 这是一个辅助函数，用于手动构建一个符合完全二叉树定义的示例树，方便测试。
<br>deleteTree 函数： 辅助函数，用于递归地删除树节点，释放内存，防止内存泄漏。
<br>main 函数：

<br>调用 createExampleCompleteBinaryTree 创建示例树。
<br>调用 storeCompleteBinaryTree 函数将树存储到 treeArray 向量中。
<br>打印 treeArray 的内容，展示存储结果。
<br>演示了如何根据数组索引计算父子节点的索引，并打印出对应的值，验证了完全二叉树的数组索引特性。
<br>调用 deleteTree 释放内存。


<br>运行此程序，你将看到完全二叉树的节点值按照层序从左到右的顺序被打印出来，并验证了父子节点在数组中的索引关系。<br><br><br>存储两个孩子<br>找双亲的时间复杂度为 ，找孩子的时间复杂度为 .<br><br>存储两个孩子和一个双亲<br><br>例如创建下面的二叉树：<br>    A
   / \
  B   C
   \
    D
<br>使用前序遍历创建的过程：<br>
<br>输入前序序列：A B # D # # C # #，每次输入一个字符

<br>输入 A：创建根节点 A
<br>递归创建 A 的左子树:

<br>输入 B：创建节点 B 作为 A 的左子节点
<br>递归创建 B 的左子树:

<br>输入#：B 的左子节点为 NULL


<br>递归创建 B 的右子树:

<br>输入 D：创建节点 D 作为 B 的右子节点
<br>递归创建 D 的左子树:

<br>输入#：D 的左子节点为 NULL


<br>递归创建 D 的右子树:

<br>输入#：D 的右子节点为 NULL






<br>递归创建 A 的右子树:

<br>输入 C：创建节点 C 作为 A 的右子节点
<br>递归创建 C 的左子树:

<br>输入#：C 的左子节点为 NULL


<br>递归创建 C 的右子树:

<br>输入#：C 的右子节点为 NULL






<br>这样，通过序列 A B # D # # C # # 就完成了整棵二叉树的创建。<br><br>举例说明 root 的作用：<br>假设我们创建一棵如下的二叉树：<br>    A
   / \
  B   C
<br>
<br>
创建过程：

<br>构造函数BiTree()调用Creat(root)
<br>用户输入A B # # C # #
<br>Creat函数递归构建树并返回指向根节点A的指针
<br>这个指针被赋值给root


<br>
访问和遍历：

<br>执行T.PreOrder()时，内部会调用PreOrder(root)
<br>root作为起点，从A开始访问整棵树
<br>如果没有root，就无法知道从哪里开始遍历


<br>
树的判空：
if (root == NULL) return; //判断是否为空树


<br>
内存释放：

<br>析构函数调用Release(root)
<br>从root开始递归释放所有节点内存


<br>root 就像是树的"把手"，有了它才能对整棵树进行操作。如果 root 丢失，即使树的节点还存在内存中，也无法访问到它们，会导致内存泄漏<br>。<br><br><br>是的，通过后序遍历和中序遍历序列可以唯一地确定一棵二叉树。<br>核心思想：<br>
<br>后序遍历 (Left-Right-Root)： 序列的最后一个元素一定是当前（子）树的根节点。
<br>中序遍历 (Left-Root-Right)： 一旦找到了根节点，那么在在中序遍历序列中，根节点左边的所有元素都属于左子树，右边的所有元素都属于右子树。
<br>步骤：<br>假设我们有后序遍历序列 postOrder 和中序遍历序列 inOrder。<br>
<br>
确定根节点：

<br>postOrder 的最后一个元素就是整棵树的根节点。设这个根节点为 rootVal。


<br>
划分左右子树：

<br>在 inOrder 序列中找到 rootVal 的位置。
<br>inOrder 中 rootVal 左边的所有元素构成了左子树的中序遍历序列 (leftInOrder)。
<br>inOrder 中 rootVal 右边的所有元素构成了右子树的中序遍历序列 (rightInOrder)。


<br>
确定左右子树的后序遍历序列：

<br>左子树的节点数量等于 leftInOrder 的长度。设为 leftTreeSize。
<br>右子树的节点数量等于 rightInOrder 的长度。设为 rightTreeSize。
<br>在 postOrder 序列中（除去最后一个根节点 rootVal）：

<br>前 leftTreeSize 个元素构成了左子树的后序遍历序列 (leftPostOrder)。
<br>接下来的 rightTreeSize 个元素构成了右子树的后序遍历序列 (rightPostOrder)。




<br>
递归构建：

<br>现在我们有了左子树的 leftPostOrder 和 leftInOrder，以及右子树的 rightPostOrder 和 rightInOrder。
<br>递归地对左子树和右子树执行上述步骤，直到处理的序列为空（表示子树为空）。
<br>将递归构建出的左子树连接到根节点的左孩子，右子树连接到根节点的右孩子。


<br>举例说明：<br>假设：<br>
<br>后序遍历 (postOrder): [D, E, B, F, G, C, A]
<br>中序遍历 (inOrder): [D, B, E, A, F, C, G]
<br>构建过程：<br>
<br>
第一次递归 (构建整棵树):

<br>根节点: postOrder 的最后一个元素是 A。所以 A 是根。
<br>划分中序: 在 inOrder [D, B, E, A, F, C, G] 中，A 的位置：

<br>leftInOrder = [D, B, E] (左子树的中序遍历)
<br>rightInOrder = [F, C, G] (右子树的中序遍历)


<br>划分后序:

<br>左子树节点数 leftTreeSize = 3 (来自 leftInOrder 的长度)。
<br>右子树节点数 rightTreeSize = 3 (来自 rightInOrder 的长度)。
<br>postOrder (除去 A) 是 [D, E, B, F, G, C]。
<br>leftPostOrder = [D, E, B] (前 3 个元素)
<br>rightPostOrder = [F, G, C] (后 3 个元素)


<br>现在，根节点 A 的左孩子通过 leftPostOrder: [D, E, B] 和 leftInOrder: [D, B, E] 构建。
<br>根节点 A 的右孩子通过 rightPostOrder: [F, G, C] 和 rightInOrder: [F, C, G] 构建。


<br>
第二次递归 (构建 A 的左子树):

<br>输入: postOrder_L = [D, E, B], inOrder_L = [D, B, E]
<br>根节点: postOrder_L 的最后一个元素是 B。所以 B 是该子树的根。
<br>划分中序: 在 inOrder_L [D, B, E] 中，B 的位置：

<br>leftInOrder_L_sub = [D]
<br>rightInOrder_L_sub = [E]


<br>划分后序:

<br>左子树节点数 = 1。右子树节点数 = 1。
<br>postOrder_L (除去 B) 是 [D, E]。
<br>leftPostOrder_L_sub = [D]
<br>rightPostOrder_L_sub = [E]


<br>B 的左孩子通过 post: [D], in: [D] 构建。
<br>B 的右孩子通过 post: [E], in: [E] 构建。


<br>
第三次递归 (构建 B 的左子树):

<br>输入: postOrder = [D], inOrder = [D]
<br>根节点: D。
<br>划分中序: leftInOrder 为空，rightInOrder 为空。
<br>D 是叶子节点。返回 D。


<br>
第三次递归 (构建 B 的右子树):

<br>输入: postOrder = [E], inOrder = [E]
<br>根节点: E。
<br>划分中序: leftInOrder 为空，rightInOrder 为空。
<br>E 是叶子节点。返回 E。
<br>此时，B 的左右孩子都已确定：B 的左孩子是 D，右孩子是 E。


<br>
第二次递归 (构建 A 的右子树):

<br>输入: postOrder_R = [F, G, C], inOrder_R = [F, C, G]
<br>根节点: postOrder_R 的最后一个元素是 C。所以 C 是该子树的根。
<br>划分中序: 在 inOrder_R [F, C, G] 中，C 的位置：

<br>leftInOrder_R_sub = [F]
<br>rightInOrder_R_sub = [G]


<br>划分后序:

<br>左子树节点数 = 1。右子树节点数 = 1。
<br>postOrder_R (除去 C) 是 [F, G]。
<br>leftPostOrder_R_sub = [F]
<br>rightPostOrder_R_sub = [G]


<br>C 的左孩子通过 post: [F], in: [F] 构建 (得到叶子节点 F)。
<br>C 的右孩子通过 post: [G], in: [G] 构建 (得到叶子节点 G)。
<br>此时，C 的左右孩子都已确定：C 的左孩子是 F，右孩子是 G。


<br>最终结果：<br>将所有构建好的子树连接起来，得到的二叉树结构如下：<br>      A
     / \
    B   C
   / \ / \
  D  E F  G
<br>这个过程通常用递归函数来实现，基本情况是当传入的遍历序列为空时，返回 null (或表示空子树的标记)。<br><br>是的，通过前序遍历和中序遍历序列同样可以唯一地确定一棵二叉树。<br>核心思想：<br>
<br>前序遍历 (Root-Left-Right)： 序列的第一个元素一定是当前（子）树的根节点。
<br>中序遍历 (Left-Root-Right)： 一旦找到了根节点，那么在中序遍历序列中，根节点左边的所有元素都属于左子树，右边的所有元素都属于右子树。
<br>步骤：<br>假设我们有前序遍历序列 preOrder 和中序遍历序列 inOrder。<br>
<br>
确定根节点：

<br>preOrder 的第一个元素就是整棵树的根节点。设这个根节点为 rootVal。


<br>
划分左右子树（在中序遍历中）：

<br>在 inOrder 序列中找到 rootVal 的位置。
<br>inOrder 中 rootVal 左边的所有元素构成了左子树的中序遍历序列 (leftInOrder)。
<br>inOrder 中 rootVal 右边的所有元素构成了右子树的中序遍历序列 (rightInOrder)。


<br>
确定左右子树的前序遍历序列：

<br>左子树的节点数量等于 leftInOrder 的长度。设为 leftTreeSize。
<br>右子树的节点数量等于 rightInOrder 的长度。
<br>在 preOrder 序列中（除去第一个根节点 rootVal）：

<br>接下来的 leftTreeSize 个元素构成了左子树的前序遍历序列 (leftPreOrder)。
<br>再往后的元素构成了右子树的前序遍历序列 (rightPreOrder)。




<br>
递归构建：

<br>现在我们有了左子树的 leftPreOrder 和 leftInOrder，以及右子树的 rightPreOrder 和 rightInOrder。
<br>递归地对左子树和右子树执行上述步骤，直到处理的序列为空（表示子树为空）。
<br>将递归构建出的左子树连接到根节点的左孩子，右子树连接到根节点的右孩子。


<br>举例说明：<br>假设：<br>
<br>前序遍历 (preOrder): [A, B, D, E, C, F, G]
<br>中序遍历 (inOrder): [D, B, E, A, F, C, G]
<br>构建过程：<br>
<br>
第一次递归 (构建整棵树):

<br>根节点: preOrder 的第一个元素是 A。所以 A 是根。
<br>划分中序: 在 inOrder [D, B, E, A, F, C, G] 中，A 的位置：

<br>leftInOrder = [D, B, E] (左子树的中序遍历)
<br>rightInOrder = [F, C, G] (右子树的中序遍历)


<br>划分前序:

<br>左子树节点数 leftTreeSize = 3 (来自 leftInOrder 的长度)。
<br>preOrder (除去 A) 是 [B, D, E, C, F, G]。
<br>leftPreOrder = [B, D, E] (接下来的 3 个元素)
<br>rightPreOrder = [C, F, G] (剩下的元素)


<br>现在，根节点 A 的左孩子通过 leftPreOrder: [B, D, E] 和 leftInOrder: [D, B, E] 构建。
<br>根节点 A 的右孩子通过 rightPreOrder: [C, F, G] 和 rightInOrder: [F, C, G] 构建。


<br>
第二次递归 (构建 A 的左子树):

<br>输入: preOrder_L = [B, D, E], inOrder_L = [D, B, E]
<br>根节点: preOrder_L 的第一个元素是 B。所以 B 是该子树的根。
<br>划分中序: 在 inOrder_L [D, B, E] 中，B 的位置：

<br>leftInOrder_L_sub = [D]
<br>rightInOrder_L_sub = [E]


<br>划分前序:

<br>左子树节点数 = 1。
<br>preOrder_L (除去 B) 是 [D, E]。
<br>leftPreOrder_L_sub = [D] (接下来的 1 个元素)
<br>rightPreOrder_L_sub = [E] (剩下的元素)


<br>B 的左孩子通过 pre: [D], in: [D] 构建。
<br>B 的右孩子通过 pre: [E], in: [E] 构建。


<br>
第三次递归 (构建 B 的左子树):

<br>输入: preOrder = [D], inOrder = [D]
<br>根节点: D。
<br>划分中序: leftInOrder 为空，rightInOrder 为空。
<br>D 是叶子节点。返回 D。


<br>
第三次递归 (构建 B 的右子树):

<br>输入: preOrder = [E], inOrder = [E]
<br>根节点: E。
<br>划分中序: leftInOrder 为空，rightInOrder 为空。
<br>E 是叶子节点。返回 E。
<br>此时，B 的左右孩子都已确定：B 的左孩子是 D，右孩子是 E。


<br>
第二次递归 (构建 A 的右子树):

<br>输入: preOrder_R = [C, F, G], inOrder_R = [F, C, G]
<br>根节点: preOrder_R 的第一个元素是 C。所以 C 是该子树的根。
<br>划分中序: 在 inOrder_R [F, C, G] 中，C 的位置：

<br>leftInOrder_R_sub = [F]
<br>rightInOrder_R_sub = [G]


<br>划分前序:

<br>左子树节点数 = 1。
<br>preOrder_R (除去 C) 是 [F, G]。
<br>leftPreOrder_R_sub = [F] (接下来的 1 个元素)
<br>rightPreOrder_R_sub = [G] (剩下的元素)


<br>C 的左孩子通过 pre: [F], in: [F] 构建 (得到叶子节点 F)。
<br>C 的右孩子通过 pre: [G], in: [G] 构建 (得到叶子节点 G)。
<br>此时，C 的左右孩子都已确定：C 的左孩子是 F，右孩子是 G。


<br>最终结果：<br>将所有构建好的子树连接起来，得到的二叉树结构如下：<br>      A
     / \
    B   C
   / \ / \
  D  E F  G
<br>这个过程与使用后序和中序遍历构建树非常相似，主要的区别在于从哪个遍历序列中取根节点（前序是第一个，后序是最后一个），以及如何根据根节点和中序遍历划分对应遍历序列中的子序列。<br><br>让我们来看一个例子：<br>情况 1： 树 A:<br>    1
   /
  2
<br>
<br>前序遍历: [1, 2]
<br>后序遍历: [2, 1]
<br>情况 2： 树 B:<br>    1
     \
      2
<br>
<br>前序遍历: [1, 2]
<br>后序遍历: [2, 1]
<br>对于这两棵不同的树，它们的前序遍历和后序遍历结果是完全相同的。因此，仅给出前序 [1, 2] 和后序 [2, 1]，我们无法判断节点 2 究竟是节点 1 的左孩子还是右孩子。]]></description><link>数据结构\二叉树.html</link><guid isPermaLink="false">数据结构/二叉树.md</guid><pubDate>Wed, 14 May 2025 07:47:19 GMT</pubDate></item><item><title><![CDATA[课程云盘]]></title><description><![CDATA[ 
 <br>
<br>https://imathcloud.quickconnect.cn
<br>user: DataStru
<br>password: Math.DS2025
]]></description><link>数据结构\课程云盘.html</link><guid isPermaLink="false">数据结构/课程云盘.md</guid><pubDate>Fri, 02 May 2025 08:58:53 GMT</pubDate></item><item><title><![CDATA[图论]]></title><description><![CDATA[ 
 <br><br>本复习资料旨在为学习数据结构与算法课程的本科生提供一份关于图论的全面指导。内容涵盖图的基本概念、常用表示方法、核心遍历算法、最小生成树、最短路径问题、拓扑排序以及环检测等。每个主题都配有生动详尽的说明和C++代码示例，以帮助深入理解并有效备考。<br>I. 图论基础 (Introduction to Graphs)<br>图论是计算机科学中一个至关重要的分支，它为建模和解决涉及对象及其关系的问题提供了一个强大的数学框架。<br>A. 什么是图？ (What is a Graph?)<br>顶点 (Vertices) 与边 (Edges)：从根本上说，一个图 (Graph) 是由两个集合组成的：一个非空顶点集合  (Vertices 或 Nodes) 和一个边集合  (Edges)。数学上，一个图  可以表示为 . 顶点代表图中的基本单元或实体，例如城市、人或网页。边则代表这些实体之间的连接或关系，例如连接城市的道路、人与人之间的友谊或网页之间的超链接。理解这两个基本构成元素——顶点和边——是掌握后续所有图论概念和算法的基石。<br>图的实际应用举例：图的抽象模型使其能够广泛应用于现实世界的多种场景中。例如：<br>
<br>社交网络：用户是顶点，用户之间的好友或关注关系是边。
<br>交通网络：城市或交叉路口是顶点，连接它们的公路或航线是边，边的权重可以表示距离或时间。
<br>万维网：网页是顶点，网页之间的超链接是边。
<br>任务调度：项目中的各个任务是顶点，任务之间的依赖关系（例如，任务A必须在任务B开始前完成）是边。这类问题常通过拓扑排序解决。
<br>生物信息学：蛋白质或基因是顶点，它们之间的相互作用是边。
<br>这些例子揭示了图作为一种通用建模工具的强大能力，能够将复杂系统简化为可分析的结构。<br>B. 图的种类 (Types of Graphs)<br>根据边的特性和图的结构，图可以分为多种类型，理解这些类型对于选择合适的算法至关重要。<br>无向图 (Undirected Graphs) 与 有向图 (Directed Graphs / Digraphs)：<br>
<br>无向图：边没有方向。如果顶点  和顶点  之间有一条边，那么这条边既可以看作从  到 ，也可以看作从  到 。这种关系是双向的，例如Facebook上的好友关系。
<br>有向图 (也称有向图)：边具有明确的方向。一条从  指向  的边表示存在从  到  的关系，但不一定存在从  到  的关系。例如Twitter上的关注关系，用户A关注用户B，不代表用户B也关注用户A。边的方向性是图的一个核心属性，它直接影响路径、连通性等概念以及算法的选择。
<br>无权图 (Unweighted Graphs) 与 加权图 (Weighted Graphs)：<br>
<br>无权图：图中的所有边都没有关联的权重或成本，每条边都被认为是等价的。
<br>加权图：图中的每条边都关联一个数值，称为权重 (Weight) 或成本 (Cost)。权重可以表示多种含义，如距离、时间、容量、费用等。例如，在地图应用中，连接两个城市的边的权重可以表示它们之间的实际距离。加权图为模拟更复杂的现实场景提供了可能，许多重要的图算法，如Dijkstra最短路径算法和Prim最小生成树算法，都是针对加权图设计的。
<br>简单图 (Simple Graphs), 多重图 (Multigraphs), 自环 (Loops)：<br>
<br>简单图：一个图如果任意两个顶点之间最多只有一条边相连，并且图中不包含自环（即连接顶点到其自身的边），则称其为简单图。大多数基础的图算法，如简单路径查找，通常是在简单图的背景下讨论的。
<br>多重图：允许在同一对顶点之间存在多条平行的边。例如，两个数据中心之间可能有多条光纤连接。
<br>自环 (Loop)：一条连接顶点到其自身的边。例如，在状态图中，一个状态可以通过某个操作转换回自身。在邻接矩阵表示法中，自环对应于主对角线上的非零元素。
<br>其他常见类型 (Brief mention)：<br>
<br>完全图 (Complete Graph)：在一个无向简单图中，如果每对不同的顶点之间都恰好存在一条边，则称该图为完全图。若有  个顶点，则完全图有  条边。
<br>二分图 (Bipartite Graph)：图的顶点集可以被划分为两个没有交集的子集  和 ，使得图中的每一条边都连接  中的一个顶点和  中的一个顶点。例如，任务分配问题中，一组顶点代表人，另一组顶点代表任务，边表示某人可以执行某任务。
<br>C. 图的基本术语 (Basic Graph Terminology)<br>掌握图论的基本术语对于理解和交流图算法至关重要。<br>顶点的度 (Degree of a Vertex), 入度 (In-degree), 出度 (Out-degree)：<br>
<br>
在无向图中，一个顶点的度是指与该顶点相关联（或称入射）的边的数量。在一个不包含自环的简单图中，一个顶点的度最大为 ，其中  是顶点总数。

<br>
在有向图中，一个顶点的度分为入度和出度。

<br>入度 (In-degree)：指向该顶点的边的数量。
<br>出度 (Out-degree)：从该顶点指出的边的数量。


<br>顶点的度（或入度/出度）是衡量其连接性的基本指标，并在多种算法（如Kahn拓扑排序算法依赖入度）中扮演关键角色。<br>邻接顶点 (Adjacent Vertices / Neighbors)： 如果两个顶点之间存在一条边，则称这两个顶点是邻接的，它们互为邻居。<br>路径 (Path)： 路径是从一个顶点  到另一个顶点  的一个顶点序列 ，其中 , ，并且对于所有 ,  都是图中的一条边。路径的长度在无权图中通常指边的数量，在加权图中通常指路径上所有边的权重之和。<br>闭合路径 (Closed Path)： 如果一条路径的起始顶点与终止顶点相同，则称其为闭合路径。<br>简单路径 (Simple Path)： 如果一条路径中所有的顶点都是唯一的（除了可能的起始顶点和终止顶点相同的情况），则称其为简单路径。<br>环路 (Cycle)： 一条简单路径，其第一个和最后一个顶点相同，并且路径中不包含重复的边（除了连接起点和终点的那条边，如果路径长度大于1）。严格来说，一个环路通常要求至少包含3条边（在简单图中）以避免退化情况。环路是图论中的一个核心概念，许多问题（如环检测、拓扑排序）都与之相关。<br>连通图 (Connected Graphs) 与 连通分量 (Connected Components)：<br>
<br>连通图 (特指无向图)：如果一个无向图中任意两个不同的顶点之间都至少存在一条路径，则称该图是连通图。
<br>连通分量 (特指无向图)：无向图的极大连通子图。这意味着一个连通分量本身是连通的，并且如果将原图中不在此分量内的任何其他顶点加入该分量，它将不再连通。一个非连通图可以分解为若干个连通分量。
<br>对于有向图，连通性有更细致的划分，如弱连通（忽略边的方向后是连通的）和强连通（任意两个顶点之间都存在双向路径）。<br>连通性描述了图的“整体性”。许多图算法的正确执行依赖于图的连通性，或者需要对图的每个连通分量分别应用算法。<br>图的定义、类型以及相关的基本术语构成了图算法世界的“词汇表”和“语法规则”。对这些基础知识的精确掌握是理解和实现复杂图算法的前提。例如，一个算法的描述可能指定它适用于“加权无向连通图”，如果对这些术语理解不清，就无法正确应用该算法。图的抽象性使其具有极强的建模能力，能够将不同领域的问题（如社交网络分析、物流路径优化、任务依赖管理）统一到同一个数学框架下进行研究和求解。因此，学习图论不仅是掌握一组特定的算法，更是获得一种强大的分析和解决问题的思维模式。<br>II. 图的表示方法 (Graph Representations)<br>要在计算机中处理图，首先需要一种方式来存储图的结构，即顶点和它们之间的连接关系。选择合适的表示方法对算法的效率和实现复杂度有显著影响。主要有两种标准的图表示方法：邻接矩阵和邻接表。<br>A. 邻接矩阵 (Adjacency Matrix)<br>概念与结构：邻接矩阵是一种通过二维数组来表示图中顶点间连接关系的方法。对于一个包含  个顶点的图，邻接矩阵是一个  的方阵，记为 adjMatrix。<br>
<br>
如果顶点  和顶点  之间存在一条边：

<br>对于无权图，adjMatrix[i][j] 的值通常设为 1。
<br>对于加权图，adjMatrix[i][j] 的值设为连接顶点  和  的边的权重。


<br>
如果顶点  和顶点  之间不存在边，则 adjMatrix[i][j] 的值通常设为 0 (对于无权图或表示不存在连接)，或者在某些算法（如最短路径算法）的初始化阶段设为一个特殊值（如无穷大）来表示不直接连通。

<br>
对于无向图，由于边  和  是同一条边，所以邻接矩阵是关于主对角线对称的，即 adjMatrix[i][j] = adjMatrix[j][i]。

<br>
如果图中存在自环（即从顶点  到其自身的边），则邻接矩阵的主对角线元素 adjMatrix[i][i] 将为非零值（1或权重）。若不允许自环的简单图，主对角线元素通常为0。

<br>邻接矩阵是一种非常直观的表示方式，易于理解和实现。<br>C++ 代码示例：下面是一个使用 std::vector&lt;std::vector&lt;int&gt;&gt; 实现邻接矩阵的C++类示例，用于表示一个无权图。它可以很容易地修改以支持加权图（将矩阵元素类型改为权重类型，并将1替换为权重值）。<br>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt; // For std::out_of_range

class GraphAdjMatrix {
private:
    int numVertices;
    std::vector&lt;std::vector&lt;int&gt;&gt; adjMatrix;
    bool isDirected; // 图是否有向

public:
    // 构造函数：初始化顶点数量和邻接矩阵
    GraphAdjMatrix(int V, bool directed = false) : numVertices(V), isDirected(directed) {
        if (V &lt;= 0) {
            throw std::invalid_argument("Number of vertices must be positive.");
        }
        // 初始化V x V的邻接矩阵，所有元素为0
        adjMatrix.resize(numVertices, std::vector&lt;int&gt;(numVertices, 0));
        std::cout &lt;&lt; "Initialized Adjacency Matrix for " &lt;&lt; numVertices &lt;&lt; " vertices." &lt;&lt; std::endl;
    }

    // 添加边 (u, v)
    // 对于加权图，可以增加一个weight参数，并将矩阵值设为weight
    void addEdge(int u, int v, int weight = 1) { // 默认为无权图，权重为1
        if (u &gt;= 0 &amp;&amp; u &lt; numVertices &amp;&amp; v &gt;= 0 &amp;&amp; v &lt; numVertices) {
            adjMatrix[u][v] = weight;
            if (!isDirected) { // 如果是无向图，对称地添加边
                adjMatrix[v][u] = weight;
            }
            std::cout &lt;&lt; "Added edge between " &lt;&lt; u &lt;&lt; " and " &lt;&lt; v &lt;&lt; " with weight " &lt;&lt; weight &lt;&lt; "." &lt;&lt; std::endl;
        } else {
            throw std::out_of_range("Vertex out of bounds.");
        }
    }

    // 移除边 (u, v)
    void removeEdge(int u, int v) {
        if (u &gt;= 0 &amp;&amp; u &lt; numVertices &amp;&amp; v &gt;= 0 &amp;&amp; v &lt; numVertices) {
            adjMatrix[u][v] = 0; // 或表示无穷大的值
            if (!isDirected) {
                adjMatrix[v][u] = 0;
            }
            std::cout &lt;&lt; "Removed edge between " &lt;&lt; u &lt;&lt; " and " &lt;&lt; v &lt;&lt; "." &lt;&lt; std::endl;
        } else {
            throw std::out_of_range("Vertex out of bounds.");
        }
    }

    // 检查顶点u和v之间是否存在边
    bool hasEdge(int u, int v) {
        if (u &gt;= 0 &amp;&amp; u &lt; numVertices &amp;&amp; v &gt;= 0 &amp;&amp; v &lt; numVertices) {
            return adjMatrix[u][v]!= 0; // 对于加权图，只要不是0或无穷大就认为有边
        }
        throw std::out_of_range("Vertex out of bounds.");
        return false;
    }

    // 打印邻接矩阵
    void display() {
        std::cout &lt;&lt; "\nAdjacency Matrix:" &lt;&lt; std::endl;
        for (int i = 0; i &lt; numVertices; ++i) {
            for (int j = 0; j &lt; numVertices; ++j) {
                std::cout &lt;&lt; adjMatrix[i][j] &lt;&lt; " ";
            }
            std::cout &lt;&lt; std::endl;
        }
    }

    // 析构函数 (std::vector 会自动管理内存，如果用裸指针则需要手动释放)
    ~GraphAdjMatrix() {
        std::cout &lt;&lt; "Adjacency Matrix Graph destroyed." &lt;&lt; std::endl;
    }
};

// 主函数示例
// int main() {
//     try {
//         GraphAdjMatrix g(4, false); // 创建一个4个顶点的无向图
//         g.addEdge(0, 1);
//         g.addEdge(0, 2);
//         g.addEdge(1, 2);
//         g.addEdge(2, 3);
//         g.display();
// 
//         GraphAdjMatrix dg(3, true); // 创建一个3个顶点的有向图
//         dg.addEdge(0, 1, 5); // 加权边
//         dg.addEdge(1, 2, 3);
//         dg.addEdge(0, 2, 10);
//         dg.display();
//         std::cout &lt;&lt; "Edge (0,1) exists: " &lt;&lt; dg.hasEdge(0,1) &lt;&lt; std::endl;
//         std::cout &lt;&lt; "Edge (1,0) exists: " &lt;&lt; dg.hasEdge(1,0) &lt;&lt; std::endl;
// 
//     } catch (const std::exception&amp; e) {
//         std::cerr &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; std::endl;
//     }
//     return 0;
// }
<br>在上述代码中，构造函数初始化一个全零的矩阵。addEdge 方法根据图是否有向来设置矩阵元素。hasEdge 方法可以快速检查边的存在性。<br>优缺点分析：邻接矩阵的主要优点包括：<br>
<br>快速判断边的存在性：检查顶点  和  之间是否存在边（即 adjMatrix[u][v] 是否非零）只需要  的时间。
<br>添加或删除边操作高效：如果顶点已知，添加或删除一条边也只需要  的时间（修改矩阵中的一个元素）。
<br>对于稠密图（图中边的数量  接近于 ），邻接矩阵的空间效率相对可以接受，并且其操作速度较快。
<br>然而，邻接矩阵也有一些显著的缺点：<br>
<br>空间复杂度高：它总是需要  的空间，其中  是顶点数。对于稀疏图（边的数量  远小于 ），这将导致大量的空间浪费，因为矩阵中的大部分元素都会是0。
<br>遍历顶点的邻接点效率低：要找到一个特定顶点的所有邻接点，需要遍历矩阵中的整行（或整列），这需要  的时间。
<br>添加或删除顶点操作成本高：这些操作通常需要重新分配和复制整个矩阵，或者至少是  级别的调整，因此非常耗时。
<br>空间与时间复杂度总结：<br>
<br>空间复杂度：
<br>添加顶点： (由于矩阵重建)
<br>添加边：
<br>删除顶点： (由于矩阵重建)
<br>删除边：
<br>查询边 (u,v) 是否存在：
<br>获取顶点  的所有邻接点：
<br>B. 邻接表 (Adjacency List)<br>概念与结构：邻接表是另一种常用的图表示方法，尤其适用于稀疏图。它由一个包含  个列表（通常是链表或动态数组，如C++中的 std::vector）的数组（或向量）构成。数组的第  个索引（或元素）对应图中的第  个顶点，该索引处的列表存储了所有与顶点  直接邻接的顶点。<br>
<br>对于无权图，列表中通常只存储邻接顶点的编号。
<br>对于加权图，列表中的每个元素通常是一个序对 (pair)，例如 std::pair&lt;int, int&gt;，其中第一个元素是邻接顶点的编号，第二个元素是连接当前顶点与该邻接顶点的边的权重。
<br>由于图的结构可能非常复杂，任意两个顶点之间都可能存在关系，这种任意的逻辑关系使得图无法简单地通过固定的存储位置来表示其连接性，而邻接表恰好提供了这种所需的灵活性。<br>C++ 代码示例：下面是一个使用 std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt;&gt;&gt; 实现邻接表的C++类示例，用于表示一个加权图。对于无权图，可以将 pair 替换为单个 int 来存储邻接顶点。<br>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;list&gt;   // 可选，如果想用链表代替vector作为邻接列表
#include &lt;algorithm&gt; // For std::remove_if for removeEdge

// 对于加权图，边信息可以包含目标顶点和权重
struct EdgeNode {
    int to_vertex;
    int weight;
};

class GraphAdjList {
private:
    int numVertices;
    std::vector&lt;std::list&lt;EdgeNode&gt;&gt; adjList; // 使用list作为邻接列表，方便删除边
    bool isDirected;

public:
    // 构造函数
    GraphAdjList(int V, bool directed = false) : numVertices(V), isDirected(directed) {
        if (V &lt;= 0) {
            throw std::invalid_argument("Number of vertices must be positive.");
        }
        adjList.resize(numVertices);
        std::cout &lt;&lt; "Initialized Adjacency List for " &lt;&lt; numVertices &lt;&lt; " vertices." &lt;&lt; std::endl;
    }

    // 添加边 (u, v) 权重为 weight
    void addEdge(int u, int v, int weight) {
        if (u &gt;= 0 &amp;&amp; u &lt; numVertices &amp;&amp; v &gt;= 0 &amp;&amp; v &lt; numVertices) {
            adjList[u].push_back({v, weight});
            if (!isDirected) { // 如果是无向图，对称地添加边
                adjList[v].push_back({u, weight});
            }
            std::cout &lt;&lt; "Added edge between " &lt;&lt; u &lt;&lt; " and " &lt;&lt; v &lt;&lt; " with weight " &lt;&lt; weight &lt;&lt; "." &lt;&lt; std::endl;
        } else {
            throw std::out_of_range("Vertex out of bounds.");
        }
    }

    // 移除边 (u, v)
    // 注意：对于多重图，这会移除第一个匹配的边。如果需要移除所有匹配边，需修改。
    void removeEdge(int u, int v) {
        if (u &gt;= 0 &amp;&amp; u &lt; numVertices &amp;&amp; v &gt;= 0 &amp;&amp; v &lt; numVertices) {
            adjList[u].remove_if([v](const EdgeNode&amp; edge){ return edge.to_vertex == v; });
            if (!isDirected) {
                adjList[v].remove_if([u](const EdgeNode&amp; edge){ return edge.to_vertex == u; });
            }
            std::cout &lt;&lt; "Attempted to remove edge(s) between " &lt;&lt; u &lt;&lt; " and " &lt;&lt; v &lt;&lt; "." &lt;&lt; std::endl;
        } else {
            throw std::out_of_range("Vertex out of bounds.");
        }
    }

    // 检查顶点u和v之间是否存在边
    bool hasEdge(int u, int v) {
        if (u &gt;= 0 &amp;&amp; u &lt; numVertices &amp;&amp; v &gt;= 0 &amp;&amp; v &lt; numVertices) {
            for (const auto&amp; edge : adjList[u]) {
                if (edge.to_vertex == v) {
                    return true;
                }
            }
            return false;
        }
        throw std::out_of_range("Vertex out of bounds.");
        return false;
    }
    
    // 打印邻接表
    void display() {
        std::cout &lt;&lt; "\nAdjacency List:" &lt;&lt; std::endl;
        for (int i = 0; i &lt; numVertices; ++i) {
            std::cout &lt;&lt; "Vertex " &lt;&lt; i &lt;&lt; ":";
            for (const auto&amp; edge : adjList[i]) {
                std::cout &lt;&lt; " -&gt; (" &lt;&lt; edge.to_vertex &lt;&lt; ", w:" &lt;&lt; edge.weight &lt;&lt; ")";
            }
            std::cout &lt;&lt; std::endl;
        }
    }

    // 获取顶点的邻接点列表 (只读访问)
    const std::list&lt;EdgeNode&gt;&amp; getNeighbors(int u) const {
        if (u &gt;= 0 &amp;&amp; u &lt; numVertices) {
            return adjList[u];
        }
        throw std::out_of_range("Vertex out of bounds.");
    }
    
    ~GraphAdjList() {
        std::cout &lt;&lt; "Adjacency List Graph destroyed." &lt;&lt; std::endl;
    }
};

// 主函数示例
// int main() {
//     try {
//         GraphAdjList g(4, false); // 4个顶点的无向加权图
//         g.addEdge(0, 1, 10);
//         g.addEdge(0, 2, 5);
//         g.addEdge(1, 2, 2);
//         g.addEdge(2, 3, 1);
//         g.display();
// 
//         std::cout &lt;&lt; "Neighbors of vertex 0:" &lt;&lt; std::endl;
//         for (const auto&amp; edge : g.getNeighbors(0)) {
//             std::cout &lt;&lt; "  To: " &lt;&lt; edge.to_vertex &lt;&lt; ", Weight: " &lt;&lt; edge.weight &lt;&lt; std::endl;
//         }
// 
//         std::cout &lt;&lt; "Edge (0,1) exists: " &lt;&lt; g.hasEdge(0,1) &lt;&lt; std::endl;
//         g.removeEdge(0,1);
//         std::cout &lt;&lt; "Edge (0,1) exists after removal: " &lt;&lt; g.hasEdge(0,1) &lt;&lt; std::endl;
//         g.display();
// 
//     } catch (const std::exception&amp; e) {
//         std::cerr &lt;&lt; "Exception: " &lt;&lt; e.what() &lt;&lt; std::endl;
//     }
//     return 0;
// }
<br>在此示例中，adjList 是一个 std::vector，其每个元素是一个 std::list&lt;EdgeNode&gt;。EdgeNode 结构体存储了目标顶点和边的权重。addEdge 方法将新的邻接信息添加到相应顶点的列表中。<br>优缺点分析：邻接表的主要优点包括：<br>
<br>空间效率高：特别是对于稀疏图，邻接表的空间复杂度为 ，其中  是顶点数， 是边数。这是因为它只存储实际存在的边。
<br>高效遍历顶点的邻接点：获取并遍历一个特定顶点的所有邻接点非常高效，时间复杂度与其度数成正比。这对于像深度优先搜索 (DFS) 和广度优先搜索 (BFS) 这样的图遍历算法非常有利。
<br>添加顶点操作相对高效：向图中添加一个新顶点（不包括其边）通常是  操作（即在表示邻接表的数组/向量末尾添加一个新列表）。
<br>添加边操作高效：向现有顶点的邻接列表中添加一条边通常是  （摊销时间，如果使用 std::vector::push_back 或链表头插）。
<br>邻接表的缺点主要有：<br>
<br>判断边的存在性较慢：要检查顶点  和  之间是否存在边，最坏情况下需要遍历顶点  (或 ) 的整个邻接列表，时间复杂度为 ，其中  是顶点  的度。在稠密图中，这可能接近 。
<br>删除边操作可能较慢：与查询类似，删除一条边  需要先在顶点  的邻接列表中找到并移除 （对于无向图，还需要在  的列表中找到并移除 ），这同样可能需要  的时间。
<br>根据 61 的观点，邻接链表（一种邻接表的实现方式）在边的读写上可能比矩阵表示稍慢，因为链表中的指针在内存中可能不是连续存储的，这可能影响缓存性能。<br>空间与时间复杂度总结：<br>
<br>空间复杂度：
<br>添加顶点： (仅指为新顶点创建空邻接列表)
<br>添加边： (摊销)
<br>删除顶点： (最坏情况，因为需要遍历所有其他顶点的邻接列表以移除与被删除顶点相关的边)
<br>删除边 (u,v)： (对于有向图，或无向图中从  到  的部分) 或  (对于无向图的完整删除)
<br>查询边 (u,v) 是否存在： 或 
<br>获取顶点  的所有邻接点：
<br>C. 如何选择合适的表示方法 (Choosing the Right Representation)<br>选择邻接矩阵还是邻接表，主要取决于图的特性（特别是密度）和应用中所需执行的主要操作类型。<br>图的密度：<br>
<br>稠密图 (Dense Graphs)：当边的数量  接近于  的上限时，图被认为是稠密的。在这种情况下，邻接矩阵的  空间开销与  相差不大，其  的边查询速度可能成为优势。
<br>稀疏图 (Sparse Graphs)：当边的数量  远小于 （例如  与  成线性关系）时，图被认为是稀疏的。此时，邻接表的  空间复杂度远优于邻接矩阵，是首选的表示方法。21 甚至探讨了对稀疏有向图的邻接矩阵进行压缩存储的方法，以缓解其空间浪费问题，这反过来也强调了邻接表在稀疏图上的自然优势。
<br>主要操作需求：<br>
<br>如果算法需要频繁地检查任意两个顶点之间是否存在边，邻接矩阵的  查询时间非常有利。
<br>如果算法需要频繁地遍历一个顶点的所有邻接点（例如在DFS、BFS等图遍历算法中），邻接表则更为高效，因为它直接提供了邻接点列表。
<br>如果图中顶点的添加和删除操作非常频繁，需要仔细评估两种方法。邻接矩阵的顶点增删成本很高 ()，而邻接表在添加顶点本身时较快，但删除顶点时仍需处理相关的边，可能达到 。
<br><br>下表总结了邻接矩阵和邻接表在各种操作上的性能特点：<br><br>数据来源：基于 14 及其他相关片段的分析。<br>此表格清晰地展示了两种表示方法的权衡。在实际应用和算法竞赛中，由于现实世界中的许多大型图（如社交网络、网页图）通常是稀疏的，邻接表因其空间效率和对遍历操作的良好支持而更为常用。<br>图的表示方法是图算法得以高效执行的基石。一种算法的理论时间复杂度往往是基于某种特定的图表示（通常是邻接表，因为它对稀疏图更友好）推导出来的。例如，标准的BFS和DFS算法的  时间复杂度就是假设图是用邻接表表示的。如果用邻接矩阵，由于查找一个顶点的所有邻居需要  时间，这些遍历算法的复杂度可能会变成 。这凸显了数据结构选择对算法性能的深远影响。此外，C++标准模板库 (STL) 中的 std::vector 和 std::list（以及用于加权图的 std::pair）为实现邻接表提供了极大的便利，使得开发者可以专注于算法逻辑本身，而不必过多地纠缠于底层数据结构的细节实现。然而，理解这些STL容器大致的性能特征（例如 std::vector::push_back 的摊销  复杂度）对于准确分析算法性能仍然是重要的。最终，选择哪种表示方法是一个需要在空间效率、时间效率以及特定操作需求之间进行权衡的决策。<br>III. 图的遍历算法 (Graph Traversal Algorithms)<br>图的遍历是指按照某种特定的顺序访问图中的每一个顶点，并且每个顶点仅访问一次。这是许多更复杂图算法的基础。最核心的两种遍历算法是广度优先搜索 (BFS) 和深度优先搜索 (DFS)。<br>A. 广度优先搜索 (BFS - Breadth-First Search)<br>算法思想与直观理解：广度优先搜索 (BFS) 是一种系统性地探索图中顶点的方法。它从一个指定的源顶点开始，首先访问所有与源顶点直接相邻的顶点（可以看作是第一层或距离为1的层）。然后，对于第一层中所有已被访问的顶点，BFS会继续访问它们所有未被访问过的邻接点（构成第二层或距离为2的层）。这个过程逐层向外扩展，直到所有从源顶点可达的顶点都被访问过为止。可以将BFS的过程想象成在平静的水面上投下一颗石子，产生的波纹会以石子落点为中心，一圈一圈地向外均匀扩散。BFS的这种“逐层”或“按距离远近”的访问特性，使其天然适用于寻找无权图中的最短路径（以边的数量衡量）。<br>为了实现这种逐层访问的顺序，BFS通常使用一个队列 (Queue) 数据结构。队列的先进先出 (FIFO) 特性保证了先发现的顶点（离源点更近的顶点）其邻接点会被优先探索。同时，为了避免重复访问同一个顶点（尤其是在包含环的图中可能导致无限循环），BFS会使用一个布尔数组 visited 来标记每个顶点是否已经被访问过。<br>C++ 代码示例：以下是一个基于邻接表实现的BFS算法的C++代码示例。假设图用 std::vector&lt;std::vector&lt;int&gt;&gt; adjList 表示（对于无权图），其中 adjList[u] 包含了顶点  的所有邻接顶点。<br>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;list&gt; // GraphAdjList 使用了 list

// (假设 GraphAdjList 类如前文定义，这里仅展示BFS成员函数)
// 或者可以是一个独立的BFS函数，接收邻接表和起始顶点作为参数

// 独立BFS函数版本
void bfs_standalone(int startVertex, int numVertices, const std::vector&lt;std::list&lt;EdgeNode&gt;&gt;&amp; adjList) {
    if (startVertex &lt; 0 || startVertex &gt;= numVertices) {
        std::cerr &lt;&lt; "Error: Start vertex is out of bounds." &lt;&lt; std::endl;
        return;
    }

    std::vector&lt;bool&gt; visited(numVertices, false); // 标记顶点是否被访问过
    std::queue&lt;int&gt; q;                             // 辅助队列

    // 1. 将起始顶点标记为已访问，并将其入队
    visited[startVertex] = true;
    q.push(startVertex);

    std::cout &lt;&lt; "BFS traversal starting from vertex " &lt;&lt; startVertex &lt;&lt; ": ";

    // 2. 当队列不为空时，循环继续
    while (!q.empty()) {
        // 3. 从队列中取出一个顶点
        int u = q.front();
        q.pop();

        // 4. 访问该顶点 (例如，打印)
        std::cout &lt;&lt; u &lt;&lt; " ";

        // 5. 遍历该顶点的所有邻

]]></description><link>数据结构\图论.html</link><guid isPermaLink="false">数据结构/图论.md</guid><pubDate>Fri, 23 May 2025 07:18:13 GMT</pubDate></item><item><title><![CDATA[栈]]></title><description><![CDATA[ 
 <br><br><br>栈是一种特殊的线性数据结构，遵循后进先出 (Last-In, First-Out, LIFO) 的原则。可以将其想象成一叠盘子：你最后放上去的盘子，会是第一个被取走的。<br>
<br>栈顶 (Top): 允许进行插入和删除操作的一端。
<br>栈底 (Bottom): 栈的另一端，通常固定不动。
<br>压栈/入栈 (Push): 向栈顶添加元素的过程。
<br>弹栈/出栈 (Pop): 从栈顶移除元素的过程。
<br>核心特性总结：<br>
<br>LIFO原则： 最后进入栈的元素最先离开。
<br>受限的线性表： 只能在栈顶进行操作。
<br><br>栈主要支持以下几种基本操作：<br>
<br>push(element): 将元素 element 压入栈顶。

<br>前置条件 (对于有界实现)： 栈未满。
<br>后置条件： element 成为新的栈顶元素，栈的大小增加1。


<br>pop(): 移除栈顶元素。注意： 在 C++ 的 std::stack 中，pop() 只移除元素，不返回值。获取栈顶元素需要使用 top()。

<br>前置条件： 栈不能为空。
<br>后置条件： 原栈顶元素被移除，其下的元素（如果存在）成为新的栈顶，栈的大小减少1。


<br>top() (或 peek()): 返回对栈顶元素的引用（或值），但不移除它。

<br>前置条件： 栈不能为空。
<br>后置条件： 栈的状态不改变。


<br>empty(): 检查栈是否为空。

<br>后置条件： 如果栈中没有元素，返回 true；否则返回 false。


<br>size(): 返回栈中元素的数量。
<br><br>栈在计算机科学中有广泛的应用，例如：<br>
<br>函数调用栈 (Call Stack): 管理函数调用的顺序，存储局部变量、参数和返回地址。
<br>表达式求值：

<br>中缀表达式转后缀表达式 (逆波兰表达式)。
<br>后缀表达式求值。


<br>括号匹配： 检查代码或表达式中的括号 ((), {}, []) 是否成对出现且正确嵌套。
<br>深度优先搜索 (DFS - Depth First Search): 在图或树的遍历中，栈可以用来存储待访问的节点。
<br>浏览器的前进/后退功能： 后退历史可以看作一个栈。
<br>撤销/重做 (Undo/Redo) 操作： 用户操作可以被存储在一个栈中。
<br>递归的非递归实现： 许多递归算法可以用栈来模拟实现。
<br><br>在 C++ 中，栈可以通过多种方式实现：<br>
<br>基于数组的实现 (静态或动态)
<br>基于链表的实现
<br>使用 C++ 标准库的 std::stack (适配器类)
<br><br>使用一个固定大小的数组来存储栈中的元素。需要一个额外的变量（通常称为 topIndex 或 count）来指示栈顶元素在数组中的下一个可用位置或当前栈顶元素的索引。<br>优点：<br>
<br>实现相对简单。
<br>内存分配在编译时或对象创建时完成，访问速度快（缓存友好）。
<br>缺点：<br>
<br>大小固定： 栈的容量在创建时就确定了。如果元素数量超过数组容量，会导致栈溢出 (Stack Overflow)。
<br>空间浪费： 如果分配的数组空间远大于实际存储的元素数量，会造成空间浪费。
<br>C++ 代码示例 (静态数组)：<br>#include &lt;iostream&gt;
#include &lt;stdexcept&gt; // 用于 std::out_of_range 和 std::runtime_error

const int MAX_SIZE = 100; // 预设栈的最大容量

template &lt;typename T&gt;
class ArrayStack {
 private:
  T arr[MAX_SIZE];
  int topIndex;  // 指向栈顶元素的索引，-1 表示空栈

 public:
  ArrayStack() : topIndex(-1) {}

  // 压栈
  void push(const T&amp; element) {
    if (isFull()) {
      throw std::overflow_error("Stack overflow: Cannot push to a full stack.");
    }
    arr[++topIndex] = element;
  }

  // 弹栈 (只移除，不返回)
  void pop() {
    if (isEmpty()) {
      throw std::underflow_error("Stack underflow: Cannot pop from an empty stack.");
    }
    topIndex--;
  }

  // 查看栈顶元素
  T&amp; top() {
    if (isEmpty()) {
      throw std::underflow_error("Stack is empty: Cannot get top element.");
    }
    return arr[topIndex];
  }

  // 查看栈顶元素 (const 版本)
  const T&amp; top() const {
    if (isEmpty()) {
      throw std::underflow_error("Stack is empty: Cannot get top element.");
    }
    return arr[topIndex];
  }

  // 检查栈是否为空
  bool isEmpty() const {
    return topIndex == -1;
  }

  // 检查栈是否已满
  bool isFull() const {
    return topIndex == MAX_SIZE - 1;
  }

  // 获取栈中元素数量
  int size() const {
    return topIndex + 1;
  }

  // 打印栈内容 (用于调试)
  void print() const {
    if (isEmpty()) {
      std::cout &lt;&lt; "Stack is empty." &lt;&lt; std::endl;
      return;
    }
    std::cout &lt;&lt; "Stack (top to bottom): ";
    for (int i = topIndex; i &gt;= 0; --i) {
      std::cout &lt;&lt; arr[i] &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
  }
};

// --- ArrayStack 示例用法 ---
void testArrayStack() {
  std::cout &lt;&lt; "--- ArrayStack (Static) 示例 ---" &lt;&lt; std::endl;
  ArrayStack&lt;int&gt; s;
  std::cout &lt;&lt; "Is empty: " &lt;&lt; s.isEmpty() &lt;&lt; std::endl;  // 1 (true)

  s.push(10);
  s.push(20);
  s.push(30);
  s.print();  // Stack (top to bottom): 30 20 10

  std::cout &lt;&lt; "Top element: " &lt;&lt; s.top() &lt;&lt; std::endl;  // 30
  std::cout &lt;&lt; "Size: " &lt;&lt; s.size() &lt;&lt; std::endl;         // 3
  std::cout &lt;&lt; "Is empty: " &lt;&lt; s.isEmpty() &lt;&lt; std::endl;  // 0 (false)

  s.pop();                                                      // 移除 30
  s.print();                                                    // Stack (top to bottom): 20 10
  std::cout &lt;&lt; "Top element after pop: " &lt;&lt; s.top() &lt;&lt; std::endl;  // 20

  s.pop();    // 移除 20
  s.pop();    // 移除 10
  s.print();  // Stack is empty.
  std::cout &lt;&lt; "Is empty: " &lt;&lt; s.isEmpty() &lt;&lt; std::endl;  // 1 (true)

  try {
    s.pop();  // 尝试从空栈 pop
  } catch (const std::underflow_error&amp; e) {
    std::cerr &lt;&lt; "Caught exception: " &lt;&lt; e.what() &lt;&lt; std::endl;
  }

  // 填满栈并尝试溢出
  ArrayStack&lt;char&gt; charStack;
  for (int i = 0; i &lt; MAX_SIZE; ++i) {
    charStack.push('A' + (i % 26));
  }
  std::cout &lt;&lt; "Char stack is full: " &lt;&lt; charStack.isFull() &lt;&lt; std::endl;
  try {
    charStack.push('Z');
  } catch (const std::overflow_error&amp; e) {
    std::cerr &lt;&lt; "Caught exception: " &lt;&lt; e.what() &lt;&lt; std::endl;
  }
  std::cout &lt;&lt; std::endl;
}
<br>时间复杂度 (静态数组实现)：<br>
<br>push(element): 
<br>pop(): 
<br>top(): 
<br>isEmpty(): 
<br>isFull(): 
<br>size(): 
<br>空间复杂度 (静态数组实现)： ，其中  是数组的最大容量 (MAX_SIZE)。<br>
<br>注意: 对于动态数组实现 (使用 new T[capacity] 和 delete[])，push 操作在需要扩容时的时间复杂度会是  (其中 N 为当前元素数量)，但均摊时间复杂度仍为 。
<br><br>使用链表（通常是单向链表）来存储栈中的元素。链表的头节点通常作为栈顶。<br>优点：<br>
<br>动态大小： 栈的大小可以根据需要动态增长或缩小，没有预设的容量限制（受限于系统可用内存）。
<br>空间高效： 只为实际存储的元素分配内存。
<br>缺点：<br>
<br>额外的内存开销： 每个节点都需要额外的空间来存储指向下一个节点的指针。
<br>内存不连续： 相比数组，可能在缓存利用率上稍差。
<br>C++ 代码示例 (链表)：<br>#include &lt;iostream&gt;
#include &lt;stdexcept&gt;  // 用于 std::out_of_range

template &lt;typename T&gt;
class LinkedStack {
 private:
  struct Node {
    T data;
    Node* next;
    Node(const T&amp; val) : data(val), next(nullptr) {}
  };

  Node* topNode;  // 指向栈顶节点
  int count;      // 栈中元素数量

 public:
  LinkedStack() : topNode(nullptr), count(0) {}

  ~LinkedStack() {  // 析构函数，释放所有节点内存
    while (!isEmpty()) {
      pop();
    }
  }

  // 压栈
  void push(const T&amp; element) {
    Node* newNode = new Node(element);
    newNode-&gt;next = topNode;
    topNode = newNode;
    count++;
  }

  // 弹栈 (只移除，不返回)
  void pop() {
    if (isEmpty()) {
      throw std::underflow_error("Stack underflow: Cannot pop from an empty stack.");
    }
    Node* temp = topNode;
    topNode = topNode-&gt;next;
    delete temp;
    count--;
  }

  // 查看栈顶元素
  T&amp; top() {
    if (isEmpty()) {
      throw std::underflow_error("Stack is empty: Cannot get top element.");
    }
    return topNode-&gt;data;
  }

  // 查看栈顶元素 (const 版本)
  const T&amp; top() const {
    if (isEmpty()) {
      throw std::underflow_error("Stack is empty: Cannot get top element.");
    }
    return topNode-&gt;data;
  }

  // 检查栈是否为空
  bool isEmpty() const {
    return topNode == nullptr;  // 或者 count == 0
  }

  // 获取栈中元素数量
  int size() const {
    return count;
  }

  // 打印栈内容 (用于调试)
  void print() const {
    if (isEmpty()) {
      std::cout &lt;&lt; "LinkedStack is empty." &lt;&lt; std::endl;
      return;
    }
    std::cout &lt;&lt; "LinkedStack (top to bottom): ";
    Node* current = topNode;
    while (current != nullptr) {
      std::cout &lt;&lt; current-&gt;data &lt;&lt; " ";
      current = current-&gt;next;
    }
    std::cout &lt;&lt; std::endl;
  }
};

// --- LinkedStack 示例用法 ---
void testLinkedStack() {
  std::cout &lt;&lt; "--- LinkedStack 示例 ---" &lt;&lt; std::endl;
  LinkedStack&lt;std::string&gt; s;
  std::cout &lt;&lt; "Is empty: " &lt;&lt; s.isEmpty() &lt;&lt; std::endl;  // 1 (true)

  s.push("Hello");
  s.push("World");
  s.push("C++");
  s.print();  // LinkedStack (top to bottom): C++ World Hello

  std::cout &lt;&lt; "Top element: " &lt;&lt; s.top() &lt;&lt; std::endl;  // C++
  std::cout &lt;&lt; "Size: " &lt;&lt; s.size() &lt;&lt; std::endl;         // 3

  s.pop();                                                      // 移除 "C++"
  s.print();                                                    // LinkedStack (top to bottom): World Hello
  std::cout &lt;&lt; "Top element after pop: " &lt;&lt; s.top() &lt;&lt; std::endl;  // World

  s.pop();    // 移除 "World"
  s.pop();    // 移除 "Hello"
  s.print();  // LinkedStack is empty.
  std::cout &lt;&lt; "Is empty: " &lt;&lt; s.isEmpty() &lt;&lt; std::endl;  // 1 (true)

  try {
    std::cout &lt;&lt; s.top() &lt;&lt; std::endl;  // 尝试从空栈获取 top
  } catch (const std::underflow_error&amp; e) {
    std::cerr &lt;&lt; "Caught exception: " &lt;&lt; e.what() &lt;&lt; std::endl;
  }
  std::cout &lt;&lt; std::endl;
}
<br>时间复杂度 (链表实现)：<br>
<br>push(element):  (在链表头部插入)
<br>pop():  (删除链表头部节点)
<br>top():  (访问链表头部节点)
<br>isEmpty(): 
<br>size():  (如果维护了一个 count 变量)
<br>空间复杂度 (链表实现)： ，其中  是栈中元素的数量。每个元素都需要一个节点的空间。<br><br>C++ 标准库提供了一个容器适配器 std::stack，它默认使用 std::deque (双端队列) 作为其底层容器，但也可以配置为使用 std::vector 或 std::list。std::stack 封装了底层容器，使其表现出栈的行为。<br>优点：<br>
<br>标准、可靠、高效： 由标准库提供，经过良好测试和优化。
<br>易于使用： 无需自己实现，直接包含 &lt;stack&gt; 头文件即可。
<br>灵活性： 可以选择底层容器。
<br>缺点：<br>
<br>功能受限： 只提供标准的栈操作，不能直接访问底层容器的非栈操作（比如直接访问非栈顶元素）。
<br>C++ 代码示例 (std::stack)：<br>#include &lt;iostream&gt;
#include &lt;stack&gt;   // 包含 stack 头文件
#include &lt;vector&gt;  // 可以用作 std::stack 的底层容器
#include &lt;list&gt;    // 也可以用作 std::stack 的底层容器
#include &lt;deque&gt;   // std::stack 默认的底层容器

// --- std::stack 示例用法 ---
void testStdStack() {
  std::cout &lt;&lt; "--- std::stack (default: deque) 示例 ---" &lt;&lt; std::endl;
  std::stack&lt;int&gt; s_deque;  // 默认底层容器是 std::deque&lt;int&gt;

  std::cout &lt;&lt; "Is empty: " &lt;&lt; s_deque.empty() &lt;&lt; std::endl;  // 1 (true)

  s_deque.push(100);
  s_deque.push(200);
  s_deque.push(300);
  // std::stack 没有直接的 print 方法，需要逐个取出打印 (会改变栈)
  // 或者访问底层容器（但不推荐，破坏封装）

  std::cout &lt;&lt; "Top element: " &lt;&lt; s_deque.top() &lt;&lt; std::endl;  // 300
  std::cout &lt;&lt; "Size: " &lt;&lt; s_deque.size() &lt;&lt; std::endl;         // 3

  s_deque.pop();  // 移除 300
  std::cout &lt;&lt; "Top element after pop: " &lt;&lt; s_deque.top() &lt;&lt; std::endl;  // 200
  std::cout &lt;&lt; "Size after pop: " &lt;&lt; s_deque.size() &lt;&lt; std::endl;         // 2

  std::cout &lt;&lt; "Popping elements: ";
  while (!s_deque.empty()) {
    std::cout &lt;&lt; s_deque.top() &lt;&lt; " ";
    s_deque.pop();
  }
  std::cout &lt;&lt; std::endl;
  std::cout &lt;&lt; "Is empty after all pops: " &lt;&lt; s_deque.empty() &lt;&lt; std::endl;  // 1 (true)

  // 使用 std::vector 作为底层容器
  std::cout &lt;&lt; "\n--- std::stack (with std::vector) 示例 ---" &lt;&lt; std::endl;
  std::stack&lt;double, std::vector&lt;double&gt;&gt; s_vector;
  s_vector.push(1.1);
  s_vector.push(2.2);
  std::cout &lt;&lt; "Top element (vector-based): " &lt;&lt; s_vector.top() &lt;&lt; std::endl;  // 2.2
  s_vector.pop();
  std::cout &lt;&lt; "Top element after pop (vector-based): " &lt;&lt; s_vector.top() &lt;&lt; std::endl;  // 1.1

  // 使用 std::list 作为底层容器
  std::cout &lt;&lt; "\n--- std::stack (with std::list) 示例 ---" &lt;&lt; std::endl;
  std::stack&lt;char, std::list&lt;char&gt;&gt; s_list;
  s_list.push('a');
  s_list.push('b');
  std::cout &lt;&lt; "Top element (list-based): " &lt;&lt; s_list.top() &lt;&lt; std::endl;  // 'b'
  s_list.pop();
  std::cout &lt;&lt; "Top element after pop (list-based): " &lt;&lt; s_list.top() &lt;&lt; std::endl;  // 'a'
  std::cout &lt;&lt; std::endl;
}
<br>std::stack 的操作及其复杂度 (通常)：<br>
<br>push(element): 通常  (均摊，取决于底层容器的 push_back 或 push_front)
<br>pop(): 通常  (取决于底层容器的 pop_back 或 pop_front)
<br>top():  (取决于底层容器的 back 或 front)
<br>empty(): 
<br>size(): 
<br><br>
<br>std::stack: 强烈推荐在大多数情况下使用。它简单、安全，并且是标准的一部分。
<br>基于数组的实现：

<br>优点： 对于固定且较小的最大容量，内存是连续的，可能具有较好的缓存性能。
<br>缺点： 容量固定（静态数组）或动态扩容有开销。
<br>适用场景： 教学目的，或者在嵌入式系统等对内存控制有严格要求的环境中，且最大容量已知。


<br>基于链表的实现：

<br>优点： 真正的动态大小，插入删除操作稳定 。
<br>缺点： 每个元素有额外的指针开销，内存不连续。
<br>适用场景： 教学目的，或者当栈的大小非常动态且难以预估时。


<br><br>
<br>理解 LIFO 原则。
<br>掌握基本操作： push, pop, top, empty, size 的含义和 C++ 中的对应。
<br>熟悉 C++ 中的实现方式： 数组（静态/动态）、链表、std::stack。
<br>时间与空间复杂度： 能够分析各种操作在不同实现下的复杂度。
<br>应用场景： 能够举例说明栈在实际问题中的应用，并理解其工作原理。
<br>边界条件处理：

<br>对空栈进行 pop 或 top 操作（如何处理，如抛出异常）。
<br>对满栈（数组实现）进行 push 操作。


<br>std::stack 的用法： 知道它是容器适配器，默认底层容器，以及如何指定其他底层容器。
<br>资源管理： 在链表或动态数组实现中，注意内存的分配 (new) 和释放 (delete/delete[])，防止内存泄漏（特别是在析构函数和 pop 中）。
<br><br>
<br>手动实现栈：用静态数组、动态数组（带扩容）和链表分别实现一个栈类。
<br>栈的应用编程：

<br>用栈实现有效的括号匹配检查器。
<br>用栈实现后缀表达式（逆波兰表达式）求值。
<br>用栈实现中缀表达式到后缀表达式的转换。
<br>使用两个栈模拟一个队列。
<br>设计一个栈，除了基本操作外，还支持一个 getMin() 方法，该方法可以在  时间内返回栈中的最小元素。
<br>用栈实现递归函数的非递归版本（例如斐波那契数列或树的遍历）。


<br>分析问题：判断某个问题是否适合用栈来解决，并说明理由。
<br>// Main function to run test cases
int main() {
  testArrayStack();
  testLinkedStack();
  testStdStack();
  return 0;
}
<br>(请将上述 main 函数与之前的类定义和测试函数放在同一个 .C++ 文件中编译运行，或者分别编译链接。)<br>祝你复习顺利，考试取得好成绩！]]></description><link>数据结构\栈.html</link><guid isPermaLink="false">数据结构/栈.md</guid><pubDate>Wed, 14 May 2025 01:10:38 GMT</pubDate></item><item><title><![CDATA[中序线索链表]]></title><description><![CDATA[ 
 <br><br>好的，我们来调整一下关于“标签”的约定，并更新解释和 C++ 代码。<br>新的约定：<br>
<br>Tag = 0: 表示对应的指针是一个 线索 (Thread)。

<br>lTag = 0: leftChild 指向中序前驱。
<br>rTag = 0: rightChild 指向中序后继。


<br>Tag = 1: 表示对应的指针指向一个 子节点 (Child)。

<br>lTag = 1: leftChild 指向左子节点。
<br>rTag = 1: rightChild 指向右子节点。


<br>我们将使用 bool类型的标签，其中 false 代表 0 (线索)，true 代表 1 (子节点)。<br><br>（这部分与之前相同，保持不变）<br>
<br>二叉树 (Binary Tree): 一种树形数据结构，每个节点最多有两个子节点，分别称为左子节点 (left child) 和右子节点 (right child)。
<br>中序遍历 (Inorder Traversal): 遍历二叉树的一种方式，顺序是：左子树 -&gt; 根节点 -&gt; 右子树。
<br><br>（这部分与之前相同，保持不变）<br>
利用空指针域，存放指向该节点在中序遍历序列中的前驱或后继节点的指针，从而优化遍历。<br><br>中序线索链表是一种特殊的二叉树，它通过修改节点的结构并利用空指针域来存储中序遍历的前驱和后继信息。<br>
<br>如果一个节点的左子节点指针为空 (nullptr)，则让它指向该节点的中序前驱，并且其左标志位 lTag 设为 0 (表示线索)。
<br>如果一个节点的右子节点指针为空 (nullptr)，则让它指向该节点的中序后继，并且其右标志位 rTag 设为 0 (表示线索)。
<br>如果指针指向的是实际的子节点：<br>
<br>左指针指向左子节点，则 lTag 设为 1。
<br>右指针指向右子节点，则 rTag 设为 1。
<br><br>template &lt;typename T&gt;
struct ThreadNode {
    T data;
    ThreadNode&lt;T&gt;* leftChild;
    ThreadNode&lt;T&gt;* rightChild;
    bool lTag; // false (0) if leftChild is a thread, true (1) if it's a child
    bool rTag; // false (0) if rightChild is a thread, true (1) if it's a child

    // Constructor: When a node is created, its links are initially not threads pointing to
    // specific predecessors/successors. They are either null or will point to children.
    // So, we initialize tags to 'true' (1), indicating they are (or would be) child links.
    // The threading process will change these to 'false' (0) if they become threads.
    ThreadNode(T val) : data(val), leftChild(nullptr), rightChild(nullptr), lTag(true), rTag(true) {}
};
<br>
<br>lTag 为 false (0) 表示 leftChild 是指向中序前驱的线索。
<br>lTag 为 true (1) 表示 leftChild 是指向左子节点的指针。
<br>rTag 为 false (0) 表示 rightChild 是指向中序后继的线索。
<br>rTag 为 true (1) 表示 rightChild 是指向右子节点的指针。
<br><br>在对普通二叉树进行中序遍历的过程中，设置线索和相应的标志位。指针 pre 指向当前访问节点在中序遍历中的前一个节点。<br>线索化过程 (inorderThreading):<br>
<br>中序遍历左子树（如果左指针是子节点链接，即 lTag == 1）。
<br>处理当前节点 current:

<br>处理左线索: 如果 current 没有左子节点 (current-&gt;leftChild == nullptr)，则将其左指针指向 pre，并设置 current-&gt;lTag = false (0, 表示线索)。如果它有左子节点，则 current-&gt;lTag = true (1, 表示子节点)。
<br>处理右线索: 如果 pre 不为空且 pre 没有右子节点 (pre-&gt;rightChild == nullptr)，则将 pre 的右指针指向 current，并设置 pre-&gt;rTag = false (0, 表示线索)。如果 pre 有右子节点，则 pre-&gt;rTag = true (1, 表示子节点)。


<br>更新 pre = current。
<br>中序遍历右子树（如果右指针是子节点链接，即 rTag == 1）。
<br>C++ 实现线索化 (按新约定):<br>template &lt;typename T&gt;
ThreadNode&lt;T&gt;* pre_threading_ptr = nullptr; //全局或成员变量

template &lt;typename T&gt;
void buildInorderThreadsRecursive(ThreadNode&lt;T&gt;* current) {
    if (current == nullptr) {
        return;
    }

    // 1. Traverse left subtree if it's a child link
    // For initial threading of an unthreaded tree, we can assume lTag is true if leftChild is not null.
    // The check current-&gt;lTag is more for robustness or re-threading.
    // A simpler initial threading just calls: buildInorderThreadsRecursive(current-&gt;leftChild);
    // Here, we'll assume tags might have been set by constructor or previous operations.
    if (current-&gt;lTag == true) { // If true (1), it's a child link
        buildInorderThreadsRecursive(current-&gt;leftChild);
    }

    // 2. Process current node
    // Set left thread for 'current' if it has no left child
    if (current-&gt;leftChild == nullptr) {
        current-&gt;lTag = false; // false (0) means THREAD
        current-&gt;leftChild = pre_threading_ptr;
    } else {
        current-&gt;lTag = true; // true (1) means CHILD (already was or should be)
    }

    // Set right thread for 'pre_threading_ptr' if it has no right child
    if (pre_threading_ptr != nullptr) {
        if (pre_threading_ptr-&gt;rightChild == nullptr) {
            pre_threading_ptr-&gt;rTag = false; // false (0) means THREAD
            pre_threading_ptr-&gt;rightChild = current;
        } else {
             // If pre_threading_ptr-&gt;rightChild is not null, it's a child.
             // Its rTag should be true (1). This would typically be set when that child was processed
             // or by the constructor.
             pre_threading_ptr-&gt;rTag = true; // Ensure it's marked as CHILD
        }
    }
    pre_threading_ptr = current; // Update predecessor

    // 3. Traverse right subtree if it's a child link
    if (current-&gt;rTag == true) { // If true (1), it's a child link
        buildInorderThreadsRecursive(current-&gt;rightChild);
    }
}

template &lt;typename T&gt;
void createInorderThreadedTree(ThreadNode&lt;T&gt;* root) {
    pre_threading_ptr&lt;T&gt; = nullptr;
    if (root == nullptr) return;

    // Call the recursive helper
    buildInorderThreadsRecursive(root);

    // The last node visited (pre_threading_ptr) in inorder traversal might have its
    // rightChild as nullptr. This should be a thread to "nullptr" (no successor).
    if (pre_threading_ptr != nullptr &amp;&amp; pre_threading_ptr-&gt;rightChild == nullptr) {
        pre_threading_ptr-&gt;rTag = false; // false (0) means THREAD (to nullptr)
        // pre_threading_ptr-&gt;rightChild remains nullptr
    }
}
<br><br>算法：<br>
<br>找到中序遍历的第一个节点：从根节点开始，只要当前节点的 lTag 为 1 (表示是子节点链接) 且左子节点存在，就一直向左下走。
<br>循环访问节点并找到下一个节点：

<br>访问当前节点 current。
<br>找到中序后继：

<br>如果 current-&gt;rTag == false (0, 右指针是线索)，那么 current-&gt;rightChild 就是中序后继。
<br>如果 current-&gt;rTag == true (1, 右指针指向右子树)，那么中序后继是其右子树中“最左下”的节点（即从 current-&gt;rightChild 开始，只要 lTag == 1 就一直向左下走）。




<br>C++ 实现中序遍历 (按新约定):<br>template &lt;typename T&gt;
void inorderTraversalThreaded(ThreadNode&lt;T&gt;* root) {
    if (root == nullptr) {
        std::cout &lt;&lt; "Tree is empty." &lt;&lt; std::endl;
        return;
    }

    // 1. Find the first node in inorder traversal
    ThreadNode&lt;T&gt;* current = root;
    // Go to the leftmost node, following child links
    while (current != nullptr &amp;&amp; current-&gt;lTag == true) { // true (1) means it's a child link
        current = current-&gt;leftChild;
    }
    // Now 'current' is the leftmost node (first in inorder)

    // 2. Traverse the tree using threads
    std::cout &lt;&lt; "Inorder traversal (threaded): ";
    while (current != nullptr) {
        std::cout &lt;&lt; current-&gt;data &lt;&lt; " ";

        // Move to the inorder successor
        if (current-&gt;rTag == false) { // false (0) means right child is a THREAD
            current = current-&gt;rightChild; // Successor is directly pointed by the thread
        } else { // rTag is true (1), meaning right child is a normal CHILD pointer
            // Successor is the leftmost node in the right subtree
            current = current-&gt;rightChild;
            // Go to the leftmost node of this right subtree
            while (current != nullptr &amp;&amp; current-&gt;lTag == true) { // true (1) means child link
                current = current-&gt;leftChild;
            }
        }
    }
    std::cout &lt;&lt; std::endl;
}
<br><br>#include &lt;iostream&gt;

// Node structure for Inorder Threaded Binary Tree
template &lt;typename T&gt;
struct ThreadNode {
    T data;
    ThreadNode&lt;T&gt;* leftChild;
    ThreadNode&lt;T&gt;* rightChild;
    bool lTag; // false (0) if leftChild is a thread, true (1) if it's a child
    bool rTag; // false (0) if rightChild is a thread, true (1) if it's a child

    // Constructor: Initialize tags to true (1), indicating child links by default.
    // If a pointer (e.g. leftChild) remains nullptr, the threading process
    // will set its corresponding lTag to false (0).
    ThreadNode(T val) : data(val), leftChild(nullptr), rightChild(nullptr), lTag(true), rTag(true) {}
};

template &lt;typename T&gt;
ThreadNode&lt;T&gt;* pre_node_for_threading_g = nullptr; // Global for simplicity

template &lt;typename T&gt;
void buildInorderThreadsRecursive(ThreadNode&lt;T&gt;* current) {
    if (current == nullptr) {
        return;
    }

    // 1. Traverse left subtree if it's a child link.
    // Assumes that if current-&gt;leftChild is not NULL, current-&gt;lTag is initially true (1).
    if (current-&gt;lTag == true) {
        buildInorderThreadsRecursive(current-&gt;leftChild);
    }

    // 2. Process current node
    // If current node has no left child, its left pointer becomes a thread.
    if (current-&gt;leftChild == nullptr) {
        current-&gt;lTag = false; // false (0) indicates THREAD
        current-&gt;leftChild = pre_node_for_threading_g;
    } else {
        // If it has a left child, ensure lTag is true (1) for CHILD.
        // This is typically already true from constructor or previous steps if tree was built with tags.
        current-&gt;lTag = true;
    }

    // If the predecessor has no right child, its right pointer becomes a thread to current.
    if (pre_node_for_threading_g != nullptr) {
        if (pre_node_for_threading_g-&gt;rightChild == nullptr) {
            pre_node_for_threading_g-&gt;rTag = false; // false (0) indicates THREAD
            pre_node_for_threading_g-&gt;rightChild = current;
        } else {
            // If predecessor has a right child, ensure its rTag is true (1) for CHILD.
            pre_node_for_threading_g-&gt;rTag = true;
        }
    }
    pre_node_for_threading_g = current; // Update predecessor

    // 3. Traverse right subtree if it's a child link.
    if (current-&gt;rTag == true) {
        buildInorderThreadsRecursive(current-&gt;rightChild);
    }
}

template &lt;typename T&gt;
void createInorderThreadedTree(ThreadNode&lt;T&gt;* root) {
    pre_node_for_threading_g&lt;T&gt; = nullptr;
    if (root == nullptr) return;

    buildInorderThreadsRecursive(root);

    // The last node visited (pre_node_for_threading_g) should have its right thread
    // point to nullptr (or a header node in more complex setups).
    // Its rTag should be false (0) if rightChild is indeed a thread (even to nullptr).
    if (pre_node_for_threading_g != nullptr &amp;&amp; pre_node_for_threading_g-&gt;rightChild == nullptr) {
        pre_node_for_threading_g-&gt;rTag = false; // false (0) means THREAD to nullptr
    }
}

template &lt;typename T&gt;
void inorderTraversalThreaded(ThreadNode&lt;T&gt;* root) {
    if (root == nullptr) {
        std::cout &lt;&lt; "Tree is empty." &lt;&lt; std::endl;
        return;
    }

    ThreadNode&lt;T&gt;* current = root;
    // Find the first node (leftmost)
    while (current != nullptr &amp;&amp; current-&gt;lTag == true) { // true (1) means CHILD link
        current = current-&gt;leftChild;
    }

    std::cout &lt;&lt; "Inorder Traversal (Threaded): ";
    while (current != nullptr) {
        std::cout &lt;&lt; current-&gt;data &lt;&lt; " ";

        if (current-&gt;rTag == false) { // false (0) means rChild is THREAD
            current = current-&gt;rightChild;
        } else { // rTag is true (1), rChild is a CHILD
            current = current-&gt;rightChild; // Go to right child
            // Then find the leftmost node in this right subtree
            while (current != nullptr &amp;&amp; current-&gt;lTag == true) { // true (1) means CHILD link
                current = current-&gt;leftChild;
            }
        }
    }
    std::cout &lt;&lt; std::endl;
}


int main() {
    // Construct a sample binary tree. Tags are initially true (1) by constructor.
    //      4
    //     / \
    //    2   5
    //   / \   \
    //  1   3   6
    // Inorder: 1, 2, 3, 4, 5, 6
    ThreadNode&lt;int&gt;* root = new ThreadNode&lt;int&gt;(4);
    root-&gt;leftChild = new ThreadNode&lt;int&gt;(2); // root-&gt;lTag remains true (1)
    root-&gt;rightChild = new ThreadNode&lt;int&gt;(5); // root-&gt;rTag remains true (1)

    root-&gt;leftChild-&gt;leftChild = new ThreadNode&lt;int&gt;(1);
    root-&gt;leftChild-&gt;rightChild = new ThreadNode&lt;int&gt;(3);
    root-&gt;rightChild-&gt;rightChild = new ThreadNode&lt;int&gt;(6);

    std::cout &lt;&lt; "Original tree structure created. Tags default to 1 (child link potential)." &lt;&lt; std::endl;

    createInorderThreadedTree(root);
    std::cout &lt;&lt; "Tree has been threaded." &lt;&lt; std::endl;

    inorderTraversalThreaded(root); // Expected output: 1 2 3 4 5 6

    // Manually check some threads for node '3' (inorder: 1, 2, *3*, 4, 5, 6)
    // Predecessor of 3 is 2. Successor of 3 is 4.
    // Node 3's leftChild will be a thread to 2 (lTag=0).
    // Node 3's rightChild will be a thread to 4 (rTag=0).
    ThreadNode&lt;int&gt;* node3 = root-&gt;leftChild-&gt;rightChild; // This is node 3
    if (node3-&gt;lTag == false) { // lTag is 0 (false) for thread
        std::cout &lt;&lt; "Node 3's left thread (lTag=0) points to: "
                  &lt;&lt; (node3-&gt;leftChild ? std::to_string(node3-&gt;leftChild-&gt;data) : "nullptr")
                  &lt;&lt; " (Expected: 2)" &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "Node 3's left is a child (lTag=1)." &lt;&lt; std::endl;
    }

    if (node3-&gt;rTag == false) { // rTag is 0 (false) for thread
        std::cout &lt;&lt; "Node 3's right thread (rTag=0) points to: "
                  &lt;&lt; (node3-&gt;rightChild ? std::to_string(node3-&gt;rightChild-&gt;data) : "nullptr")
                  &lt;&lt; " (Expected: 4)" &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "Node 3's right is a child (rTag=1)." &lt;&lt; std::endl;
    }

    // Manually check threads for node '1' (inorder: *1*, 2, 3, 4, 5, 6)
    // Predecessor of 1 is null. Successor of 1 is 2.
    // Node 1's leftChild will be a thread to nullptr (lTag=0).
    // Node 1's rightChild will be a thread to 2 (rTag=0).
    ThreadNode&lt;int&gt;* node1 = root-&gt;leftChild-&gt;leftChild; // This is node 1
    if (node1-&gt;lTag == false) {
         std::cout &lt;&lt; "Node 1's left thread (lTag=0) points to: "
                  &lt;&lt; (node1-&gt;leftChild ? std::to_string(node1-&gt;leftChild-&gt;data) : "nullptr")
                  &lt;&lt; " (Expected: nullptr for this simple setup)" &lt;&lt; std::endl;
    }
     if (node1-&gt;rTag == false) {
        std::cout &lt;&lt; "Node 1's right thread (rTag=0) points to: "
                  &lt;&lt; (node1-&gt;rightChild ? std::to_string(node1-&gt;rightChild-&gt;data) : "nullptr")
                  &lt;&lt; " (Expected: 2)" &lt;&lt; std::endl;
    }


    // Memory cleanup would be needed here for a complete program
    // delete ... (complex for threaded trees, omitted for brevity)

    return 0;
}

<br><br>（这部分与之前相同，保持不变）<br>优点：<br>
<br>快速遍历。
<br>查找前驱/后继容易。
<br>空间利用。
<br>缺点：<br>
<br>结构复杂。
<br>插入和删除复杂。
<br><br>
<br>核心目的： 利用空指针，实现不需要栈/递归的快速中序遍历，并方便查找中序前驱/后继。
<br>节点变化： 增加 lTag 和 rTag (布尔型)。

<br>leftChild 指针：

<br>lTag = false (0): 指向中序前驱 (是线索)。
<br>lTag = true (1): 指向左子节点。


<br>rightChild 指针：

<br>rTag = false (0): 指向中序后继 (是线索)。
<br>rTag = true (1): 指向右子节点。




<br>线索化： 在中序遍历过程中，用一个 pre 指针记录前驱，建立当前节点与 pre 之间的线索，并正确设置 Tag 为 false (0)。如果指针是指向子节点的，则 Tag 为 true (1)。
<br>遍历： 找到第一个节点（一直沿 lTag=true (1) 的左子链走到底），然后利用 rTag=false (0) 的右线索或右子树 (rTag=true (1)) 的最左节点不断找后继。
<br>这个版本应该符合你对标签值 0 和 1 的具体要求了。祝你期末备考顺利！]]></description><link>数据结构\中序线索链表.html</link><guid isPermaLink="false">数据结构/中序线索链表.md</guid><pubDate>Wed, 14 May 2025 07:47:19 GMT</pubDate></item><item><title><![CDATA[Bootstrap]]></title><description><![CDATA[ 
 <br><br>The bootstrap method estimates standard errors and computes confidence intervals for a statistic . It aims to estimate , the variance of , which depends on the unknown distribution function . The method involves two steps:<br>
<br>Step 1: Estimate  with .
<br>Step 2: Approximate  using simulation.
<br>For , Step 1 gives . In more complex cases, Step 2 is needed to approximate  because a simple formula cannot be derived.<br><br>Theorem (Law of Large Numbers).
Let  be i.i.d. with  and . Let . Then, for every ,

as . We say that  converges in probability to  and write .
<br>Let  i.i.d. then by law of large numbers, . Let , then<br><br>Hence, we can use the sample variance of the simulated values to approximate . <br><br>We can approximate  by simulation. To simulate from the distribution of  when the data are assumed to have distribution , we simulate  from  and then compute . Drawing an observation from  is equivalent to drawing one point at random from the original data set. Thus, to simulate  it suffices to draw  observations with replacement from .<br>Bootstrap Variance Estimation<br>
<br>Draw .
<br>Compute .
<br>Repeat steps 1 and  times, to get .
<br>Let


<br><br>There are three methods to construct bootstrap confidence intervals.<br>See All of Statistic p 111<br>
主要通过程序计算.
]]></description><link>数理统计\bootstrap.html</link><guid isPermaLink="false">数理统计/Bootstrap.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate></item><item><title><![CDATA[chap1-2]]></title><description><![CDATA[ 
 <br><br>Section 3 introduces the fundamental definitions of probability functions on sets endowed with a -algebra structure. Key concepts discussed include the interchange of  and , properties of disjoint unions (), and DeMorgan's laws.<br>Section 4 elaborates on conditional probability and independence, presenting them as generalizations of probability theory with broad applicability. The conditional probability is defined computationally as , while independence is defined as , implying . The section concludes with a discussion of simulation methods for approximating probabilities in complex real-world scenarios, along with an introduction to error estimation, which is further explored in Chapter 4 in the context of confidence intervals.<br>Section 5 introduces the concept of random variables as functions mapping from a sample space (equipped with a sigma algebra) to . It distinguishes between the probability mass function (pmf) for discrete distributions and the probability density function (pdf) for continuous distributions, denoted by . The cumulative distribution function (cdf) is defined as , where  represents the sample space. The notion of equality in distribution is defined as  if and only if . However, it is noted that  does not necessarily imply  (e.g., ). The section also outlines the properties of cdfs, including being nondecreasing, having a lower limit of 0, an upper limit of 1, and being right continuous. Additionally, it establishes that .<br>Section 6 focuses on discrete random variables, whose sample space is at most countable, and explores transformations between random variables, i.e., . In the case where  is one-to-one, the pmf of  is given by  ( and  are discrete). When  is piecewise one-to-one, the definition of  requires a case-by-case analysis.<br>Section 7 introduces continuous random variables, where the cdf is given by . The quantile of order  of the distribution of  is defined as a value  such that  and , also known as the () th percentile of . It is noted that the quantile may not be unique and that . For transformations, the pdf of  is given by  for  in , the support of . For continuous random vectors,  refers to the Jacobian of the transformation.<br>Section 8 discusses the expectation , and .<br>Section 9 covers specific expectations, including the mean , the variance , and the moment generating function (mgf)  (if it exists for ). The derivatives of  are explored, noting that , , and  is called the  th moment of .<br>Section 10 presents important inequalities: the existence of  implies the existence of  for . Markov's Inequality is stated as  for nonnegative  and positive . Chebyshev's Inequality is given as: for  with , for  we have . Jensen's Inequality states that for a convex function  (), we have .<br>Chapter 2 delves into multivariate distributions. Section 1 introduces the basic definitions and calculation techniques for two random variables. Section 2 presents transformations and the moment generating function (mgf) technique, which is effective for linear functions of random variables. If  then .<br>Section 3 introduces conditional distributions and expectations. The conditional pmf is given by , and the conditional pdf is . The probability  and . The conditional expectation of  ( is a function of ) is . The conditional variance is . Conditional expectation satisfies ,  which can serve as an alternative definition of conditional expectation.<br>Section 4 introduces the concept of independent random variables. If  have the joint pdf , then  are independent if and only if  can be written as , where  and  are nonnegative functions. For independent , we have . If  is the joint mgf, then  are independent if and only if .<br>Section 5 introduces the correlation coefficient , where the covariance . Independence implies that random variables are uncorrelated.<br>Section 6 extends the discussion to several random variables.  are said to be mutually independent if and only if . Consequently, . Let  be a -dimensional random vector, . If  is an  matrix of random variables then the mean of  is , the variance-covariance matrix is  (), and  and . All variance-covariance matrices are positive semi-definite, because  where  is a random variable.<br>Section 7 discusses transformations for several random variables. Section 8 addresses the linear combinations of random variables. If  are iid, then these random variables constitute a random sample of size  from that common distribution. The sample variance is defined by .]]></description><link>数理统计\chap1-2.html</link><guid isPermaLink="false">数理统计/chap1-2.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate></item><item><title><![CDATA[chap3]]></title><description><![CDATA[ 
 <br><br>, has the Bernouli distribution, with pmf:<br><br>.<br>For , the pmf is<br><br>The mgf of a binomial distribution is <br><br>Then .<br><br><br>A distribution with a pmf of the form  is called a negative binomial distribution, which means the probability that exactly  successes in the first  trials and a success on the  th trial. Its mgf is , for . <br>If , then  and . We say that  has a geometric distribution. <br><br>, , we say  has a multinomial distribution with parameters  and  if<br><br>The conditional pmf is interesting. <br><br><br><br>We say that  has a hypergeometric distribution with parameters . The mean of  is  and . <br><br> if  then . (check by mgf) <br><br><br><br><br><br>The definition of Gamma function is<br><br>  has the pmf<br><br> is also called the exponential distribution with parameter .  for . <br>The characteristic function of  is<br><br>
 If  then .
<br><br><br><br>When , then the exponential distribution  has mean  and variance .<br>Remark.
Some texts define the PDF of  as , while others use .
<br><br>Consider the special case  for given .  has the pdf<br><br>and the mgf<br><br>is said to have a chi-square distribution ( -distribution)  and any  of this form is called a chi-square pdf. Because  -distribution is a subfamily of  -distribution, we have .<br>Theorem.
Let  have a  distribution. If , then  exists and it is given by

<br>Proof.<br>
Note that<br><br>Make the change of variable  in the above integral. This results in<br><br>This simplifies to the desired result provided that .<br>
□<br><br>Let , , then  has the beta distribution, with pdf:<br><br>And <br><br><br>Let  have the standard normal distribution then .  is the CDF of .<br>Definition (Normal Distribution).
We say a random variable  has a normal distribution  if its pdf is<br>
The parameters  and  are the mean and variance of , respectively. 
<br>Theorem.
If  then . Particularly,<br>

<br>
Calculate the CDF of .
<br>Proof. Because , where  is , the cdf  for  is, for ,<br><br>That is,<br><br>And<br><br>If we change the variable of integration by writing , then<br><br>Hence the pdf  of the continuous-type random variable  is<br><br>Since  is a pdf<br><br>hence, it must be that  and thus  is .<br>
□<br>Theorem.
 are iid, then .
<br>
Prove by the characteristic function.
<br><br><br>We say that  follows a bivariate normal distribution if its pdf is given by<br><br>Where<br><br>and , for , and  satisfies . Clearly, this function is positive everywhere in . As we show in Section 3.5.2, it is a pdf with the mgf given by:<br><br>Then <br><br><br>Consider the random vector  where  are iid  random variables. Then the density of  is <br><br><br>We abbreviate this by saying that .<br>For the general case, suppose  is an , symmetric and positive semi-definite matrix. The spectral decomposition is , where ,  are the eigenvalues of  and the columns of ,  are the corresponding eigenvectors. The matrix  is orthogonal, i.e., . .<br>Definition (Multivariate Normal).
Say an  -dimensional random vector  has a multivariate normal distribution if its mgf is<br>
where  is a symmetric, positive semi-definite matrix and . We abbreviate this by saying that  has a  distribution.
<br>If  then . And we have<br><br>Further, the mgf of  is given by<br><br>Theorem.
If  and  is positive definite then .
<br>Proof.<br>
It's a consequence of <a data-href="#^f74ad8" href="about:blank#^f74ad8" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^f74ad8</a><a data-href="#^f74ad8" href="about:blank#^f74ad8" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 4</a>.<br>
□<br>Theorem (Linearity).
Suppose . Let  where  is  and . Then .
<br>Theorem.
Suppose . Let  where  is  and . Then .
<br>Proof.<br>
Calculate the mgf of .<br>
□<br>Particularly, suppose<br><br>Then .<br>Theorem (decomposite to independent subvector).
, , then  and  are independent iff , i.e.

<br>Proof.<br>
The joint mgf is<br><br>The product of their marginal mgfs is <br><br>Then  iff .<br>
□<br>Theorem (conditional distribution).
 are defined as above, then the conditional distribution of  is<br>

<br>Proof.<br>
See proof from Hogg p.204.<br>
□<br><br> indepedent; ;  has the pdf<br><br><br><br>By <a data-href="#^ea9b9f" href="about:blank#^ea9b9f" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^ea9b9f</a><a data-href="#^ea9b9f" href="about:blank#^ea9b9f" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 2</a>, for , <br><br>Thus<br><br><br>
We will show the technique to compute the pdf of  .
<br>Let  indepedent. Then the joint pdf of , say  is <br><br>Define a new random variable  by <br><br>The transformation technique  used to obtain the pdf  of . The equations<br><br>define a transformation from  to . Calculate the Jacobian of the transformation<br><br>Accordingly, the joint pdf of  and  is given by<br><br>where .<br>
The marginal pdf of  is then <br><br>In this integral let  and it is seen that<br><br>The distribution of the random variable  is usually called a  -distribution. , with max at . As , the  -distribution converges to the .<br><br>Let , . The joint pdf  of  and  is then<br><br>We define the new random variable<br><br>and we propose finding the pdf  of . The equations<br><br>By calculations, we have<br><br>The distribution of this random variable is usually called an  -distribution, .<br>By <a data-href="#^ea9b9f" href="about:blank#^ea9b9f" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^ea9b9f</a><a data-href="#^ea9b9f" href="about:blank#^ea9b9f" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 2</a>, for , ,<br><br>In particular,<br><br><br>Our final note concerns an important result for the later chapters on inference for normal random variables. It is a corollary to the  -distribution derived bove and is often referred to as Student's Theorem.<br>Theorem (Student's theorem).
Let  be iid random variables each having a normal distribution with mean  and variance . Define the random variables

Then

<br> has a  distribution.
<br> and  are independent.
<br> has a  distribution.
<br>The random variable

has a Student  -distribution with  degrees of freedom.

<br>Proof.<br>
Note that we have proved part (a) in Corollary 3.4.1. Let . Because  are iid  random variables,  has a multivariate normal distribution , where  denotes a vector whose components are all 1 . Let . Note that . Define the random vector  by . Consider the following transformation:<br><br>Because  is a linear transformation of multivariate normal random vector, by Theorem 3.5.2 it has a multivariate normal distribution with mean<br><br>where  denotes a vector whose components are all 0 , and covariance matrix<br><br>Because  is the first component of , we can also obtain part (a) by Theorem 3.5.1. Next, because the covariances are  is independent of . But . Hence,  is independent of , also. Thus part (b) is true.<br>Consider the random variable<br><br>Each term in this sum is the square of a  random variable and, hence, has a  distribution (Theorem 3.4.1). Because the summands are independent, it follows from Corollary 3.3 .1 that  is a  random variable. Note the following identity:<br><br>By part (b), the two terms on the right side of the last equation are independent. Further, the second term is the square of a standard normal random variable and, hence, has a  distribution. Taking mgfs of both sides, we have<br><br>Solving for the mgf of  on the right side we obtain part (c). Finally, part (d) follows immediately from parts (a)-(c) upon writing , (3.6.9), as<br><br>□<br><br>For  distributions with pdfs , supports , means  and variances , with positive mixing probabilities  where . Let  and consider the function<br><br><br><br>]]></description><link>数理统计\chap3.html</link><guid isPermaLink="false">数理统计/chap3.md</guid><pubDate>Sun, 18 May 2025 15:50:28 GMT</pubDate></item><item><title><![CDATA[chap4]]></title><description><![CDATA[ 
 <br><br>We continue the concepts of samples and statistics in chapter 2 while introducing the main tools of inference: confidence intervals and tests of hypotheses.<br>
In a typical statistic problem, we have  but don't know its pdf  or pmf . There are two cases: completely unkown and known down to a parameter  which may be a vector. Now we consider the second case, e.g.  with unkown ,  with unknown .<br>
 idd is called a random sample of size , and a function of the sample    is called a statistic. Once the sample is drawn, then  is called the realization of , where  and  is the realization of the sample.<br><img alt="chap4-20250313.png" src="lib\media\chap4-20250313.png"><br><img alt="1-chap4-20250313.png" src="lib\media\1-chap4-20250313.png"><br>In chapter 6 and 7 we discuss several theories of estimation in general. We briefly discuss the maximum likelihood estimator (mle) and then use it to obtain point estimators. Our discussion is for the continuous case.<br>
The information is involved in the likelihood function . An often-used estimate is the value of  that provides a maximum of . If unique, this is called the maximum likelihood estimator (mle) and we denote it as . In practice, it's easier to work with , and  solves . <br><br><br>Suppose  with density , . The log of the likelihood function is given by<br>
The first partial of the log-likelihood with respect to  is<br>
Setting this partial to 0 then we obtain the solution , thus the statistic  is the mle of . Because  we have  hence  is an unbiased estimator of .<br><br>Let  be one of zero. Let , , denote the probability of success. Then the pmf of  is<br>
If  is a random sample on , then<br>
Taking logs, we have<br>
The partial derivative of  is<br>
Thus ,  then  is an unbiased estimator of .<br><br>Let  then .<br>
The two partial derivatives simplify to <br><br>Setting these to 0 and solving simultaneously, we see that the mles are<br>
We kown that  is unbiased estimator for  and  is an unbiased estimator of . Thus for the mle of , , which is a biased estimator of . Note that the bias of  is  which converges to 0 as . However  is the preferred estimator of .<br><br>Let  be iid with the uniform  density; i.e. <br><br>Because  is in the support, differentiation is not helpful here. The likelihood function can be written as<br><br>The function  is a decreasing function of  for all  and is  otherwise. So the maximum occurs at the smallest value that  can assume; i.e. the mle is .<br><br>In this section we briefly discuss a histogram of the sample, which is an estimate of the pmf,  or the pdf, , of .<br><br>Assume  discrete with pmf . Let  be a random sample on . Suppose the space of  is finite, i.e. . An intuitive estimate of  is the relative frequency of  in the sample. <br><br>These estimators  constitute the nonparametric estimate of the pmf . Because <br><br> is an unbiased estimator of .<br>Next suppose  infinite, i.e.. In practice, we select a value  and make the groupings<br><br>Let  be the proportion of sample items that are greater than or equal to . Then the estimates  form our estimate of . <br>A histogram is a barplot of  versus . There are two cases to consider. For the first case, supppose the values  represent qualitative categories, e.g. hair colors of a population of people. Such histograms are usually called bar charts. An example is helpful here.<br><img alt="chap4-20250314.png" src="lib\media\chap4-20250314.png"><br><img alt="2-chap4-20250314.png" src="lib\media\2-chap4-20250314.png"><br>For the second case, assume that the values in the space  are ordinal in nature; i.e. the natural ordering of the   is numerically meaningful. In this case, the usual histogram is an abutting bar chart with heights  that are plotted in the natural order of the  , as in the following example.<br><img alt="4-chap4-20250314.png" src="lib\media\4-chap4-20250314.png"><br><img alt="5-chap4-20250314.png" src="lib\media\5-chap4-20250314.png"><br><br>For this section, assume that the random sample  is from a continuous random variable  with continuous pdf . For an arbitrary but fixed point  and a given , consider the interval . By the mean value theorem for integrals, we have for some , , that<br><br>Let the sample items fall in , which suggests the following nonparmetric extimate of  at a given :<br><br>More formally, a nonparametric estimator of  is<br><br>Then<br><br>Hence  is approximately an unbiased estimator of the density . <br><img alt="6-chap4-20250314.png" src="lib\media\6-chap4-20250314.png"><br><br>Recall that the random variable of interest  has density , where  is unknown. In Section 4.1, we discussed estimating  by a statistic , where  is a sample from the distribution of . But how much did  miss ? In this section, we embody this estimate of error in terms of a confidence interval, which we now formally define:<br><img alt="7-chap4-20250314.png" src="lib\media\7-chap4-20250314.png"><br><img alt="8-chap4-20250314.png" src="lib\media\8-chap4-20250314.png"><br><img alt="11-chap4-20250314.png" src="lib\media\11-chap4-20250314.png"><br>For , define  for .<br>Motivated by the CLT, we have<br>
<img alt="9-chap4-20250314.png" src="lib\media\9-chap4-20250314.png"><br><img alt="10-chap4-20250314.png" src="lib\media\10-chap4-20250314.png"><br><br>A practical problem of interest is the comparison of two distributions,  and . In this section, we compare the means of  and , denoted by  and . In particular, we obtain confidence intervals for the difference . Let  be a random sample from the distribution of  and  from , and all independent of one another. Let  and  and , which is an unbiased estimator of . This difference  is the numerator of the pivot random variable. By independence of the samples,<br><br>Let  and  be the sample variances. Then estimating the variances by the sample variances, consider the random variable<br><br>By CLT, this pivot variable has an approximate  distribution. This leads to the approximate  confidence interval for  given by<br><br>where  is the standard error of . This is a large sample  confidence interval for .<br><img alt="12-chap4-20250314.png" src="lib\media\12-chap4-20250314.png"><br><img alt="13-chap4-20250314.png" src="lib\media\13-chap4-20250314.png"><br><br>Omitted...<br><br>Omitted...<br><br>Definition (order statistic).
<img alt="14-chap4-20250314.png" src="lib\media\14-chap4-20250314.png">
<br><img alt="15-chap4-20250314.png" src="lib\media\15-chap4-20250314.png"><br>Note that the support of  an be partitioned into  mutually disjoint sets that map onto the support of  namely, . One of these  sets is , and the others can be found by permuting the   s in all possible way, thus the Jacobian equal to 1.<br><br><img alt="16-chap4-20250314.png" src="lib\media\16-chap4-20250314.png"><br><img alt="17-chap4-20250314.png" src="lib\media\17-chap4-20250314.png"><br>Omitted...<br><br><br> continuous rv with cdf . For , define the  th distribution percentile to be , where . Let  be the order statistics. Then<br><br>Then  serves as a  confidence interval for , the quantile of order .<br><br><img alt="chap4-2025033022.png" src="lib\media\chap4-2025033022.png"><br>
<img alt="1-chap4-2025033022.png" src="lib\media\1-chap4-2025033022.png"><br><br>See All of statistics Chapter 10.<br><br>We partition the parameter space  into two disjoint sets  and  and we wish to test<br><br>We call  the null hypothesis and  the alternative hypothesis. Let  be a r.v. and  be the range of . To test a hypothesis, we aim to find the rejection region(critical region) . If  we reject , otherwise retain .<br>Definition (critical region (rejection region)).
A test of  versus  is based on a subset  of . This set  is called the critical region (rejection region) and its corresponding decision rule (test) is<br>

<br>Usually, the rejection region  (critical region ) is of the form<br><br>where  is a test statistic and  is called a critical value. <br>Definition (power function, size (significance level), level).
The power function of a test with rejection region  is defined by<br>
The size of a test is defined to be<br>
A test is said to have level<a data-footref="[inline0" href="about:blank#fn-1-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a>  if its size is less than or equal to . 
<br>Definition (type I error, type II error).
Rejecting  when  is true is called a type I error. Retaining  when  is true is called a type II error.
<br>Definition (two-side test, one-side test).
A test of the form<br>
is called a two-side test. A test of the form<br>
is called a one-side test. The most common tests are two-sided.
<br><br><img alt="4-chap4-2025040315.png" src="lib\media\4-chap4-2025040315.png"><br><img alt="5-chap4-2025040315.png" src="lib\media\5-chap4-2025040315.png"><br>Next we consider four widely used tests: the Wald test, the  test, the permutation test, and the likelihood ratio test.<br><br>Let  be a scalar parameter, let  be an estimate of  and let  be the estimated standard error of .<br>Definition (The Wald Test).
Consider testing . Assume that the estimator  is asymptotically Normal, i.e.<br>
The size  Wald test is: reject  when .
<br> means that for ,<br><br>Thus<br><br>where .<br>Remark.
An alternative version of the Wald test statistic is  where  is the standard error computed at . Both versions of the test is valid.
<br>Let us consider the power of the Wald test when the null hypothesis is false.<br>
<img alt="9-chap4-2025040315.png" src="lib\media\9-chap4-2025040315.png"><br>Theorem (The rejection region of size  Wald test).
The size  Wald test rejects  versus  iff  where<br>
Thus, testing the typothesis is equivalent to checking whether the null value is in the confidence interval.
<br>Remark.
When we reject  we often say that the result is statistically significant.
<br><br><img alt="5-chap4-2025041621.png" src="lib\media\5-chap4-2025041621.png"><br><br><img alt="6-chap4-2025041621.png" src="lib\media\6-chap4-2025041621.png"><br><br>For every  we have a size  test with rejection region . Then<br><br> -value is the smallest level at which we can reject .<br>Remark (Warning!).
Do not confuse the  -value with . The  -value is not the probability that the null hypothesis is true.
<br>Suppose that the size  test is of the form<br><br>Then<br><br>where  is the observed value of . <br>
The  -value is the probability (under ) of observing a value of the test statistic the same as or more extreme than what was actually observed.
<br><br><img alt="3-chap4-2025040316.png" src="lib\media\3-chap4-2025040316.png"><br>
<img alt="4-chap4-2025040316.png" src="lib\media\4-chap4-2025040316.png"><br><br><br><img alt="chap4-2025041621.png" src="lib\media\chap4-2025041621.png"><br><br>The Pearson's  test is used for multinomial data. If  has a multinomial  distribution, then the MLE of  is  <br>
 need not to be independent!
<br>Definition (Pearson's  statistic).
Pearson's  statistic is<br>
where  is the expected value of  under .
<br>Under , . Hence the test: reject  if   has asymptotic level . The p-value is  where  is the observed value of the test statistic.<br><img alt="2-chap4-2025041621.png" src="lib\media\2-chap4-2025041621.png"><br><br><img alt="4-chap4-2025041621.png" src="lib\media\4-chap4-2025041621.png"><br><br><img alt="1-chap4-2025041712.png" src="lib\media\1-chap4-2025041712.png"><br>
<img alt="2-chap4-2025041712.png" src="lib\media\2-chap4-2025041712.png"><br>
<br>
<br>The definition is useless.<a href="about:blank#fnref-1-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>数理统计\chap4.html</link><guid isPermaLink="false">数理统计/chap4.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate><enclosure url="lib\media\chap4-20250313.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\chap4-20250313.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[chap5]]></title><description><![CDATA[ 
 <br><br><br>In this section, we formalize the notion of a sequence of random variables  getting "close" to another random variable  as . We say  converges in probability to , denoted as , if  for all .<br>One way to demonstrate convergence in probability is to use Chebyshev's Theorem: for a random variable  with variance , and for any , we have .<br>Let  be a sequence of independent and identically distributed (i.i.d.) random variables with mean  and variance . Let . Then .<br>Proof.<br>
The mean and variance of  are  and , respectively. By Chebyshev's Theorem, for all , we have<br><br>□<br>The Weak Law of Large Numbers (WLLN) implies that all the mass of the distribution of  converges to . In a sense, for large ,  is close to . But how close is it? For example, if we were to estimate  by , what can we say about the error of estimation? Actually, a Strong Law of Large Numbers (SLLN) can be proved. Moreover, we can weaken the hypothesis of the WLLN to require only that the  are i.i.d. with finite mean . Thus, the SLLN is a first moment theorem, while the WLLN requires the existence of the second moment.<br>Next, we list several theorems concerning convergence in probability, which is closed under linearity.<br>Theorem.
Suppose  and . Then .
<br>Proof.<br>
Using the triangle inequality, we have<br><br>□<br>Theorem.
For any constant , if , then .
<br>Theorem.
If  and the real function  is continuous at , then . (Note: the constant  is necessary.)
<br>Proof.<br>
Since  is continuous at , for all , there exists  such that  for . Thus,  implies . Substituting  for , we obtain<br><br>□<br>This theorem gives us many useful results, e.g., if , then ,  (for ), and  (for ).<br>Theorem.
Suppose  and . Then .
<br>Proof.<br>
We can write<br><br>Since  and , we have  and . Therefore,<br><br>Alternatively, .<br>
□<br><br><img alt="2-chap5-20250309.png" src="lib\media\2-chap5-20250309.png"><br><img alt="3-chap5-20250309.png" src="lib\media\3-chap5-20250309.png"><br><br>In many situations we can show statistic convergence without the distribution function of the statistic. But how close is the statistic to the estimator? <br><img alt="4-chap5-20250309.png" src="lib\media\4-chap5-20250309.png"><br><img alt="5-chap5-20250309.png" src="lib\media\5-chap5-20250309.png"><br>Theorem (Stirling's formula).

<br><img alt="6-chap5-20250309.png" src="lib\media\6-chap5-20250309.png"><br>Convergence in distribution is weaker than convergence in probability. Thus convergence in distribution is often called weak convergence.<br>Theorem.
If  converges to  in probability, then  converges to  in distribution.
<br>^4b6469<br>
Proof.<br>
Let  be a point of continuity of . For every ,<br><br>Basd on this inequality and the fact that  we see that<br><br>To get a lower bound, we proceed similarly with the complement to show that<br><br>Hence<br><br>Using a relationship between  and , it follows that <br><br>Letting  gives us the desired result.<br>
□<br><img alt="7-chap5-20250309.png" src="lib\media\7-chap5-20250309.png"><br><img alt="9-chap5-20250309.png" src="lib\media\9-chap5-20250309.png"><br>Theorem.
If  constant, then .
<br>Let  be given. Then<br><br>The converse is not true.<br>Theorem.
 then .
<br>The proof is similar to the above theorem.<br>We often use this result as follows. Suppose it is difficult to show that  converges to  in distributino, but it is easy to show that  converges in distribution to  and that  converges to 0 in probability. Hence by this last theorem.  as desired.<br>The next two theorems state general results.<br>Theorem.
 and  continuous on the support of . Then .
<br>An often-used application of this theorem occurs when we have a sequence of random variables  which converges in distribution to a standard normal random variable . Because the distribution of  is , it follows by the above theorem that  converges in distribution to a  distribution.<br>Theorem (Slutsky's theorem).
If  and  then .
<br>The proof is similar to <a data-href="#^4b6469" href="about:blank#^4b6469" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^4b6469</a><a data-href="#^4b6469" href="about:blank#^4b6469" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">^4b6469</a>  <br><br><img alt="10-chap5-20250309.png" src="lib\media\10-chap5-20250309.png"><br>Theorem.
<img alt="11-chap5-20250309.png" src="lib\media\11-chap5-20250309.png"> 
<br>One way of thinking of a sequence that is bounded in probability (or one that is converging to a random variable in distribution) is that the probability mass of  is not escaping to . At times we can use boundedness in probability instead of convergence in distribution. A property we will need  later is given in the following theorem:<br>Theorem.
Let  be a sequence of random variables bounded in probability and let  be a sequence of random variables that converges to 0 in probability. Then<br>

<br>Let  is given. Choose  and an integer  such that <br><br>Then<br><br>Remark.
It's similar to .
<br><br>The -method is employed to determine the asymptotic distribution of a function of a random variable, given the distribution of the random variable itself. This is analogous to problems discussed in previous chapters, such as <a data-href="#^721da5" href="about:blank#^721da5" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^721da5</a><a data-href="#^721da5" href="about:blank#^721da5" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 9</a> and <a data-href="#^1136a4" href="about:blank#^1136a4" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^1136a4</a><a data-href="#^1136a4" href="about:blank#^1136a4" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 10 (Slutsky's theorem)</a>.<br>Little-o Notation<br>The notation  signifies that  converges to 0 in probability relative to , formally:<br><br>Big-O Notation<br>The notation  indicates that  is bounded in probability as .<br>Theorem (Theorem 5.2.8. ).
If  is a sequence of random variables that is bounded in probability and , then  as .
<br>Proof of Theorem 5.2.8<br>Let . Then, there exist  and  such that for , . Since , we have:<br><br>Theorem (Theorem 5.2.9 (-Method)).
Let  be a sequence of random variables such that

If  is differentiable at  and , then

<br>Proof of Theorem 5.2.9<br>Since , it follows that<br><br>Because , it implies that  is bounded in probability. Therefore, by <a data-href="#^cf8d09" href="about:blank#^cf8d09" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^cf8d09</a><a data-href="#^cf8d09" href="about:blank#^cf8d09" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 14 (Theorem 5.2.8.)</a> ,  in probability. Hence, the result follows.<br><br>It's difficult to obtain , but quite easier from the mgf  that corresponds to the cdf . <br><img alt="15-chap5-20250309.png" src="lib\media\15-chap5-20250309.png"><br><img alt="16-chap5-20250309.png" src="lib\media\16-chap5-20250309.png"><br><img alt="17-chap5-20250309.png" src="lib\media\17-chap5-20250309.png"><br><br><img alt="18-chap5-20250309.png" src="lib\media\18-chap5-20250309.png"><br>Prove by characteristic function .<br>The Central Limit Theorem is saying that when  is large, fixed positive integer, the random variable  has an approximate normal distribution with mean  and variance . We can equivalently state the conclusion of the Central Limit Theorem as<br><br>This is often a convenient formulation to use.<br>Remark.
We know that  and  have approximately normal distributions, provided that  is large enough. Later, we find that other statistics also have approximate normal distributions, and this is the reason that the normal distribution is so improtant to statisticians. That is, while not many underlying distributions are normal, the distributions of statistics calculated from random samples arising from these distributions are often close to being normal.
<br>We can combine  -method with Central Limit Theorem. Assume that  is a random sample on  which has finite mean  and variance . Then by the Central Limit Theorem, we have<br><br>Hence by the  -method, we have<br><br>for a continuous transformation  such that .<br><br>This section discusses asymptotic concepts for sequences of random vectors.<br>Definition (convergence in probability).
Let  be a sequence of -dimensional random vectors, and let  be a random vector, all defined on the same sample space. We say that  converges in probability to  if

for all . As in the univariate case, we write .
<br>Theorem (Theorem 5.4.1).
Let  be a sequence of -dimensional random vectors, and let  be a random vector, all defined on the same sample space. Then  if and only if  for all .
<br>Based on <a data-href="#^479de5" href="about:blank#^479de5" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^479de5</a><a data-href="#^479de5" href="about:blank#^479de5" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 18 (Theorem 5.4.1)</a>, many theorems involving convergence in probability can be extended to the multivariate setting.<br>Let  be a sequence of i.i.d. random vectors with common mean vector  and variance-covariance matrix . Denote the vector of means by . By the Weak Law of Large Numbers,  in probability for each . Hence, by <a data-href="#^479de5" href="about:blank#^479de5" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^479de5</a><a data-href="#^479de5" href="about:blank#^479de5" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 18 (Theorem 5.4.1)</a>,  in probability.<br>Now consider the analog of the sample variances. Let . Define the sample variances and covariances by<br><br><br>If we define the  matrix , then  in probability.<br>Definition (convergence in distribution).
Let  be a sequence of random vectors with  having distribution function , and let  be a random vector with distribution function . Then  converges in distribution to  if

for all points  at which  is continuous. We write .
<br>Theorem.
Let  be a sequence of random vectors that converges in distribution to a random vector , and let  be a function that is continuous on the support of . Then  converges in distribution to .
<br>Theorem.
Let  be a sequence of random vectors with  having distribution function  and moment generating function . Let  be a random vector with distribution function  and moment generating function . Then  converges in distribution to  if and only if, for some ,

for all  such that .
<br>Theorem (Multivariate Central Limit Theorem).
Let  be a sequence of i.i.d. random vectors with common mean vector  and variance-covariance matrix  which is positive definite. Assume that the common moment generating function  exists in an open neighborhood of . Let

Then  converges in distribution to a  distribution.
<br>\begin{proof}<br>
Let  be a vector in the stipulated neighborhood of . The moment generating function of  is<br><br>where . Note that  are i.i.d. with mean 0 and variance . Hence, by the standard Central Limit Theorem,<br><br>Then  is the MGF of  evaluated at 1. Therefore, we must have<br><br>Because the last quantity is the moment generating function of a  distribution, the result follows.<br>
\end{proof}<br>Theorem (Theorem 5.4.5).
Let  be a sequence of -dimensional random vectors. Suppose . Let  be an  matrix of constants, and let  be an -dimensional vector of constants. Then .
<br>Theorem (Theorem 5.4.6).
Let  be a sequence of -dimensional random vectors. Suppose

Let  be a transformation  such that  and the  matrix of partial derivatives,

are continuous and do not vanish in a neighborhood of . Let  at . Then

]]></description><link>数理统计\chap5.html</link><guid isPermaLink="false">数理统计/chap5.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate><enclosure url="lib\media\2-chap5-20250309.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\2-chap5-20250309.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[chap6]]></title><description><![CDATA[ 
 <br><br><br>We need some regularity conditions. <br><br>Definition (Assumptions 6.1.1 (Regularity Conditions)).
Regularity conditions (R0)-(R5) are

<br>(R0) The cdfs are distinct; i.e., .
<br>(R1) The pdfs have common support for all .
<br>(R2) The point  is an interior point in .
<br>(R3) The pdf  is twice differentiable as a function of .
<br>(R4) The integral  can be differentiated twice under the integral sign as a function of .
<br>(R5) The pdf  is three times differentiable as a function of . Further, for all , there exist a constant  and a function  such that

with , for all  and all  in the support of .

<br><br>Since <br><br>thus<br><br>Apply  again,<br><br>We define the Fisher information:<br><br>The function  is called the score function. Recall the calculation of MLE, the mle  solves <br><br><br>Theorem (Rao-Cramér Lower Bound).
Let  be iid with common pdf  for . Assume that the regularity conditions (R0)-(R4) hold. Let  be a statistic with mean . Then

<br>Corollary.
Under the assumptions of <a data-href="#^a64f1e" href="about:blank#^a64f1e" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^a64f1e</a><a data-href="#^a64f1e" href="about:blank#^a64f1e" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Theorem 2 (Rao-Cramér Lower Bound)</a> , if  is an unbiased estimator of , so that , then the Rao-Cramér inequality becomes

<br>Definition (Efficiency).
The efficiency of that estimator is<br>

<br>Definition (Efficient Estimator).
Let  be an unbiased estimator of a parameter . The statistic  is called an efficient estimator of  iff<br>

<br>Theorem.
Assume  are iid with pdf  for  such that the regularity conditions (R0)-(R5) are satisfied. Suppose further that the Fisher information satisfies . Then any consistent sequence of solutions of the mle equations satisfies

<br>Definition.
Let  be independent and identically distributed with probability density function . Suppose  is an estimator of  such that . Then

<br>The asymptotic efficiency of  is defined to be


<br>The estimator  is said to be asymptotically efficient if the ratio in part (a) is 1 .
<br>Let  be another estimator such that . Then the asymptotic relative efficiency  of  to  is the reciprocal of the ratio of their respective asymptotic variances; i.e.,



<br><br>See All of statistic.<br>Definition (likelihood ratio test).
Consider testing

The likelihood ratio statistic is

where  is the MLE and  is the MLE when  is restricted to lie in .
<br>When , .<a data-footref="[inline0" href="about:blank#fn-1-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a> We have <br><br>
<br>The  -value for the test is , where  is the observed value. We reject  at level  if   -value. 
<br>We reject  at level  when , where .
<br>Consider another statistic <br><br>Under , , then we construct a test<a data-footref="[inline1" href="about:blank#fn-2-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[2]</a><br><br>Note that under , .<br>The third test is called Rao's score test. The scores are<br><br>Define the statistic<br><br>Recall that <br><br><br>Assume that . Then the Fisher information is given by<br><br>Recall that<br><br>We also have <br><br>The diagonal entries of  are<br><br>Similar to <a data-href="#^08320e" href="about:blank#^08320e" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^08320e</a><a data-href="#^08320e" href="about:blank#^08320e" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Corollary 3</a>, if  is an unbiased estimate of , then<br><br>We call it efficient if attaining the lower bound.<br>
 if  is diagonal.
<br><br>Theorem.
Let  be iid with pdf  for . Assume the regularity conditions hold. Then

<br>The likelihood equation,

has a solution  such that .
<br>For any sequence that satisfies (1),



<br>For , we have<br><br>where <br><br><br>Suppose  are i.i.d. . In this case  and . Then<br><br>Then<br><br>Let , then<br><br>Note that  is unbiased,  is biased.<br>
<br>
<br>Defined in Hogg<a href="about:blank#fnref-1-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
<br>This test is often referred to as a Wald-type test.<a href="about:blank#fnref-2-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>数理统计\chap6.html</link><guid isPermaLink="false">数理统计/chap6.md</guid><pubDate>Mon, 05 May 2025 13:34:55 GMT</pubDate></item><item><title><![CDATA[chap7]]></title><description><![CDATA[ 
 <br><br>This chapter focuses on finding "optimal" point estimators, particularly Minimum Variance Unbiased Estimators (MVUEs), by leveraging the concept of sufficiency.<br><br>
<br>
Goal: Find estimators that are close to the true parameter value.

<br>
Properties Reviewed:

<br>Consistency: Estimator converges in probability to the parameter as sample size increases.
<br>Unbiasedness: Expected value of the estimator equals the parameter.


<br>
Minimum Variance Unbiased Estimator (MVUE):

<br>Definition.
An estimator  is an MVUE of  if:

<br>It is unbiased: .
<br>Its variance is less than or equal to the variance of every other unbiased estimator of .

<br>
<br>
Loss Functions and Risk:

<br>Decision function<a data-footref="[inline0" href="about:blank#fn-1-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a> :  is the function of the observed value of the statistic  which is the point estimate of . One value of the decision function, say , is called a decision.

<br>Loss Function : Measures the "cost" of estimating  with . Common example: Squared Error Loss .
<br>Risk Function : Expected value of the loss function, .
<br>Minimizing risk uniformly is usually impossible.




<br>
Minimax Principle: Choose the decision rule  that minimizes the maximum risk:  for all other rules .

<br>
Likelihood Principle: If two experiments yield likelihood functions  and  that are proportional (), they contain the same information about , and the inference should be the same.

<br><br>
<br>
Idea: A statistic  is sufficient if it captures all the information about  contained in the sample. Knowing the value of  is equivalent to knowing the original sample for the purpose of inference about .

<br>
Formal Definition:

<br>Definition.
A statistic  with pdf/pmf  is sufficient for  if and only if the ratio

does not depend on . (This means the conditional distribution of the sample given  does not depend on ).
<br>
<br>Neyman Factorization Theorem: A much easier way to find sufficient statistics.
<br>Theorem (Neyman).
 is sufficient for  if and only if the joint pdf/pmf can be factored as:

where  does not depend on . The function  depends on the data only through the statistic .
<br>
<br>
Example (Normal Mean, Known Variance): Let  with  known. The joint pdf is:

Here,  and  is the second term, which does not involve . Thus,  is a sufficient statistic for .

<br>
Example (Poisson): Let . Joint pmf:

Here  and . Thus,  is sufficient for .

<br><br>
<br>Rao-Blackwell Theorem: Provides a method to improve any unbiased estimator by conditioning on a sufficient statistic.
<br>Theorem (Rao-Blackwell).
Let  be a sufficient statistic for , and let  be any unbiased estimator of . Define . Then:

<br> is a statistic (does not depend on ).
<br> (it's unbiased).
<br>. Equality holds iff  is already a function of .

<br>
<br>
Implication: To find an MVUE, we only need to consider functions of a sufficient statistic.

<br>
Sufficiency and MLEs:

<br>Theorem.
If a sufficient statistic  exists and a unique Maximum Likelihood Estimator (MLE)  exists, then  must be a function of .
<br>
<br>
Often, the MLE is a good starting point to find an MVUE. It might be biased, but we can adjust it (if necessary) to make it unbiased, and it will still be a function of the sufficient statistic.

<br>
Example (Exponential):  (mean ). Pdf is .

<br> is sufficient.
<br>MLE is .
<br> (biased).
<br>MVUE is .


<br><br>
<br>Completeness: A property of the family of distributions of a statistic.
<br>Definition.
A family of pdfs/pmfs  for a statistic  is complete if  for all  implies  (almost everywhere w.r.t. the distributions in the family).
<br>
<br>
Intuition: If a family is complete, the only unbiased estimator of 0 that is a function of  is the function .

<br>
Lehmann-Scheffé Theorem: Connects sufficiency, completeness, and MVUEs.

<br>Theorem (Lehmann-Scheffé).
If  is a complete sufficient statistic for , and  is an unbiased estimator of , then  is the unique MVUE of . (Uniqueness means any other MVUE must be equal to  almost everywhere).
<br>
<br>
Complete Sufficient Statistic: A statistic  that is both sufficient for  and whose family of distributions  is complete.

<br>
Example (Uniform): .

<br> is sufficient.
<br>The family of pdfs for  is  for . This family can be shown to be complete.
<br>.
<br>Therefore,  is the unique MVUE of .


<br><br>
<br>
A large class of common distributions where finding complete sufficient statistics is straightforward.

<br>
Definition (Regular Exponential Class): A family  is a regular exponential class if:

<br> for .
<br>The support  does not depend on .
<br> is a nontrivial continuous function of .
<br> and  are continuous (continuous case) or  is nontrivial (discrete case).


<br>
Key Result: For a random sample  from a regular exponential class distribution:

<br>Theorem.
The statistic  is a complete sufficient statistic for .
<br>
<br>
Implication: If you can write the pdf/pmf in the exponential form, you can immediately identify the complete sufficient statistic. Then, if you find any function of that statistic which is unbiased for , it is automatically the unique MVUE by Lehmann-Scheffé.

<br>
Example (Normal Mean, Known Variance): ,  known.<br>
.<br>
Here . So  is complete sufficient.<br>
Since ,  is the unique MVUE.

<br><br>
<br>
Often interested in estimating , not just .

<br>
If  is a complete sufficient statistic for , we seek a function  such that . If found,  is the unique MVUE of .

<br>
Techniques:

<br>Find an unbiased estimator  (perhaps not a function of ) and compute . (Rao-Blackwell).
<br>Guess a function  (often related to the MLE of ) and check if . Adjust if necessary.


<br>
Example (Bernoulli Variance): . Estimate .

<br> is complete sufficient.  is MVUE of .
<br>MLE of  is .
<br>.
<br>MVUE of  is .


<br>
Bootstrap Standard Errors: Can compute standard errors for MVUEs using bootstrap resampling (nonparametric or parametric).

<br><br>
<br>
Concepts extend to vector parameters .

<br>
Joint Sufficiency: A vector of statistics  is jointly sufficient if the definition or factorization theorem holds.


<br>
Completeness:  for all  implies .

<br>
Rao-Blackwell &amp; Lehmann-Scheffé: Apply similarly. If  is jointly complete sufficient for , and  is unbiased for , then  is the unique MVUE of .

<br>
Exponential Class (Multiparameter):

If regular, then  for  are jointly complete sufficient statistics for .

<br>
Example (Normal): .<br>
.<br>
, .<br>
,  are jointly complete sufficient.<br>
Equivalently,  and  are jointly complete sufficient.<br>
Since  and ,  and  are the unique MVUEs of  and .

<br><br>
<br>
Minimal Sufficient Statistic: A sufficient statistic that is a function of every other sufficient statistic. It achieves the maximum possible data reduction while retaining sufficiency.

<br>Often, complete sufficient statistics are minimal.
<br>If an MLE is itself sufficient, it is often minimal.


<br>
Ancillary Statistic: A statistic  whose distribution does not depend on the parameter .

<br>Location-Invariant: If , a statistic  is location-invariant if . Such statistics are ancillary for . Ex: , Range.
<br>Scale-Invariant: If , a statistic  is scale-invariant if  for . Such statistics are ancillary for . Ex: .
<br>Location- and Scale-Invariant: Combination of the above. Ex: .


<br><br>
<br>Key Relationship (Basu's Theorem):
<br>Theorem (Basu).
If  is a complete sufficient statistic for , then  is independent of any ancillary statistic .
<br>
<br>
The converse also holds: If  is sufficient and is independent of an ancillary statistic , then  must be complete.

<br>
This provides a powerful tool for proving independence.

<br>
Example (Normal  and ):

<br>Let the model be .
<br>If  is known,  is complete sufficient for .  is location-invariant, hence ancillary for . By Basu's Theorem,  and  are independent.
<br>If  is known,  is complete sufficient for .  is not ancillary for  (its distribution depends on ). We cannot use Basu's theorem here (though they are still independent).


<br>
If Sufficiency is Not Complete: An ancillary statistic might still provide information about the precision of an estimator based on the sufficient statistic (e.g., Example 7.9.5).

<br>
<br>
<br>or decision rule<a href="about:blank#fnref-1-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>数理统计\chap7.html</link><guid isPermaLink="false">数理统计/chap7.md</guid><pubDate>Sun, 11 May 2025 16:31:45 GMT</pubDate></item><item><title><![CDATA[Convergence of Random Variables]]></title><description><![CDATA[ 
 <br><br>See All of Statistic Chapter 5.<br><br><img alt="Convergence of Random Variables-2025032723.png" src="lib\media\convergence-of-random-variables-2025032723.png"><br>
<img alt="1-Convergence of Random Variables-2025032723.png" src="lib\media\1-convergence-of-random-variables-2025032723.png"><br><br><img alt="2-Convergence of Random Variables-2025032723.png" src="lib\media\2-convergence-of-random-variables-2025032723.png"><br><img alt="3-Convergence of Random Variables-2025032723.png" src="lib\media\3-convergence-of-random-variables-2025032723.png"><br><br><img alt="4-Convergence of Random Variables-2025032723.png" src="lib\media\4-convergence-of-random-variables-2025032723.png"><br><br>We say that  converges almost surely to , written  if <br><br>We say that  converges in  to , written  if<br><br><img alt="5-Convergence of Random Variables-2025032723.png" src="lib\media\5-convergence-of-random-variables-2025032723.png">]]></description><link>数理统计\convergence-of-random-variables.html</link><guid isPermaLink="false">数理统计/Convergence-of-Random-Variables.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate><enclosure url="lib\media\convergence-of-random-variables-2025032723.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\convergence-of-random-variables-2025032723.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw1]]></title><description><![CDATA[ 
 <br><img alt="hw1-20250302.png" src="lib\media\hw1-20250302.png"><br>
(a)<br><br>Then ,  is the median. Or say that .<br>
(b)<br><br>Then  .<br>
(c)<br><br>Then .<br><img alt="1-hw1-20250302.png" src="lib\media\1-hw1-20250302.png"><br><br>Then . <br><img alt="hw1-20250304.png" src="lib\media\hw1-20250304.png"><br><br><br><img alt="2-hw1-20250302.png" src="lib\media\2-hw1-20250302.png"><br><br><img alt="3-hw1-20250302.png" src="lib\media\3-hw1-20250302.png"><br><br> <img alt="4-hw1-20250302.png" src="lib\media\4-hw1-20250302.png"><br>Characteristic function , by the inverse formula<br><br>Then  is discrete random variable with .<br>
The mgf of  is <br><br>]]></description><link>数理统计\hw1.html</link><guid isPermaLink="false">数理统计/hw1.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate><enclosure url="lib\media\hw1-20250302.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw1-20250302.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw2]]></title><description><![CDATA[ 
 <br><img alt="hw2-20250304.png" src="lib\media\hw2-20250304.png"><br><img alt="hw2-20250305.png" src="lib\media\hw2-20250305.png"><br><br><br>Let  then .<br><img alt="1-hw2-20250305.png" src="lib\media\1-hw2-20250305.png"><br>The pdf of  is <br><br>Then <br><br><img alt="2-hw2-20250305.png" src="lib\media\2-hw2-20250305.png"><br>The pdf of  is<br><br>The pdf of  is<br><br>Hence  has an  -distribution with parameters  and .<br><img alt="3-hw2-20250305.png" src="lib\media\3-hw2-20250305.png"><br>Let<br><br>Then we have the transformation from  to . The Jacobian  is<br><br>Then the joint distribution of  is<br><br>The distribution of  is <br><br>Hence  has an  -distribution with parameter .<br><img alt="1-hw2-20250309.png" src="lib\media\1-hw2-20250309.png"><br>Exercise.
 is a random sample of  (normal is not required) with , compute the moments of sample mean and sample variance  and .
<br><br><br><br>Exercise.
 is a random sample from , compute , where  is the sample deviation.
<br><br><br>By student's theorem, . Then . <br><br>Exercise.
Suppose , and two samples are independent. Then<br>
(1) ;<br>
(2) Furthermore, if , then . where  is called mixed samples Variance.
<br>(1) Let , , then . Let<br><br>The equation<br><br>defines a transformation from  to . Calculate the Jacobian of this transformation<br><br>The pdf of  and  are <br><br>The joint pdf of  is <br><br>Then<br><br>Therefore .<br>(2) , . . Then <br><br> By student's theorem,  and  are independent. Thus  are independent. Thus  are independent. <br><br>Therefore<br><br>where  and .  ]]></description><link>数理统计\hw2.html</link><guid isPermaLink="false">数理统计/hw2.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate><enclosure url="lib\media\hw2-20250304.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw2-20250304.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw3]]></title><description><![CDATA[ 
 <br>5.1 7 9
5.2 7 18
5.3 11 12
<br><img alt="hw3-20250313.png" src="lib\media\hw3-20250313.png"><br>For <br><br>If  then  thus .<br>
If  then <br><br>Then for any , we have<br><br>Therefore , i.e.  in probability.<br><img alt="1-hw3-20250313.png" src="lib\media\1-hw3-20250313.png"><br><br><br>Since ,  is not an unbiased estimator of . But  has the mean  thus is an unbiased estimator of .<br><img alt="2-hw3-20250313.png" src="lib\media\2-hw3-20250313.png"><br>To assure the existence, we use the characteristic functions.<br><br><br>Denote .<br>
By the inverse formula<br><br>Then <br><br><img alt="3-hw3-20250313.png" src="lib\media\3-hw3-20250313.png"><br><br>Denote , then<br><br>Thus , which means<br><br>Let , using the  -method, we have<br><br>Therefore the limiting distribution of  is .<br>
<img alt="4-hw3-20250313.png" src="lib\media\4-hw3-20250313.png"><br>We know that<br><br>Let  then . Using the  -method, we have<br><br>Therefore <br><br><img alt="5-hw3-20250313.png" src="lib\media\5-hw3-20250313.png"><br>We know that<br><br>Let  then . Using the  -method, we have<br><br>Therefore<br><br>which means the variance of  is essentially free of .]]></description><link>数理统计\hw3.html</link><guid isPermaLink="false">数理统计/hw3.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate><enclosure url="lib\media\hw3-20250313.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw3-20250313.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw4]]></title><description><![CDATA[ 
 <br>• &nbsp; &nbsp;Section 4.1: 2, 6, 8  
• &nbsp; &nbsp;Section 4.2: 3, 9, 10
<br><img alt="hw4-20250321.png" src="lib\media\hw4-20250321.png"><br>(a)<br>
<img alt="Figure_1.png" src="lib\media\figure_1.png"><br>
The normal probability model is credible.<br>(b)<br>
For normal distributions, the mles are<br><br><br><br><br>Locate  on the plot:<br>
<img alt="Figure_1 1.png" src="lib\media\figure_1-1.png"><br>Overlay the normal pdf with these estimates:<br>
<img alt="Figure_1 2.png" src="lib\media\figure_1-2.png"><br>(c)<br><br>where  is the number of successes (pitchers weighing over 215 pounds) and  is the probability of success (a pitcher weighing over 215 pounds).<br><br>Let  then<br><br>(d)<br><br>where  is the CDF of the standard normal distribution . Then <br><br><img alt="1-hw4-20250321.png" src="lib\media\1-hw4-20250321.png"><br>The estimator<br><br>where<br><br>Its variance is <br><br>Its mgf is<br><br><img alt="2-hw4-20250321.png" src="lib\media\2-hw4-20250321.png"><br>For Poisson distribution with mean , we have<br><br>The likelihood function is <br><br>The first parital of the log-likelihood with respect to  is<br><br>Setting this partial to 0 and solving for , we obtain the solution , thus the mle of  is <br><br>The mle of the pmf is<br><br><br><img alt="6-hw4-20250321.png" src="lib\media\6-hw4-20250321.png"><br><br><img alt="3-hw4-20250321.png" src="lib\media\3-hw4-20250321.png"><br>Proof.<br>
(a) The characteristic function of  is <br><br>Then the characteristic function of  is<br><br>Then .<br>(b) define  to be the upper  critical point of a  -distribution with  degrees of freedom, i.e. . Using a simple algebraic derivation, we obtain<br><br>Then  an approximate  confidence interval for  is given by<br><br>(c)<br><img alt="hw4-20250322.png" src="lib\media\hw4-20250322.png"><br><img alt="1-hw4-20250322.png" src="lib\media\1-hw4-20250322.png"><br>□<br><img alt="4-hw4-20250321.png" src="lib\media\4-hw4-20250321.png"><br>(a)<br><br>, and  means , where . We obtain<br><br>Then a  confidence interval for  is given by<br><br>(b)<br>
By student's theorem, the rv  has a  -distribution with  degrees of freedom. Define<br><br>We obtain<br><br>Then a  confidence interval for  is given by<br><br>(c)<br>
Omitted<br><img alt="5-hw4-20250321.png" src="lib\media\5-hw4-20250321.png"><br><br><br>Then<br><br>Then <br><br>By the defintion of  -distribution, the rv<br><br>has a  -distribution with . Thus<br><br>Denote  to be . Then <br><br>Then the  confidence interval for  is given by<br><br>Then <br>]]></description><link>数理统计\hw4.html</link><guid isPermaLink="false">数理统计/hw4.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate><enclosure url="lib\media\hw4-20250321.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw4-20250321.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw5]]></title><description><![CDATA[ 
 <br>• &nbsp; &nbsp;Section 4.2:&nbsp; 17, 18, 19, 23, 25, &nbsp;27(a)(c)  
• &nbsp; &nbsp;Section 4.4: &nbsp;6(a), 7, &nbsp;9, &nbsp;26, &nbsp;30, &nbsp;31    
<br>Exercise.
<img alt="1-hw5-2025032722.png" src="lib\media\1-hw5-2025032722.png">
<br>The statistic model is <br><br>Let   are random sample of distribution . To calculate the mle of ,<br><br>Then<br><br>Thus the mle of  is<br><br>Thus . . When  is large, <br><br>Let  where  is the standard normal distribution. Then the  confidence interval of  is (we replace  by its estimator )<br><br>Put  then<br><br>Exercise.
<img alt="2-hw5-2025032722.png" src="lib\media\2-hw5-2025032722.png">
<br>(a) Trivial.<br>(b) .<br><br>(c)<br>
A confidence interval for  is<br><br>Exercise.
<img alt="3-hw5-2025032722.png" src="lib\media\3-hw5-2025032722.png">
<br><br>Denote , then<br><br>Thus . <br><br>Let , then the  confidence interval for  is <br><br>Exercise.
<img alt="4-hw5-2025032722.png" src="lib\media\4-hw5-2025032722.png">
<br>Let  be a random sample of ,  be of . Then . Therefore . Let  and  denote the realized values of the statistics  and . Let  then the  confidence interval of  is<br><br>Exercise.
<img alt="5-hw5-2025032722.png" src="lib\media\5-hw5-2025032722.png">
<br>Denote , then<br><br><br>Thus<br><br><br>Let<br><br>which is an unbiased estimator of . By Student's theorem,<br><br>Then<br><br>And<br><br> is an unbiased estimator of . Since  is independent of  and  is independent of  by Student's theorem,  is independent of  and . Thus<br><br>Denote , , then the  confidence interval of  is<br><br>We know that  thus<br><br>i.e.<br><br>Exercise ((a)(c)).
<img alt="6-hw5-2025032722.png" src="lib\media\6-hw5-2025032722.png">
<br>(a) <br><br>Then <br><br>(c)<br>
Trivial.<br>Exercise.
<img alt="7-hw5-2025032722.png" src="lib\media\7-hw5-2025032722.png">
<br>Let  denote the 3 order statistics based on the random sample , then the joint pdf of  is given by<br><br>Then <br><br>Exercise.
<img alt="8-hw5-2025032722.png" src="lib\media\8-hw5-2025032722.png">
<br><br><br><br><br><br><br>That is <br><br>Exercise.
<img alt="9-hw5-2025032722.png" src="lib\media\9-hw5-2025032722.png">
<br><br>Then <br><br>Exercise.
<img alt="10-hw5-2025032722.png" src="lib\media\10-hw5-2025032722.png">
<br><br>Exercise.
<img alt="11-hw5-2025032722.png" src="lib\media\11-hw5-2025032722.png">
<br><img alt="hw5-2025033022.png" src="lib\media\hw5-2025033022.png"><br>For binomial distribution ,  thus<br><br>is a  confidence interval for .<br>The interval means that the median number has the probability  lying the interval .<br>Exercise.
<img alt="12-hw5-2025032722.png" src="lib\media\12-hw5-2025032722.png">
<br>(a)<br><br>Then <br><br>(b)<br>
 and , then<br><br>Then the  confidence interval for  can be<br>]]></description><link>数理统计\hw5.html</link><guid isPermaLink="false">数理统计/hw5.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate><enclosure url="lib\media\1-hw5-2025032722.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\1-hw5-2025032722.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw6]]></title><description><![CDATA[ 
 <br>• &nbsp; &nbsp;Section 4.5: &nbsp;3, &nbsp;5, &nbsp;8, &nbsp;11  
• &nbsp; &nbsp;Section 4.6: &nbsp;7, &nbsp;8, &nbsp;9, &nbsp;10
<br>Exercise.
<img alt="hw6-2025041423.png" src="lib\media\hw6-2025041423.png"><br>
<img alt="1-hw6-2025041423.png" src="lib\media\1-hw6-2025041423.png">
<br>The power function is <br><br>Exercise.
<img alt="2-hw6-2025041423.png" src="lib\media\2-hw6-2025041423.png">
<br>The rejection set  is <br><br>The power of the test is <br><br>The significance level of the test is<br><br>When  is false, , then <br><br>Exercise.
<img alt="3-hw6-2025041423.png" src="lib\media\3-hw6-2025041423.png">
<br><br><br><br><br>The power function is <br><br>Let  and  then<br><br>We have <br><br>Exercise.
<img alt="4-hw6-2025041423.png" src="lib\media\4-hw6-2025041423.png">
<br>(1) Clearly, , then<br><br><br>Let  then . <br>(2) the power function is <br><br>Exercise.
<img alt="5-hw6-2025041423.png" src="lib\media\5-hw6-2025041423.png">
<br>(a) Let's test the null hypothesis that . Write this as ,  where . The nonparametric plug-in estimate of  is  , with estimated standard error<br><br>By Student's theorem, the random variable<br><br><br>Let <br><br>The critical region of  is <br><br>(b) Let , then<br><br>，因此在  显著性水平下有理由拒绝零假设，即休斯顿市中心悬浮颗粒密度大于墨尔本.<br>Exercise.
<img alt="6-hw6-2025041423.png" src="lib\media\6-hw6-2025041423.png">
<br>(a) .<br>(b) , let  be random sample of , . Then the estimator of  is . Define<br><br>Then , and<br><br><br>(c)  then <br><br>所以认为广告战役成功. <br>dist = NormalDistribution[0, 1]
CDF[dist, 2.53907]
1 - %
<br>Exercise.
<img alt="7-hw6-2025041423.png" src="lib\media\7-hw6-2025041423.png"><br>
<img alt="hw6-2025041515.png" src="lib\media\hw6-2025041515.png">
<br><br><br>Then .<br>Exercise.
<img alt="8-hw6-2025041423.png" src="lib\media\8-hw6-2025041423.png"><br>
<img alt="9-hw6-2025041423.png" src="lib\media\9-hw6-2025041423.png">
<br>When , <br><br><br><br>fDist = FRatioDistribution[12, 10]
Quantile[fDist, 0.95]
]]></description><link>数理统计\hw6.html</link><guid isPermaLink="false">数理统计/hw6.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate><enclosure url="lib\media\hw6-2025041423.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw6-2025041423.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw7]]></title><description><![CDATA[ 
 <br>Section 4.7：2， 5， 8， 9 （for ed7：1，4, 8, 9）

Section 6.1:&nbsp; &nbsp;2,&nbsp; 4,&nbsp; 6,&nbsp; 9,&nbsp; 10&nbsp; (for ed7:&nbsp; 2,&nbsp; 4,&nbsp; 5,&nbsp; 8,&nbsp; 9)
<br>Exercise.
<img alt="1-hw7-2025041710.png" src="lib\media\1-hw7-2025041710.png"><br>
<img alt="2-hw7-2025041710.png" src="lib\media\2-hw7-2025041710.png">
<br>Let  denote the frequency of , <br><br><br><br>In  trials we observe . We will test  versus . Since , , , , the test statistic is <br><br>The -value is<br><br>which is the smallest level at which we reject . Since ,  is rejected at  level of significance.<br>1 - CDF[ChiSquareDistribution[3], 8.38095]
<br>Exercise.
<img alt="hw7-2025041711.png" src="lib\media\hw7-2025041711.png">
<br>The number of each type is multinomial with probability . His theory of inheritance predicts that  is equal to<br><br>In  trials he observed . We will test  versus . Since, , and  34.75 , the test statistic is<br><br>The  value for a  is  . Since  is not larger than  we do not reject the null. The p-value is<br><br>which is not evidence against . <br>Exercise.
<img alt="1-hw7-2025041711.png" src="lib\media\1-hw7-2025041711.png">
<br>Let  denote the frequncy of , , . Let <br><br>We will test  versus . Denote<br><br>Fix , , then the test statistic is<br><br><br><br>We reject  at significant level , iff  -value , iff , where . Thus . The smallest value of  is .<br>alpha = 0.05;
Quantile[ChiSquareDistribution[11], 1 - alpha]
<br>Reduce[{8/3  k^2 &gt;= 19.6}, k, Reals]
<br>Exercise.
<img alt="hw7-2025041712.png" src="lib\media\hw7-2025041712.png">
<br>Let's analyze the data and perform the chi-squared goodness-of-fit test.<br>The observed data is:<br>
<br>: 
<br>: 
<br>: 
<br>: 
<br>: 
<br>The total number of observations is .<br>(a) Compute the corresponding chi-square goodness-of-fit statistic.<br>
<br>
Estimate the Poisson parameter : As hinted, we treat the  category as  for computing the sample mean (), which is the estimate for .



<br>
Calculate Expected Probabilities under :<br>
Using  with  ():

<br>
<br>
<br>
<br>
<br><br>



<br>
Calculate Expected Frequencies ():<br>
With :

<br>
<br>
<br>
<br>
<br>


<br>
Calculate the Chi-Square Statistic ():<br>
The formula is:

Plugging in the values:





So, the chi-square goodness-of-fit statistic is approximately 7.228.

<br>(b) How many degrees of freedom are associated with this chi-square?<br>The degrees of freedom () for a chi-squared goodness-of-fit test are calculated as:<br><br>Where:<br>
<br> = number of categories = 5 (categories are 0, 1, 2, 3, &gt;3)
<br> = number of parameters estimated from the data = 1 (we estimated )
<br>Therefore, .<br>
There are 3 degrees of freedom associated with this chi-square test.<br>(c) Do these data result in the rejection of the Poisson model at the  significance level?<br>
<br>Hypotheses:

<br>: The data follows a Poisson distribution.
<br>: The data does not follow a Poisson distribution.


<br>Significance Level: .
<br>Test Statistic: .
<br>Degrees of Freedom: .
<br>Critical Value: We need to find the critical value from the chi-squared distribution with 3 degrees of freedom for . This is the value  such that . Looking up this value in a chi-squared table or using statistical software:


<br>Decision Rule: Reject  if the test statistic  is greater than the critical value .
<br>Comparison: . Our test statistic is less than the critical value.
<br>Conclusion: Since the test statistic () is not greater than the critical value (), we fail to reject the null hypothesis () at the  significance level.
<br>Therefore, based on this test, these data do not result in the rejection of the Poisson model at the  significance level. There is not sufficient evidence to conclude that the data does not follow a Poisson distribution.<br>Exercise.
<img alt="1-hw7-2025041712.png" src="lib\media\1-hw7-2025041712.png">
<br>(a)<br><br>Let <br><br>i..<br><br>(b)<br><br> reaches its maximum iff  reaches its minimum. Thus .<br>Exercise.
<img alt="2-hw7-2025041712.png" src="lib\media\2-hw7-2025041712.png">
<br>(a)<br><br>reaches its maximum at . <br>(b)<br>
Find the pdf of . <br><br><br>Thus <br><br>Therefore<br><br>(c)<br>Definition (Consistency).
Let  be a random variable with cdf , . Let  be a sample from the distribution of  and let  denote a statistic. We say  is a consistent estimator of  if

<br><br><br>By the invariance of MLE, we have<br><br>Need to show that for any given ,<br><br>We have<br><br>Exercise.
<img alt="3-hw7-2025041712.png" src="lib\media\3-hw7-2025041712.png">
<br>First to find the mle of . Let<br><br>Let<br><br>Then<br><br>Denote <br><br>Then the mle of  is<br><br>To show  is consistent, it suffices to show  is consistent, which is consequence of the Law of Large number.<br>Exercise.
<img alt="4-hw7-2025041712.png" src="lib\media\4-hw7-2025041712.png">
<br>,<br><br><br>Then<br><br>The realization is<br><br>Exercise.
<img alt="5-hw7-2025041712.png" src="lib\media\5-hw7-2025041712.png">
<br><br>The pmf of  is <br><br>Thus<br><br><br>If  then <br><br>reaches its maximum at , thus .<br>If  then . Therefore<br>]]></description><link>数理统计\hw7.html</link><guid isPermaLink="false">数理统计/hw7.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate><enclosure url="lib\media\1-hw7-2025041710.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\1-hw7-2025041710.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw8]]></title><description><![CDATA[ 
 <br>Section 6.2:&nbsp; 9, 10, 11, 12,&nbsp; 16(ed7: 14)
<br>Exercise.
<img alt="hw8-2025042517.png" src="lib\media\hw8-2025042517.png">
<br>Proof.<br><br>So  is an unbiased estimator of . <br><br><br>The fisher information is<br><br>The Rao–Cramér lower bound in this case is<br><br>The variance of  is <br><br>The efficiency is<br><br>□<br>Exercise.
<img alt="1-hw8-2025042517.png" src="lib\media\1-hw8-2025042517.png">
<br><br>Let  then . <br><br><br><br><br>The efficiency is <br><br>Exercise.
<img alt="2-hw8-2025042517.png" src="lib\media\2-hw8-2025042517.png">
<br><br><br>Thus  is unbiased estimator of . <br><br><br><br><br>The efficiency is<br><br>Exercise.
<img alt="3-hw8-2025042517.png" src="lib\media\3-hw8-2025042517.png">
<br>(a)<br>
We say  if the pdf of <br><br>The characteristic function of  is<br><br>Then <br><br><br>Thus .<br>(b)<br><br>Let , , where  for .<br>(c)<br>
When , then . The confidence interval is <br><br>Exercise.
<img alt="4-hw8-2025042517.png" src="lib\media\4-hw8-2025042517.png">
<br>(a)<br><br><br><br><br><br>The efficiency is <br><br>(b)<br>
The log-likelihood function is <br><br>Let <br><br>i.e. <br><br>The solution of <a data-href="#^51d91f" href="about:blank#^51d91f" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^51d91f</a><a data-href="#^51d91f" href="about:blank#^51d91f" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a>, , is the mle of .<br><br>(c)<br><br>By Student's theorem,<br><br>Then the characteristic function of  is<br><br>The characteristic function of  is <br><br>By the inverse formula, the asymptotic pdf of  is<br><br>Thus .]]></description><link>数理统计\hw8.html</link><guid isPermaLink="false">数理统计/hw8.md</guid><pubDate>Sun, 04 May 2025 15:57:10 GMT</pubDate><enclosure url="lib\media\hw8-2025042517.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw8-2025042517.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw9]]></title><description><![CDATA[ 
 <br>Section 6.3: 6, 7,11,16,19
Section 6.4: 2, 3, 5, 6
<br>Exercise.
<img alt="1-hw9-2025050423.png" src="lib\media\1-hw9-2025050423.png">
<br><br><br><br><br>Then<br><br>We reject  at level  when<br><br>Remark.
Here we use  instead of , just for fun.
<br>Exercise.
<img alt="2-hw9-2025050423.png" src="lib\media\2-hw9-2025050423.png">
<br>Under the general alternatives,<br><br><br>Thus<br><br><br>Therefore <br><br>(* 设置参数 *)
alpha = 0.05;
n = 10;

(* 定义您的方程表达式 *)
equation = -n Log[n] - n - n Log[W] + W;

(* 计算所需的分布分位数 *)
lowerQuantile = Quantile[ChiSquareDistribution[1], alpha/2];
upperQuantile = Quantile[ChiSquareDistribution[1], 1 - alpha/2];

(* 联立两个不等式并求解 W *)
Reduce[
    (equation &lt;= lowerQuantile) &amp;&amp; (equation &gt;= upperQuantile),
    W
]
<br>Solve <a data-href="#^49c1a0" href="about:blank#^49c1a0" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^49c1a0</a><a data-href="#^49c1a0" href="about:blank#^49c1a0" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a> , we get<br><br>i.e. <br><br>Exercise.
<img alt="3-hw9-2025050423.png" src="lib\media\3-hw9-2025050423.png">
<br>(a)<br><br><br><br>To obtain the null distribution of , we first have . Then<br><br>(b)<br>\[Theta]0 = 3; 
n = 5;
alpha = 0.05;
Reduce[2/\[Theta]0  W - 8  n  Log[W] - 8  n + 8  n  Log[\[Theta]0] + 
   8  n  Log[4  n] &gt;= Quantile[ChiSquareDistribution[1], 1 - alpha], W]
<br><br>Then .<br>Exercise.
<img alt="4-hw9-2025050423.png" src="lib\media\4-hw9-2025050423.png">
<br>(a)<br><br><br><br>Let  then we have the solution . Since , denote <br><br><br>(b)<br><br><br><br><br><br>The Wald-test is <br><br>(c)<br><br>The Rao's score statistic is <br><br>Exercise.
<img alt="5-hw9-2025050423.png" src="lib\media\5-hw9-2025050423.png">
<br>(a)<br><br>where  and . Assuming all , then <br><br>Then<br><br>(b)<br>
When  is true, we have<br><br><br>Then<br><br>Thus <br><br>Hence .<br>Exercise.
<img alt="6-hw9-2025050423.png" src="lib\media\6-hw9-2025050423.png">
<br>(a)<br>
Let , then <br><br><br><br>Let , then the mles of ,  and  are<br><br>(b)<br><br><br>Let , then the mles of  and  are<br><br>Exercise.
<img alt="7-hw9-2025050423.png" src="lib\media\7-hw9-2025050423.png">
<br><br><br><br>The mles of  and  are<br><br>Exercise.
<img alt="hw9-2025050500.png" src="lib\media\hw9-2025050500.png">
<br><br><br>We have , then . The equality holds iff , . <br>Thus , .<br><br><br>Then<br><br><br>Therefore,  is unbiased,  is not unbiased.<br>-(1/2)*Integrate[(1/(2*\[Rho])^n)*n*x*(\[Theta] + \[Rho] - x)^(n - 1), {x, \[Theta] - \[Rho], \[Theta] + \[Rho]}] + (1/2)*Integrate[(1/(2*\[Rho])^n)*n*x*(x - \[Theta] + \[Rho])^(n - 1), {x, \[Theta] - \[Rho], \[Theta] + \[Rho]}]
<br>Exercise.
<img alt="1-hw9-2025050500.png" src="lib\media\1-hw9-2025050500.png">
<br>(a)<br>
The mle of  and  are<br><br>Then <br><br>Thus<br><br>where , thus the mle of  is<br><br>(b)<br><br>Thus the mle of  is <br>]]></description><link>数理统计\hw9.html</link><guid isPermaLink="false">数理统计/hw9.md</guid><pubDate>Wed, 07 May 2025 15:56:14 GMT</pubDate><enclosure url="lib\media\1-hw9-2025050423.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\1-hw9-2025050423.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw10]]></title><description><![CDATA[ 
 <br>Section 6.5:&nbsp; 4,&nbsp; 5(b),&nbsp; &nbsp;6,&nbsp; 7;&nbsp; &nbsp;
6(b): This Λ is a function of what F-statistic that would actually be used in this test?  
Section 7.1:&nbsp; 2,&nbsp; 4,&nbsp; 5,&nbsp; 8
<br>Exercise.
<img alt="hw10-2025051117.png" src="lib\media\hw10-2025051117.png">
<br>Consider testing<br><br>The likelihood ratio statistic is<br><br>where <br><br>then <br><br><br><br><br><br><br>We reject  at level  provided<br><br>We know that<br><br>Then  decreases when  and increases when ; . Thus the solution of <a data-href="#^bbac55" href="about:blank#^bbac55" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^bbac55</a><a data-href="#^bbac55" href="about:blank#^bbac55" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a> gives<br><br>for some .<br>Exercise.
<img alt="1-hw10-2025051117.png" src="lib\media\1-hw10-2025051117.png"><br>
<img alt="2-hw10-2025051117.png" src="lib\media\2-hw10-2025051117.png">
<br><br>The likelihood ratio statistic is<br><br><br><br>Let  then<br><br><br>When ,<br><br><br>Thus<br><br>So the test can be based on .<br>Exercise.
<img alt="3-hw10-2025051117.png" src="lib\media\3-hw10-2025051117.png">
<br>(a)<br><br><br>(b)<br>
Under ,<br><br>Exercise.
<img alt="4-hw10-2025051117.png" src="lib\media\4-hw10-2025051117.png">
<br><br><br>Let , then<br><br>Under ,<br><br>Then<br><br><br>Exercise.
<img alt="5-hw10-2025051117.png" src="lib\media\5-hw10-2025051117.png">
<br><br><br> is an unbiased estimator of . <br><br>Exercise.
<img alt="6-hw10-2025051117.png" src="lib\media\6-hw10-2025051117.png">
<br><br><br>The equality holds iff<br><br>Exercise.
<img alt="7-hw10-2025051117.png" src="lib\media\7-hw10-2025051117.png">
<br><br><br><br><br>When ,  is smaller maximum risk; otherwise,  is.<br><img alt="hw10-2025051120.png" src="lib\media\hw10-2025051120.png"><br>
<img alt="2-hw10-2025051120.png" src="lib\media\2-hw10-2025051120.png"><br>Exercise.
<img alt="8-hw10-2025051117.png" src="lib\media\8-hw10-2025051117.png">
<br><br><br><br>Let , then<br><br><br><br>Thus,  does not minimize . (If so, , which is a contradiction.)]]></description><link>数理统计\hw10.html</link><guid isPermaLink="false">数理统计/hw10.md</guid><pubDate>Wed, 14 May 2025 15:33:39 GMT</pubDate><enclosure url="lib\media\hw10-2025051117.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw10-2025051117.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw11]]></title><description><![CDATA[ 
 <br>Exercise.
<img alt="hw11-2025051819.png" src="lib\media\hw11-2025051819.png">
<br><br><br><br><br>Let  then<br><br>Then <br><br>does not depend on . Thus  is sufficient.<br>Exercise.
<img alt="1-hw11-2025051819.png" src="lib\media\1-hw11-2025051819.png">
<br><br><br>Then<br><br>does not depend on . Thus  is sufficient.<br>Exercise.
<img alt="2-hw11-2025051819.png" src="lib\media\2-hw11-2025051819.png">
<br>For ,<br><br>does not depend on . Thus  is sufficient.<br>In the general case,<br><br>does not depend on . Thus  is sufficient.<br>Exercise.
<img alt="3-hw11-2025051819.png" src="lib\media\3-hw11-2025051819.png">
<br><br><br>Then the Likelihood function is<br><br>By Neyman Factorization Theorem,<br><br>is the sufficient statistic for .<br>Exercise.
<img alt="5-hw11-2025051819.png" src="lib\media\5-hw11-2025051819.png">
<br><br><br><br><br><br><br><br><br><br><br><br><br><br>Exercise.
<img alt="6-hw11-2025051819.png" src="lib\media\6-hw11-2025051819.png">
<br>7.2.1 <br><br><br><br>The unbiased sufficient estimator is<br><br>7.2.2<br><br><br>The unbiased sufficient estimator is<br><br>7.2.3<br><br><br>The unbiased sufficient estimator is<br><br>Exercise.
<img alt="7-hw11-2025051819.png" src="lib\media\7-hw11-2025051819.png">
<br><br><br>Denote<br><br>Then<br><br><br><br>We have the identity:<br><br>Thus<br><br><br>Therefore<br><br><br>We have the indentity<br><br><br>Then<br><br>Hence<br>]]></description><link>数理统计\hw11.html</link><guid isPermaLink="false">数理统计/hw11.md</guid><pubDate>Tue, 20 May 2025 09:11:44 GMT</pubDate><enclosure url="lib\media\hw11-2025051819.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\hw11-2025051819.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Markov Chain]]></title><description><![CDATA[ 
 <br><br><br>好的，马尔可夫链具有一些非常重要的基本性质，这些性质是我们理解和应用它的基础。以下是一些核心的性质：<br>
<br>
马尔可夫性 (Markov Property) - 无记忆性

<br>定义： 这是马尔可夫链最根本的性质。它指系统的下一个状态只依赖于其当前状态，而与它过去的状态序列无关。
<br>数学表达： 。
<br>意义： 大大简化了对随机过程的分析，因为我们不需要追踪系统的全部历史。


<br>
状态空间 (State Space)

<br>定义： 系统所有可能状态的集合。
<br>分类：

<br>离散状态空间 (Discrete State Space)： 状态是可数的（有限个或无限可数个），例如天气（晴、阴、雨）、骰子点数（1, 2, 3, 4, 5, 6）。我们通常讨论的马尔可夫链都是离散状态的。
<br>连续状态空间 (Continuous State Space)： 状态是连续的，例如某个物理量的精确值。这通常涉及到更复杂的马尔可夫过程。
<br>有限状态空间 (Finite State Space)： 状态的个数是有限的。
<br>无限状态空间 (Infinite State Space)： 状态的个数是无限的。




<br>
转移概率 (Transition Probabilities)

<br>定义： 从一个状态  转移到另一个状态  的概率，记为  或 。
<br>性质：

<br> （概率非负且不大于1）
<br> （对于任意状态 ，从  出发到所有可能状态  的转移概率之和为1，其中  是状态空间）




<br>
时齐性 (Time Homogeneity) / 稳态转移概率 (Stationary Transition Probabilities)

<br>定义： 转移概率  不随时间  的变化而变化。也就是说，在任何时刻从状态  转移到状态  的概率都是相同的。
<br>数学表达：  对所有  成立。
<br>意义： 大多数我们初学的马尔可夫链都假设是时齐的，这使得分析更加简单。如果转移概率随时间变化，则称为非时齐马尔可夫链。


<br>
n步转移概率 (n-step Transition Probabilities)

<br>定义： 从状态  经过  步转移到状态  的概率，记为 。
<br>计算： 可以通过 Chapman-Kolmogorov 方程计算：。特别地，状态转移矩阵的 n 次幂  的  元就是 。


<br>以下是一些更深入的、描述马尔可夫链长期行为的性质：<br>
<br>
可达性 (Accessibility)

<br>定义： 如果从状态  出发，经过有限步（可能为0步）能够到达状态  (即  对某个  成立)，则称状态  从状态  可达，记为 。


<br>
互通性 (Communication)

<br>定义： 如果状态  和状态  相互可达 (即  且 )，则称状态  和状态  是互通的，记为 。
<br>性质： 互通是一种等价关系，可以将状态空间划分为若干个互通类。


<br>
不可约性 (Irreducibility)

<br>定义： 如果一个马尔可夫链中所有状态都属于同一个互通类（即从任意状态都可以到达任意其他状态），则称该马尔可夫链是不可约的。
<br>意义： 不可约马尔可夫链的行为更为整体和一致。


<br>
常返性 (Recurrence) 与瞬逝性 (Transience)

<br>常返状态： 如果从状态  出发，最终能以概率1返回到状态 ，则称状态  是常返的。
<br>瞬逝状态： 如果从状态  出发，最终返回到状态  的概率小于1（意味着有可能永远不再返回），则称状态  是瞬逝的。
<br>性质：

<br>在不可约马尔可夫链中，所有状态要么都是常返的，要么都是瞬逝的。
<br>对于有限状态空间的不可约马尔可夫链，所有状态都是常返的。




<br>
周期性 (Periodicity)

<br>定义： 状态  的周期  是使得  的所有步数  的最大公约数。如果  对所有  成立，则定义  或  (不同教材定义可能略有差异，但核心是不能返回自身)。
<br>非周期性： 如果一个状态的周期 ，则称该状态是非周期的。
<br>性质： 同一个互通类中的所有状态具有相同的周期。如果一个不可约马尔可夫链的所有状态都是非周期的，则称该链是非周期的。


<br>
平稳分布 (Stationary Distribution) / 极限分布 (Limiting Distribution)

<br>平稳分布 ()： 一个概率分布向量 ，其中  是系统处于状态  的概率，并且满足  以及 （即 ）。如果系统当前的概率分布是 ，那么经过一步转移后，其概率分布仍然是 。
<br>极限分布： 当时间  时，  的极限（如果存在）。
<br>重要定理： 对于一个不可约、非周期、正常返（对于有限状态空间，不可约即正常返）的马尔可夫链，存在唯一的平稳分布 ，并且该平稳分布也是极限分布，即  (与初始状态  无关)。
<br>意义： 描述了马尔可夫链在长时间运行后的稳定状态。


<br>这些是马尔可夫链的一些最基本的性质，理解它们对于进一步学习和应用马尔可夫链至关重要。根据研究的深入程度，还会有更多细致的性质和分类。<br><br>要证明一个随机过程是一个马尔可夫链，核心在于验证它是否满足马尔可夫性质 (Markov Property)，并且明确其状态空间 (State Space) 和 时间参数 (Time Parameter)。<br>Definition (Markov Property).
A stochastic process  has the Markov property if, for any  in ,

for all  and . In other words, the future is independent of the past given the present.
<br>以下是证明一个过程是马尔可夫链的一般步骤和关键点：<br>
<br>
定义状态空间 (Define the State Space ):

<br>首先，你需要清晰地定义系统所有可能的状态。状态空间  可以是有限的，也可以是无限可数的。
<br>确保每个状态都是互斥的，即系统在任何时刻只能处于一个状态。
<br>例子：

<br>天气模型：
<br>硬币投掷：
<br>排队系统中的顾客数量：




<br>
定义时间参数 (Define the Time Parameter ):

<br>确定过程是离散时间的还是连续时间的。对于初学者，我们通常关注离散时间马尔可夫链，时间参数  或 {}.
<br> 或  表示在时间步  (或时刻 ) 系统所处的状态。


<br>
验证马尔可夫性质 (Verify the Markov Property):
这是最关键的一步。马尔可夫性质指出，给定现在，未来与过去独立。更正式地说，对于任意时间步  和任意状态序列 ：

要证明这一点，你需要：

<br>
明确条件概率的含义： 理解  是在事件  发生的条件下事件  发生的概率。

<br>
利用过程的定义和规则： 根据你所研究的随机过程的具体规则和描述，推导其一步转移的条件概率。

<br>
展示“无记忆性”：

<br>考虑在已知当前状态  以及过去所有状态  的情况下，系统在下一个时刻  转移到状态  的概率。
<br>然后，证明这个概率仅仅依赖于当前状态 ，而与过去的状态  无关。也就是说，那些过去的状态信息对于预测下一个状态是多余的。

如何操作？

<br>
直接从定义出发： 有些过程的定义本身就隐含了这种无记忆性。例如，如果规则明确说明“下一步只看当前”，那么马尔可夫性质就比较容易验证。

<br>
通过计算条件概率：

<br>写出  的表达式。
<br>利用过程的内在机制，看看这个表达式是否可以简化为只依赖于  和  的形式，即 。
<br>如果可以，那么马尔可夫性质就得到了证明。






<br>
（可选，但常伴随）确定转移概率 (Determine Transition Probabilities):

<br>一旦证明了马尔可夫性质，通常下一步是确定（或者说明如何确定）一步转移概率 。
<br>如果这些转移概率不依赖于时间 ，那么这个马尔可夫链是时齐的 (Time-Homogeneous)。大多数基础讨论中的马尔可夫链都是时齐的。如果依赖于时间 ，即 ，则它是非时齐的 (Non-Time-Homogeneous)。证明过程本身是马尔可夫链时，并不强制要求时齐性，但通常会关注这一点。


<br>一个简单的例子来说明思路：简化的天气模型<br>假设我们有一个天气模型，规则如下：<br>
<br>如果今天下雨，明天有  的概率下雨，  的概率晴天。
<br>如果今天晴天，明天有  的概率下雨，  的概率晴天。
<br>明天的天气只取决于今天的天气。
<br>证明步骤：<br>
<br>
状态空间： 

<br>
时间参数： 离散时间， (天数)

<br>
验证马尔可夫性质：
我们要证明：

<br>
<br>考虑 : 根据模型规则，“明天的天气只取决于今天的天气”。所以，即使我们知道  的具体天气情况，只要 ，下一天是雨天的概率就是 0.7。因此，。同时，。两者相等。
<br>类似地，可以对所有可能的当前状态和下一个状态进行验证：

<br>
<br>
<br>


<br>由于对于所有情况，未来状态的概率只依赖于当前状态，所以该过程满足马尔可夫性质。<br>
<br>
转移概率（时齐）：

<br>
<br>
<br>
<br><br>
这些概率不随天数  变化，所以这是一个时齐马尔可夫链。


<br>总结关键：<br>证明的核心是严格地、形式化地展示出“给定现在，未来与过去无关”。这通常需要仔细分析随机过程的规则和定义，并运用条件概率的知识。对于一些复杂的过程，这可能涉及到更多的数学推导。]]></description><link>数理统计\markov-chain.html</link><guid isPermaLink="false">数理统计/markov-chain.md</guid><pubDate>Thu, 15 May 2025 09:30:08 GMT</pubDate></item><item><title><![CDATA[Models-Statistical-Inference-and-Learning]]></title><description><![CDATA[ 
 <br>This is the Chapter 6 of All of Statistics.<br><br><br>A typical statistical inference question: Given a sample  how do we infer ?<br><br><img alt="1-Models, Statistical Inference and Learning-2025032722.png" src="lib\media\1-models,-statistical-inference-and-learning-2025032722.png"><br>In general, a parametric model takes the form<br><br>where  is an unknown parameter (or vector) taking values in the parameter space .<br><br>A nonparametric model is a set  that cannot be parmeterized by a finite number of parameters. For example,  is nonparametric.<br><br><img alt="2-Models, Statistical Inference and Learning-2025032722.png" src="lib\media\2-models,-statistical-inference-and-learning-2025032722.png"><br>Remark.
We first discuss nonparametric inference. Two dominant approaches to statistical inference are frequentist inferenceand Bayesian inference.
<br><br>If  is a parametric model, we write <br><br>The subscript  indicates that the probability or expectation is w.r.t. ; it does not mean we are averaging over . Similarly, write  for the variance.<br><br>Many inferential problems can be identified as one of three types:<br>
<br>Estimation
<br>Confidence sets
<br>Hypothesis testing
<br><br>Point estimation refers to provide a single "best guess" of some quantity of interest, such as cdf, pdf, regression function....<br>Denote a point estimate of  by  or . <br>Remark.
Note that  is fixed, unknown quantity,  depens on the data so is a r.v.
<br><br>Say  unbiased if . <br>
Unbiasedness is considered less important than before.
<br>Say  consistent if .<br>The distribution of  is called the sampling distribution. The standard deviation of  is called the standard error, denoted by :<br><br>Often,  depends on the unknown . The estimated se is denoted by .<br><img alt="Models, Statistical Inference and Learning-2025032723.png" src="lib\media\models,-statistical-inference-and-learning-2025032723.png"><br>The mean squared error (MSE) is defined by<br><br>We have<br><br><img alt="1-Models, Statistical Inference and Learning-2025032723.png" src="lib\media\1-models,-statistical-inference-and-learning-2025032723.png"><br><img alt="2-Models, Statistical Inference and Learning-2025032723.png" src="lib\media\2-models,-statistical-inference-and-learning-2025032723.png"><br>
Which means the estimator is not always asymptotically Normal. But point estimators often have this property.<br><br><img alt="3-Models, Statistical Inference and Learning-2025032723.png" src="lib\media\3-models,-statistical-inference-and-learning-2025032723.png"><br>
Note that  is random and  is fixed.
<br>Remark (A interpret of confidence in tervals).
<img alt="4-Models, Statistical Inference and Learning-2025032723.png" src="lib\media\4-models,-statistical-inference-and-learning-2025032723.png">
<br><br><img alt="5-Models, Statistical Inference and Learning-2025032723.png" src="lib\media\5-models,-statistical-inference-and-learning-2025032723.png"><br><br>Point estimators often have a limite Normal distribution, meaning that . In this case we can sonstruct (approximate) confidence intervals as follows.<br><img alt="6-Models, Statistical Inference and Learning-2025032723.png" src="lib\media\6-models,-statistical-inference-and-learning-2025032723.png"><br><br><img alt="7-Models, Statistical Inference and Learning-2025032723.png" src="lib\media\7-models,-statistical-inference-and-learning-2025032723.png"><br><img alt="8-Models, Statistical Inference and Learning-2025032723.png" src="lib\media\8-models,-statistical-inference-and-learning-2025032723.png"><br><br><img alt="9-Models, Statistical Inference and Learning-2025032723.png" src="lib\media\9-models,-statistical-inference-and-learning-2025032723.png"><br><img alt="10-Models, Statistical Inference and Learning-2025032723.png" src="lib\media\10-models,-statistical-inference-and-learning-2025032723.png">]]></description><link>数理统计\models-statistical-inference-and-learning.html</link><guid isPermaLink="false">数理统计/Models-Statistical-Inference-and-Learning.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate><enclosure url="lib\media\1-models,-statistical-inference-and-learning-2025032722.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\1-models,-statistical-inference-and-learning-2025032722.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Parametric Inference]]></title><description><![CDATA[ 
 <br><br>See All of Statistic Chap 9<br><img alt="1-Parametric-Inference-2025041715.png" src="lib\media\1-parametric-inference-2025041715.png"><br>
There are two methods for estimating , the method of moments and the method of maximum likelihood.<br><br>When estimating a parameter , we may only be interested in a function , called the parameter of interest. Other components of  are nuisance parameters. For instance, if  and we want to estimate , then  is the parameter of interest, with  being the nuisance parameter. As an example, if  and we want to know the fraction  of the population with test scores larger than 1, then .<br><br>Suppose that the parameter  has  components. For  , define the  moment<br><br>and the  sample moment<br><br>Definition (method of moments estimator).
The method of moments estimator  is defined to be the value of  such that

<br><br>Let . Then , and . By <a data-href="#^2f0756" href="about:blank#^2f0756" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^2f0756</a><a data-href="#^2f0756" href="about:blank#^2f0756" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Definition 1 (method of moments estimator)</a>, <br><br><br>Let . Then . We need to solve the quations<br><br>The solution is <br><br>Theorem (Theorem 9.6).
Let  denote the method of moments estimator. Under appropriate conditions on the model, the following statements hold:

<br>The estimate  exists with probability tending to 1.
<br>The estimate is consistent: .
<br>The estimate is asymptotically Normal:


where

 and 
<br><br>Let  i.i.d. with pdf .<br>Definition (Likelihood function).
The likelihood function is defined by

The log-likelihood function is defined by .
<br>The likelihood function is just the joint density of the data , except that we treat it is a function of the parameter . Thus, . <br>Definition (maximum likelihood estimator).
The maximum likelihood estimator MLE, denoted by , is the value of  that maximizes .
<br>
Often, it is easier to work with the log-likelihood.
<br>Remark.
If we multiply  by any positive constant  (not depending on  ) then this will not change the mle. Hence, we shall often drop constants in the likelihood function.
<br><br>Let . The parameter is , and the likelihood function (ignoring some constants) is:<br><br>where  is the sample mean and . The last equality above follows from the fact that , which can be verified by writing  and then expanding the square.<br>The log-likelihood is<br><br>Solving the equations<br><br>we conclude that  and . It can be verified that these are indeed global maxima of the likelihood.<br><br>Here is an example that many people find confusing. Let . Recall that<br><br>Consider a fixed value of . Suppose  for some . Then,  and hence . It follows that  if any . Therefore,  if  where .<br>Now consider any . For every  we then have that  so that . In conclusion,<br><br>Now  is strictly decreasing over the interval . Hence, .<br><br>The MLE  possesses many properties that make it an appealing choice choice of estimator<br>
<br>The MLE is consistent:  where  denotes the true value of the parameter ;
<br>The MLE is equivariant: if  is the MLE of  then  is the MLE of ;<a data-footref="[inline0" href="about:blank#fn-1-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a>
<br>The MLE is asymptotically Normal: ; also, the estimated standard error se can often be computed analytically;
<br>The MLE is asymptotically optimal or efficient: roughly, this means that among all well-behaved estimators, the MLE has the smallest variance, at least for large samples;
<br>The MLE is approximately the Bayes estimator. (This point will be explained later.)
<br>In sufficiently complicated problems, the MLE will no longer be a good estimator.<br>We focus on the simpler situations where the MLE works well, assuming that the model satisfies certain regularity conditions, which are essentially smoothness conditions on .<br><br>Consistency means that the mle converges in probability to the true value.<br>Definition (Kullback-Leibler distance).
If  and  are pdf's, define the Kullback-Leibler distance<a data-footref="[inline1" href="about:blank#fn-2-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[2]</a> between  and  to be

It can be shown that  and . For any  write  to mean .
<br>We will say that the model  is identifiable if  implies that  0. This means that different values of the parameter correspond to different distributions. <br>Theorem.
Let  denote the true value of . Define

and . Suppose that

and that, for every ,

Let  denote the MLE. Then .
<br><br>
<br>
<br>when  admits an inverse.<a href="about:blank#fnref-1-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
<br>This is not a distance in the formal sense because  is not symmetric.<a href="about:blank#fnref-2-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>数理统计\parametric-inference.html</link><guid isPermaLink="false">数理统计/Parametric-Inference.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate><enclosure url="lib\media\1-parametric-inference-2025041715.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\1-parametric-inference-2025041715.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[simple-approximation]]></title><description><![CDATA[ 
 <br><br>If we want to verify a property that holds for general Borel-measurable function , we can follow four steps as below.<br>
<br>Verify the property when  is indicator function.
<br>Verify the property when  is nonnegative simple function.
<br>Verify the property when  is Borel-measurable function
<br>Verify the property when  is General Borel-measurable function
<br>An example is as follow.<br><br>Theorem.
Let  be a random variable on a probability space  and let  be a Borel-measurable function on . Then<br>
and if this quantity is finite, then<br>

<br>Proof.<br>
Step 1. Indicator functions. (Omitted)<br>Step 2. Nonnegative simple functions. (Trivial because of the linearity)<br>Step 3. Nonnegative Borel-measurable functions. Let  be an arbitraty nonnegative Borel-measurable function defined on . For each positive integer , define the sets<br><br>Remark.
这样的定义是为了保证在  时，每个划分越来越细，同时 . 而且对于任意 ， 是  的加细（ 的划分点都包含在  的划分点集内）
<br>For eac fixed , the sets  correspond to the partition<br><br>At the next stage , the partition points include all those at stage  and new partition points at the midpoints between te old ones. Because of this fact, the simple functions<br><br>satisfy . Furthermore, these functions become more and more accurate approximations of  as  becomes larger; indeed  for every . From Step 2, we knoe that <br><br>for every . Letting  and using the Monotone Convergence Theorem, on both sides of the equation, we obtain<br><br>This proves when  is a nonnegative Borel-measurable function.<br>Step 4. General Borel-measurable function. (consider  where  and  are both nonnegative Borel-measurable functions)<br>□]]></description><link>数理统计\simple-approximation.html</link><guid isPermaLink="false">数理统计/simple-approximation.md</guid><pubDate>Fri, 02 May 2025 16:55:31 GMT</pubDate></item><item><title><![CDATA[Yau contest]]></title><description><![CDATA[ 
 <br><br>D<br><img alt="1-yau-contest-2025051416.png" src="lib\media\1-yau-contest-2025051416.png"><br>Okay, this problem (Problem 6 from your image) is from the area of statistical decision theory, specifically focusing on estimation theory and minimax estimators. Since you're a beginner in statistics, understanding this problem and its solution will require familiarity with several key concepts.<br>Here's a breakdown of the topics and materials you'll need to study:<br>I. Foundational Probability and Statistics Concepts:<br>
<br>
Random Variables:

<br>Definition: What a random variable is (discrete and continuous).
<br>Probability Distributions: Understanding probability mass functions (PMF) for discrete variables and probability density functions (PDF) for continuous variables.
<br>Expected Value (Mean): .
<br>Variance: .


<br>
Specific Probability Distributions:

<br>Normal (Gaussian) Distribution: .

<br>Its PDF: .
<br>Properties: Mean , variance .
<br>The problem states . This means each  is normally distributed with mean  and variance .




<br>
Independent Random Variables:

<br>Understanding what it means for random variables to be independent. This is crucial as the problem states  are independent.


<br>II. Statistical Estimation Theory:<br>
<br>
Parameter Estimation:

<br>The goal is to estimate an unknown parameter (here, the mean vector ) based on observed data (here, ).
<br>Estimator: A function of the data used to estimate the parameter. In this problem, the estimator being considered is  itself, meaning  is used to estimate .


<br>
Loss Function :

<br>A function that quantifies the "cost" or "loss" incurred when the true parameter is  and our estimate is .
<br>In this problem, the loss function is a weighted squared error loss:

This means errors in estimating  are weighted by . Errors for components with smaller  (and thus smaller variance  for ) are penalized more heavily relative to their scale if the  in the denominator were not there. The  in the denominator effectively normalizes the squared error by the variance of the observation  if .


<br>
Risk Function :

<br>The expected loss of an estimator  when the true parameter is .
<br>. The expectation is taken over the distribution of , given .
<br>For the estimator  (meaning ):


Since ,  is the variance of , which is .<br>
So, .<br>
This shows that the estimator  has a constant risk (it doesn't depend on the true value of ). An estimator with constant risk is called an equalizer rule.


<br>III. Bayesian Statistics (Used in the Proof Strategy):<br>
<br>
Prior Distribution :

<br>In Bayesian statistics, the unknown parameter  is treated as a random variable having a prior distribution, which reflects our beliefs about  before observing data.
<br>The solution considers independent priors . This is a common choice for mathematical convenience.


<br>
Posterior Distribution :

<br>After observing data , the prior belief is updated to a posterior distribution using Bayes' theorem: , where  is the likelihood of the data given the parameter.


<br>
Bayes Estimator :

<br>An estimator that minimizes the Bayes risk (defined below) for a given prior .
<br>For squared error loss $ (di - \theta_i)^2 -th component of the Bayes estimator is the mean of the posterior distribution of : $\delta{\pi,i}(X) = \mathbb{E}[\theta_i | X]$.
<br>The problem uses a slightly modified loss. For the loss , the Bayes estimator for  will still be  (since the  and  are independent across ).
<br>The "Recall" part of the problem gives a formula for the posterior mean when the likelihood is normal and the prior is normal (this is a standard result for conjugate priors):<br>
If  and , then the posterior distribution of  is also normal:

The posterior mean is .<br>
In the problem's context, for estimating :<br>
 (so  is ,  is , variance is ).<br>
Prior  (so , prior variance is ).<br>
The Bayes estimator for  (posterior mean ) is:

The solution in the image has . This is slightly different from what I derived for the posterior mean.<br>
Let's re-check the posterior mean given in the problem: .<br>
Here: , , . And for the prior: , .<br>
So, .<br>
The solution's notation  is indeed the posterior mean, which simplifies to .


<br>
Bayes Risk  (or  in the solution):

<br>The expected risk with respect to the prior distribution of : .
<br>The Bayes estimator  minimizes this Bayes risk. The minimum Bayes risk is .
<br>The solution calculates the Bayes risk for the Bayes estimator  (where  parameterizes the prior variance).<br>
. This is not quite right.<br>
The Bayes risk for  is .<br>
It's also .<br>
Alternatively, for squared error type losses, the Bayes risk of the Bayes estimator  is .<br>
The solution states .<br>
This term  is  or related to posterior variance.<br>
The posterior variance is .<br>
The Bayes risk for component  under loss  is .<br>
So for loss , it would be .<br>
The solution has . This is slightly different.<br>
Let's check: The Bayes risk  for component  under squared error loss.<br>
For the weighted loss , the Bayes risk for  is .<br>
The solution states the associated Bayes risk is .<br>
This formula for the Bayes risk of a Bayes estimator under normal-normal model with weighted squared error loss is a standard result that you'd find in textbooks on Bayesian decision theory.


<br>IV. Minimax Estimation:<br>
<br>
Minimax Estimator :

<br>An estimator  is minimax if it minimizes the maximum possible risk:


<br>Finding minimax estimators can be hard.


<br>
Proving Minimaxity (Key Theorem Used in the Solution):<br>
A common way to prove an estimator  is minimax is to:

<br>Show that  is an equalizer rule, meaning its risk  is constant (doesn't depend on ). Let this constant risk be .
<br>Find a sequence of prior distributions  such that the Bayes risk of the Bayes estimator for , denoted , converges to  as .<br>
If both conditions hold, then  is minimax.<br>
(This relies on the fact that  and ).<br>
The theorem states: If  is an equalizer rule with risk , and if there's a sequence of priors  such that the corresponding Bayes risks  converge to , then  is minimax.


<br>Applying the Theorem to the Problem:<br>
<br>
The estimator  (where ) has a constant risk . So,  is an equalizer rule.

<br>
The solution considers a sequence of priors , so  is the prior.<br>
The Bayes risk for this sequence of priors is  (as per the solution's formula).

<br>
The solution then takes the limit as  (this corresponds to a sequence of priors that become increasingly "non-informative" or "flat").

As , each term .<br>
So, .
There's a discrepancy here. The constant risk of  is . The limit of Bayes risks is .<br>
For  to be minimax, the limit of Bayes risks should converge to the constant risk of , which is .
Let's re-read the solution carefully:<br>
"The associated Bayes risk is ."<br>
This simplifies to . This part is consistent.<br>
"Clearly, as , , which is identical to the Bayes risk of ."<br>
This limit calculation in the solution image is incorrect.<br>
, not .
The solution seems to have a typo in this limit evaluation or in the expression for .
Let's look at the Bayes risk of the estimator  itself, under the prior .<br>
. Since  (constant),<br>
.<br>
The theorem for minimaxity is: an equalizer rule  with risk  is minimax if , or if there's a sequence of priors  such that .
The solution strategy is sound: show  is an equalizer, and its risk is the limit of some Bayes risks.<br>
The risk of  is . This is the .<br>
We need to find a sequence of priors  (here, parameterized by ) such that the minimal Bayes risk  converges to .<br>
The Bayes estimator component is .<br>
The Bayes risk associated with this estimator is (as given in the solution, which I re-derived as ):<br>
.<br>
As , . This does not equal .
Possible misunderstanding or error in the provided solution text:<br>
The statement in the solution "Clearly, as , " is incorrect for the given .<br>
Perhaps the intended Bayes risk calculation or the prior setup was different.
Let's assume the theorem application is standard. For  to be minimax, its constant risk (2022) must be the limit of the Bayes risks of the Bayes estimators for a sequence of priors.
What if the estimator  itself is a Bayes estimator or a limit of Bayes estimators?<br>
The Bayes estimator is .<br>
As , .<br>
So, .<br>
This means the estimator  is a limit of Bayes estimators.<br>
If an estimator is Bayes for some prior  (or a limit of Bayes estimators) and has constant risk, then it is minimax. This is another standard result.

<br> has constant risk .
<br>.<br>
This approach (showing an equalizer rule is a limit of Bayes rules) is a common technique.

Let's review the general conditions for minimaxity often used:

<br>If an estimator has constant risk (is an equalizer rule) and is Bayes with respect to some prior, it is minimax.
<br>If an estimator  is an equalizer rule with risk , and if for any  there exists a prior  such that the Bayes risk  (i.e., the supremum of Bayes risks is ), then  is minimax. This is equivalent to finding a sequence  such that .

The solution's text "This implies that  with  gives a least favorable sequence of priors and  is minimax" suggests they are trying to use the latter condition.<br>
The error must be in the expression for  or its limit.
Let's re-examine the calculation of the Bayes risk of .<br>
The risk of an estimator  for  under loss  is .<br>
The Bayes risk for component  is .<br>
For the Bayes estimator , the Bayes risk is .<br>
This is known to be . (The expectation is over the marginal distribution of ).<br>
.<br>
So, the -th component of Bayes risk for the Bayes estimator is .<br>
Then the total Bayes risk is .<br>
Now, let's take the limit as :

So,

This matches the constant risk of .<br>
So, with this corrected formula for the Bayes risk of the Bayes estimator, the solution's logic holds.
The discrepancy was that the solution in the image has .<br>
My derived Bayes risk for the Bayes estimator is .
Let's check the solution's expression for .<br>
.<br>
This is the formula written in the solution. If this is the Bayes risk, then its limit as  is indeed .
There is a confusion about which specific formula for Bayes risk is being used or if there's a standard result that leads to the solution's expression for .<br>
Commonly, .<br>
If , then for squared error loss , the Bayes risk is .<br>
For weighted squared error , Bayes risk is .<br>
Here . So it should be .
Why does the solution use ?<br>
Let  (precision of prior) and  (precision of data).<br>
Posterior mean . Here , so .<br>
Posterior variance .<br>
The Bayes risk of the Bayes estimator for  is .<br>
Since the data  itself is random,  is actually constant (not dependent on  value for normal-normal case). So .<br>
So the Bayes risk for  under squared error  is .<br>
Then for the weighted loss , the Bayes risk is .<br>
.
It seems my derivation of the Bayes risk is , whose limit is .<br>
The solution states the Bayes risk is .<br>
Let's break down the solution's term :<br>
This is .<br>
If this is the correct Bayes risk for the Bayes estimator , then its limit as  is indeed .
So, there is a conflict between the standard formula for the Bayes risk  and the expression the solution provides for .<br>
The Bayes risk is .<br>
.<br>
.<br>
The quantity  is the mean squared error of the Bayes estimator . For Bayesian estimation under a specific prior, this MSE averaged over the prior of  and data  is the component of the Bayes risk.<br>
The Bayes risk for estimating  with  under squared error loss is . No, this is not it.<br>
It's .<br>
Or .<br>
The Bayes risk for squared error for  is  (if  is used) or simpler, .<br>
So the weighted Bayes risk is .<br>
If this is correct, then the limit is .
The solution's claim that "Clearly, as , " seems to imply that the terms of their  sum should go to 1.<br>
If , this limit is .<br>
If , this limit is .

<br><img alt="yau-contest-2025051612.png" src="lib\media\yau-contest-2025051612.png"><br><img alt="1-yau-contest-2025051612.png" src="lib\media\1-yau-contest-2025051612.png"><br><img alt="2-yau-contest-2025051612.png" src="lib\media\2-yau-contest-2025051612.png"><br>
<img alt="3-yau-contest-2025051612.png" src="lib\media\3-yau-contest-2025051612.png">]]></description><link>数理统计\yau-contest.html</link><guid isPermaLink="false">数理统计/yau-contest.md</guid><pubDate>Sat, 17 May 2025 14:18:42 GMT</pubDate><enclosure url="lib\media\1-yau-contest-2025051416.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\1-yau-contest-2025051416.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[傅里叶分析初步]]></title><description><![CDATA[ 
 <br><br><br>傅里叶级数的三种主要收敛类型——逐点收敛 (Pointwise Convergence)、一致收敛 (Uniform Convergence) 和绝对收敛 (Absolute Convergence)——之间存在明确的层级关系和重要的区别。<br>首先，我们来定义这三种收敛性，并针对傅里叶级数  (或其实数形式 ) 进行说明：<br>
<br>逐点收敛 (Pointwise Convergence)

<br>定义: 对于级数 ，如果对于定义域中的每一个固定的 ，数列部分和  收敛于一个值 ，则称该级数在  处逐点收敛于 。如果对定义域中所有  都如此，则称级数逐点收敛于函数 。
<br>傅里叶级数:  (或对应实数形式的部分和) 当  时，对于每个固定的 ，其极限等于  (或在不连续点等于 )。
<br>特点: 不同点的收敛速度可能不同。极限函数  不一定是连续的，即使级数的每一项都是连续的。


<br>一致收敛 (Uniform Convergence)

<br>定义: 对于级数 ，如果部分和序列  一致收敛于函数 ，即对于任意 ，存在一个与  无关的 ，使得当  时，对定义域中的所有 ，都有 。这等价于 。
<br>傅里叶级数: 。
<br>特点: 收敛速度不依赖于 。如果级数的每一项  都是连续的，并且级数一致收敛于 ，则极限函数  也必定是连续的。这是非常重要的性质。


<br>绝对收敛 (Absolute Convergence)

<br>定义 (对于函数项级数): 如果级数  对于每个  都收敛，则称级数  在该点  绝对收敛。
<br>傅里叶级数: 对于傅里叶级数，我们通常关心其系数的绝对收敛性，即  (或等价地 ) 是否收敛。这是因为 。如果系数级数  收敛，那么根据Weierstrass M-判别法，傅里叶级数  必然一致收敛且绝对收敛（作为函数项级数，即  对每个  都收敛，因为它等于 ）。
<br>特点: 绝对收敛是一个很强的条件。


<br>它们之间的关系：<br>
<br>绝对收敛  一致收敛 (对于傅里叶级数，指系数绝对收敛)

<br>如果傅里叶级数的系数满足 ，那么根据 Weierstrass M-判别法 (取 ，因为  对所有  成立)，傅里叶级数  必定一致收敛。
<br>同时，由于  收敛，所以傅里叶级数本身也作为函数项级数绝对收敛于每个点。


<br>一致收敛  逐点收敛

<br>这是由定义直接得出的。如果一个级数在整个定义域上一致地逼近一个函数，那么它在定义域内的每一个特定点也必然逼近该函数在该点的值。


<br>总结层级关系：<br>对于傅里叶级数：<br>系数绝对收敛 ()  一致收敛  逐点收敛<br>反向关系（通常不成立）：<br>
<br>逐点收敛  一致收敛

<br>一个傅里叶级数可能在每个点都收敛到函数值（或跳跃点的中点值），但不是一致收敛。例如，对于有跳跃间断点的函数，即使其傅里叶级数在跳跃点收敛到中点值，在跳跃点附近也会出现吉布斯现象 (Gibbs Phenomenon)，这妨碍了一致收敛。
<br>即使对于连续函数，其傅里叶级数也可能逐点收敛（例如，根据Carleson定理， 函数的傅里叶级数几乎处处逐点收敛），但不一定一致收敛。Lusin曾构造出连续函数，其傅里叶级数在某些点发散。


<br>一致收敛  绝对收敛 (指系数的绝对收敛)

<br>存在一致收敛的傅里叶级数，但其系数的绝对和  是发散的。例如，某些Hölder连续函数（如  且 ）的傅里叶级数是一致收敛的，但其系数不一定绝对收敛。


<br>逐点收敛  绝对收敛

<br>这从前面两条就可以推断出来。例如，条件收敛的数值级数（如 ）就是逐点收敛但不绝对收敛的例子。函数项级数也有类似情况。


<br>影响收敛性的函数性质：<br>
<br>函数的连续性与光滑性起着关键作用：

<br>逐点收敛: 函数有界变差 (Dirichlet-Jordan 条件)；满足Dini条件；Hölder连续 () 等都能保证逐点收敛。
<br>一致收敛: 函数连续且有界变差；函数Hölder连续 ()；函数是  (一阶连续可微) 等都能保证一致收敛。一般来说，函数越光滑，其傅里叶系数衰减越快，越容易一致收敛。
<br>绝对收敛 (): 需要更强的光滑性。例如，根据Bernstein定理，若  且 ，则系数绝对收敛。若函数是  且  (对于周期  的区间，二阶导数连续)，则系数通常绝对收敛。如果函数可以解析延拓到包含实轴的一个带状区域，其傅里叶系数也会指数衰减，从而绝对收敛。


<br>简而言之：<br>
<br>绝对收敛是最强的，它保证了一致收敛和逐点收敛。
<br>一致收敛比逐点收敛强，它保证了逐点收敛，并且如果级数项连续，则极限函数也连续。
<br>逐点收敛是最弱的，不保证另外两者。
<br>理解这些区别对于分析傅里叶级数的行为至关重要。<br>傅里叶级数收敛性分析：逐点收敛、一致收敛与绝对收敛的比较<br>引言：傅里叶级数收敛性问题<br>傅里叶级数是一种强大的数学工具，它允许我们将一个周期函数 f(x) 表示为一系列正弦和余弦函数（或复指数函数）的无穷和 [1]。对于周期为 2L 的函数 f(x)，其傅里叶级数通常写作：<br><br>其中傅里叶系数  和  通过积分计算得出 [3]：<br><br><br>或者使用复指数形式：<br><br>其中<br><br>傅里叶级数的概念起源于19世纪初傅里叶对热传导问题的研究 [2]。然而，一个基本且深刻的问题随之产生：这个无穷级数在何种意义下收敛？并且，它是否收敛到原始函数 f(x)？ [6]。<br>傅里叶级数的收敛性并非理所当然，它取决于函数 f(x) 的性质以及我们所考虑的收敛类型 [5]。历史上，关于傅里叶级数收敛性的探讨充满了挑战，傅里叶本人的断言曾受到拉格朗日等数学家的质疑，而后来的研究（如du Bois-Reymond）也揭示了连续函数的傅里叶级数也可能在某点发散 [2]。这表明，理解傅里叶级数的收敛性需要严谨的数学框架，区分不同的收敛模式至关重要。级数表示中的 ~ 符号提醒我们这仅仅是一个形式上的展开，并不自动保证等式成立 [5]。<br>核心挑战在于，傅里叶级数的构建依赖于函数的全局积分性质（计算系数），而收敛性则可能涉及函数在某一点的局部性质或整个区间上的整体性质。这种全局与局部的联系是傅里叶分析的核心，也是其复杂性的来源。<br>本报告旨在深入探讨傅里叶级数的三种主要收敛类型：逐点收敛（pointwise convergence）、一致收敛（uniform convergence）和绝对收敛（absolute convergence）[8]。我们将详细阐述它们的定义、收敛条件（包括狄利克雷条件、若尔当判别法、狄尼判别法、伯恩斯坦定理等）、蕴含关系、局限性以及它们在函数性质保持（如连续性、可微性）和收敛速度方面的差异。理解这些不同类型的收敛对于理论分析和实际应用（如信号处理、偏微分方程求解）都具有重要意义 [1]。不同的收敛类型对应着傅里叶级数逼近原函数的不同“质量”等级，某些应用（如需要保证近似误差在整个区间一致小）可能需要比逐点收敛更强的收敛模式，如一致收敛 [11]。<br>收敛类型的定义<br>为了精确比较不同的收敛模式，我们首先需要明确它们的定义。令  表示傅里叶级数的前 N 项部分和：<br>对于实数形式：<br><br>对于复数形式：<br><br>Definition (Pointwise Convergence).
逐点收敛 (Pointwise Convergence)
定义: 傅里叶级数 S(x) 在集合 I 上逐点收敛于函数 f(x)，如果对于 I 中的每一个 x，都有  [11]。
<br>解释: 这种收敛性是在每个点 x 上独立考虑的。对于任意给定的点 x 和任意小的正数 ，我们总能找到一个足够大的 （这个  可能依赖于 x 和 ），使得当  时， 。收敛的速度在不同点上可能存在显著差异。<br>Definition (Uniform Convergence).
一致收敛 (Uniform Convergence)
定义: 傅里叶级数在集合 I 上一致收敛于函数 f(x)，如果  [11]。等价地，对于任意给定的 ，存在一个 （不依赖于 x），使得对于所有  和 I 中的所有 x，都有  [20]。
<br>解释: 这是一种更强的收敛形式，要求级数在整个区间 I 上以“相同的速度”逼近函数 f(x)。部分和  的图像最终会完全落在 f(x) 图像周围一个宽度为  的“带子”内。一致收敛关注的是在整个区间上的最大逼近误差。<br>Definition (Absolute Convergence).
绝对收敛 (Absolute Convergence)
定义: 傅里叶级数称为绝对收敛，如果其系数的绝对值构成的级数收敛：
对于实数形式： 。
对于复数形式：  [3]。
<br>解释: 绝对收敛是关于傅里叶系数本身大小的一个条件。它不直接描述  如何逼近 f(x)，但它蕴含了非常好的收敛性质。一个重要的特性是，绝对收敛的级数，其各项可以任意重排而不改变级数的和 [24]。这与逐点收敛和一致收敛形成了对比，后两者关注的是部分和函数序列  与目标函数 f(x) 之间的逼近关系。<br>这三种定义揭示了它们关注点的不同：逐点收敛关注每个独立点上的极限行为；一致收敛关注整个区间上逼近误差的最大值；绝对收敛则关注系数的衰减速度。正是这种关注点的差异导致了它们各自成立的条件以及所蕴含的性质有所不同。特别是，一致收敛要求存在一个对所有 x 都有效的 ，这比逐点收敛的要求（ 可以依赖于 x）严格得多 [22]，也解释了为何在某些情况下（如吉布斯现象）一致收敛会失效。<br>逐点收敛<br>逐点收敛是傅里叶级数收敛性中最基本的一种形式，它描述了级数在单个点上是否趋向于函数（或其某个特定值）。<br>收敛条件:判断傅里叶级数是否逐点收敛有多种充分条件，这些条件通常与函数的局部光滑性或有界变差性质有关。<br>
<br>狄利克雷条件 (Dirichlet Conditions): 这是最经典的判据之一。若周期为 2L 的函数 f(x) 在一个周期内满足：(1) 绝对可积 ()；(2) 只有有限个极大值和极小值；(3) 只有有限个第一类间断点（左右极限均存在且有限），则其傅里叶级数在每一点 x 都收敛 [1]。
<br>若尔当判别法 (Jordan's Test - Bounded Variation): 如果 f(x) 是一个周期为 2 且在  上具有有界变差 (bounded variation) 的函数，则其傅里叶级数在每一点都逐点收敛 [8]。有界变差函数意味着函数图像的总“上下波动”是有限的，这类函数允许有跳跃间断点，但不能有无限次的振荡。这个条件比经典的狄利克雷条件更广泛。
<br>狄尼判别法 (Dini's Test): 这是一个更精细的局部判据。如果 f 局部可积，并且对于某点  和某个值 S，积分  对于某个  收敛，则 f 的傅里叶级数在  点收敛于 S [6]。这个条件考察了函数在  点附近关于值 S 的对称部分的平均收敛速度。
<br>局部光滑性条件: 如果函数 f 在点  处满足 Hölder 条件（即 , ），或者在  点可微（即左右导数存在且相等），则其傅里叶级数在  点收敛于  [8]。即使在跳跃间断点 ，如果左右导数存在，级数也会收敛 [8]。
<br>L2 条件 (Carleson's Theorem): 对于平方可积函数 (), 其傅里叶级数几乎处处 (almost everywhere) 逐点收敛于 f(x) [6]。这意味着不收敛的点集测度为零。
<br>收敛值:当傅里叶级数在点 x 逐点收敛时，其收敛值取决于 f(x) 在该点的性质：<br>
<br>连续点: 如果 f(x) 在 x 点连续且满足上述任一收敛条件，则傅里叶级数收敛于 f(x) [1]。
<br>间断点: 如果 f(x) 在 x 点存在第一类间断点（跳跃间断点）且满足收敛条件，则傅里叶级数收敛于该点左右极限的算术平均值，即  [1]。
<br>局限性与现象:逐点收敛虽然基本，但有其局限性。<br>吉布斯现象 (Gibbs Phenomenon): 在函数 f(x) 的跳跃间断点附近，傅里叶级数的部分和  会表现出“过冲”和“下冲”的振荡行为。当  时，这些振荡的峰值并不会趋于零，而是趋向于一个超过函数实际跳跃高度约 9% 的值。虽然振荡区域会向间断点压缩，但峰值高度不变，这表明在包含间断点的任何邻域内，收敛都不是一致的 [1]。<br>可能发散: 存在这样的连续函数，其傅里叶级数在某（些）点发散（du Bois-Reymond 构造）[2]。甚至存在 L1 可积函数（比连续函数更弱的条件），其傅里叶级数处处发散（Kolmogorov 构造）[6]。<br>逐点收敛的条件，如狄尼判别法或可微性，都集中在考察函数在收敛点  邻域的行为 [6]。这体现了逐点收敛的“局部性”特征，即级数在一点的收敛性主要由函数在该点附近的性质决定，这与需要全局信息的傅里叶系数计算形成对比。黎曼的局部化原理 (localization principle) 进一步强调了这一点：如果两个函数在某点的一个小邻域内相等，那么它们的傅里叶级数在该点的收敛性态（收敛或发散，以及收敛值）必然相同 [29]。然而，du Bois-Reymond 和 Kolmogorov 的反例揭示了逐点收敛的深刻局限性 [2]。它们表明，仅仅是函数的基本性质，如连续性或 L1 可积性，并不足以保证傅里叶级数处处收敛。这促使数学家们寻找更强的函数条件（如有界变差、满足狄尼条件等）来确保逐点收敛，或者转向研究其他类型的收敛（如 L2 收敛、一致收敛、可和性）。卡尔松定理 (L2 函数傅里叶级数几乎处处收敛) 则表明，对于在许多应用中至关重要的 L2 函数类，逐点发散是“罕见”的 [6]。<br>一致收敛<br>一致收敛是比逐点收敛更强的收敛模式，它要求傅里叶级数在整个区间上以统一的速率逼近函数。<br>收敛条件:确保傅里叶级数一致收敛的条件通常要求函数具有更好的整体光滑性和连续性。<br>
<br>连续性 + 有界变差 (Jordan's Test): 如果函数 f(x) 在  上连续且具有有界变差，并且满足周期性条件 ，则其傅里叶级数在  上一致收敛于 f(x) [8]。
<br>Hölder 连续性: 如果周期函数 f(x) 在整个区间上满足 Hölder 条件（阶数 ），则其傅里叶级数一致收敛 [8]。这包括了 Lipschitz 连续函数（）的情况。
<br>狄尼-利普希茨判别法 (Dini-Lipschitz Test): 如果 f(x) 是连续的周期函数，且其连续模  满足  当  时，则其傅里叶级数一致收敛 [27]。这个条件比 Hölder 连续性稍弱，但仍保证了一致收敛。
<br>连续可微性 (C1): 如果函数 f(x) 连续，其导数 f′(x) 分段连续（piecewise continuous），且满足周期性边界条件 ，则 f(x) 的傅里叶级数一致收敛于 f(x) [12]。这是实际应用中一个常用且相对容易验证的条件。
<br>更高阶光滑性 (Ck,k，即 k 阶连续可微的周期函数），其傅里叶级数同样一致收敛。函数的阶数越高，通常收敛速度越快 [29]。
<br>系数绝对收敛: 如果 f(x) 连续，且其傅里叶系数绝对可和 ( 或 )，则傅里叶级数一致收敛 [6]。
<br>蕴含的性质:一致收敛具有重要的理论意义。<br>
<br>保持连续性: 如果构成级数的各项函数（cos(nx),sin(nx)）是连续的，且级数一致收敛，那么其和函数 f(x) 也必定是连续的 [16]。这意味着，如果一个函数的傅里叶级数一致收敛，那么该函数必须是连续的（并且满足周期性边界条件  才能在整个周期上连续）。
<br>逐项积分: 一致收敛的函数项级数可以逐项积分 [16]。这意味着对于一致收敛的傅里叶级数，我们可以通过对其各项积分来得到原函数积分的傅里叶级数（常数项需要调整）。
<br>逐项微分: 逐项微分需要更强的条件，即微分后得到的级数需要一致收敛 [16]。（详见第7节）。
<br>一致逼近: 一致收敛保证了对于任意给定的精度 ，总能找到一个有限项的部分和 ，使得在整个区间 I 上的每一点 x，逼近误差  都小于 。
<br>与逐点收敛的关系:一致收敛必然蕴含逐点收敛 [10]。然而，反之不成立。最典型的例子就是吉布斯现象：在跳跃间断点附近，傅里叶级数虽然逐点收敛（收敛到跳跃中点），但由于持续存在的过冲，收敛在包含该点的任何邻域内，收敛都不是一致的 [1]。此外，也存在连续函数，其傅里叶级数逐点收敛但非一致收敛 [8]。例如，某些精心构造的级数或在特定点收敛速度特别慢的级数 [12]。<br>一致收敛与函数的全局光滑性和连续性紧密相关。跳跃间断点是其主要障碍，因为吉布斯现象导致在间断点附近的最大误差无法任意小 [33]。因此，函数的连续性（特别是周期延拓后的连续性，即 ）是一致收敛的必要条件 [30]。确保一致收敛的充分条件，如若尔当判别法（连续+有界变差）或 Hölder 连续性，都对函数的整体行为施加了限制，排除了剧烈振荡或不连续性 [8]。值得注意的是， 光滑性（f 连续，f′ 分段连续，f(−L)=f(L)）足以保证 f 的傅里叶级数 S(f) 一致收敛 [12]。其证明通常依赖于将 f 的系数  与 f′ 的系数  通过分部积分联系起来（），然后利用 f′ 的系数满足的贝塞尔不等式或帕塞瓦尔等式（这仅要求 f′ 是 L2 或分段连续）以及柯西-施瓦茨不等式来证明  和  收敛得足够快（至少像 ），从而保证 S(f) 的绝对收敛，进而保证一致收敛 [20]。这个过程并不要求 f′ 的傅里叶级数 S(f′) 本身一致收敛。<br>绝对收敛<br>绝对收敛是傅里叶级数最强的收敛形式之一，它关注的是系数本身的大小。<br>收敛条件:绝对收敛要求傅里叶系数衰减得足够快。<br>
<br>伯恩斯坦定理 (Bernstein's Theorem): 如果周期函数 f(x) 属于 Hölder 类  (或 Lip()), 且阶数 , 则其傅里叶级数绝对收敛 [8]。这个  的条件是临界的；存在  的 Hölder 函数，其傅里叶级数不绝对收敛 [8]。
<br>Zygmund 定理: 如果 f(x) 具有有界变差 且 属于 Hölder 类  (对于某个 ), 则其傅里叶级数绝对收敛 [8]。这表明有界变差本身不足以保证绝对收敛，但结合任意阶的 Hölder 连续性即可。
<br>足够的光滑性 (Ck): 如果函数 f(x) 足够光滑，例如  且 , 则其傅里叶系数衰减速度至少为 , 这保证了  或  收敛，即级数绝对收敛 [29]。然而，如果仅仅是 （f 和 f′ 连续），系数衰减速度通常为 ，不足以保证绝对收敛，尽管此时级数是一致收敛的 [20]。函数 f 及其导数 f′ 均属于 L2 空间也不能保证绝对收敛 [8]。
<br>维纳代数 (Wiener's Algebra): 具有绝对收敛傅里叶级数的连续函数构成的集合被称为维纳代数，记作  [8]。伯恩斯坦定理和 Zygmund定理给出的就是函数属于维纳代数的充分条件。
<br>蕴含的性质:绝对收敛是非常好的性质。<br>
<br>蕴含一致收敛: 绝对收敛的傅里叶级数必然一致收敛 [6]。这是因为 ，根据 Weierstrass M 判别法，若 ，则  一致收敛。
<br>和函数连续: 由于绝对收敛蕴含一致收敛，而一致收敛保持连续性，因此绝对收敛的傅里叶级数的和函数必然是连续的。
<br>允许重排: 绝对收敛级数的一个重要特性是，级数的各项可以任意重新排列，其和保持不变 [24]。这在进行某些代数运算或变换时非常有用。
<br>与一致收敛的关系:绝对收敛严格强于一致收敛。存在一致收敛但非绝对收敛的傅里叶级数 [21]。一个经典的例子是级数  [57]。这个级数可以使用狄利克雷判别法证明其一致收敛，但其系数的绝对值构成的级数  发散（因为  发散）[53]。<br>绝对收敛本质上是对傅里叶系数衰减速度的要求。它要求系数的绝对值之和有限，这意味着系数衰减速度必须快于  [39]。像  或 Hölder  这样的光滑性条件恰好能保证这种快速衰减 [8]。而一致收敛则依赖于级数项之间的相互抵消（特别是在三角级数中，如狄利克雷判别法所示 [53]），以及部分和与函数之间的最大误差。 的例子清晰地展示了这种区别：尽管系数  的衰减相对较慢，不足以保证绝对收敛，但  项的振荡和  的单调递减性相结合，通过狄利克雷判别法可以保证级数一致收敛 [57]。这说明，即使系数大小衰减不够快，精巧的项间抵消也可能导致一致收敛。<br>收敛类型比较分析<br>傅里叶级数的三种主要收敛类型——逐点收敛、一致收敛和绝对收敛——构成了理解级数逼近性质的层级结构。它们之间存在明确的蕴含关系，对函数性质的要求也逐级递增。<br>层级关系与蕴含:这三种收敛类型构成了一个严格的强弱层级：绝对收敛  一致收敛  逐点收敛 [6]。<br>
<br>绝对收敛蕴含一致收敛是因为，如果 ，根据 Weierstrass M-判别法，由于 ，级数  必然一致收敛 [6]。
<br>一致收敛蕴含逐点收敛是根据它们各自的定义：如果级数在整个区间上一致地逼近函数，那么在区间内的每一点上自然也逼近函数 [11]。
<br>反向不成立:

<br>逐点收敛  一致收敛：吉布斯现象是典型的反例，方波的傅里叶级数逐点收敛（在间断点收敛到均值），但在包含间断点的区间上不一致收敛 [1]。
<br>一致收敛  绝对收敛：级数  是一致收敛的，但其系数绝对值之和发散 [57]。


<br>函数性质要求:实现不同类型的收敛对函数的光滑性/正则性有不同的要求：<br>
<br>逐点收敛: 要求相对较弱，可以是局部条件（如在某点可微、满足 Dini 条件）或全局条件（如有界变差、属于 L2 空间（几乎处处收敛））。允许函数存在某些类型的不连续点（如跳跃间断点）[1]。
<br>一致收敛: 要求更强的全局性质。函数通常需要是连续的（且满足周期性边界条件 ），并且具有一定的整体光滑度，如有界变差（Jordan 判别法）、满足 Hölder 条件或 C1 光滑 [8]。
<br>绝对收敛: 要求最高的全局光滑性。通常需要函数属于 C2 或更高阶的光滑类，或者满足 Hölder 条件且阶数 （Bernstein 定理）[8]。
<br>收敛速度与系数衰减:函数的光滑程度直接影响其傅里叶系数的衰减速度，进而决定了收敛的速度和类型 [38]。<br>光滑性  系数衰减:<br>
<br>f 有跳跃间断点 (分段连续):  [38]。
<br>f 连续, f′ 分段连续 (C1 分段光滑):  [38]。
<br> (k 阶连续可微):  或  (如果  绝对连续或  分段连续) [28]。
<br>f 满足 Hölder 条件 :  [8]。
<br> (m阶导数 Hölder  连续) + 有限振荡:  [62]。
<br>衰减  收敛类型/速度:<br>
<br>O(1/n) 衰减：通常只保证 L2 收敛和某些条件下的逐点收敛（可能伴随 Gibbs 现象）。收敛速度相对较慢。L2 误差  [39]。
<br> 且 ：

<br>p=2 (C1 分段光滑): 保证一致收敛和绝对收敛。L2 误差  [39]。
<br>p&gt;1.5 (对应 Hölder ): 保证绝对收敛（从而一致收敛）[8]。
<br>p 越大（函数越光滑），收敛速度越快。一致收敛误差  通常与系数衰减速度相关，例如对于  函数，误差可能为  [11] 或更快。


<br>函数性质的保持:<br>
<br>连续性: 一致收敛可以保持连续性，即如果级数各项连续且一致收敛，则和函数也连续 [16]。逐点收敛则不保证保持连续性 [11]。绝对收敛因蕴含一致收敛，其和函数也是连续的。
<br>可微性: 傅里叶级数的逐项微分需要更强的条件，通常要求微分后得到的级数一致收敛（见第7节）[16]。仅仅是原级数的一致收敛或绝对收敛通常不足以保证逐项微分的有效性。
<br>表1：傅里叶级数收敛类型比较<br><br>核心关系在于函数的光滑性、系数衰减速度和收敛性之间的紧密联系。更光滑的函数通常对应更快的傅里叶系数衰减速度，而更快的系数衰减则能保证更强的收敛模式（从逐点到一致再到绝对）和更快的收敛速度 [39]。例如，从分段连续 () 到 C1 分段光滑 () 再到 C2 ( 或更快)，系数衰减速度加快，收敛性也从可能仅 L2 收敛或伴有 Gibbs 现象的逐点收敛，提升到一致收敛，再到绝对收敛。伯恩斯坦定理关于 Hölder  的阈值 [8] 明确指出了保证绝对收敛所需的最低光滑度界限。然而，各种收敛类型所需的条件差异显著，反映了它们衡量逼近程度的不同侧重。逐点收敛依赖局部性质 [8]，一致收敛需要全局误差控制 [27]，而绝对收敛完全取决于系数的大小 [23]。这解释了为何函数可能满足逐点收敛的局部条件却因全局问题（如间断点）而无法一致收敛 [33]，或者通过项间抵消实现一致收敛却因系数衰减不够快而无法绝对收敛 [57]。<br>逐项微分<br>傅里叶级数的一个重要应用是在求解微分方程等问题中，这自然引出了一个问题：能否对傅里叶级数进行逐项微分，并且得到的级数是否收敛到原函数的导数？答案是肯定的，但需要满足比级数本身收敛更强的条件。<br>Theorem (Statement).
定理陈述:若函数 f(x) 在  上满足以下条件 [31]：

<br>f(x) 处处连续。
<br>f′(x) 在  上分段光滑 (piecewise smooth)。这意味着 f′(x) 本身及其导数 f′′(x) 都是分段连续的。
<br>f(x) 满足周期性边界条件 。

则 f(x) 的傅里叶级数

可以逐项微分，得到 f′(x) 的傅里叶级数：

并且这个微分得到的级数在 f′(x) 的所有连续点处收敛于 f′(x)。
<br>一致收敛的角色:逐项微分的合理性依赖于级数收敛的性质。根据函数项级数的基本理论，若要保证和函数的导数等于级数逐项微分后的和，通常要求微分后得到的级数是一致收敛的 [16]。<br>原级数 S(f) 的一致收敛: 定理中的条件（f 连续，f′ 分段光滑，f(−L)=f(L)）实际上保证了原级数 S(f) 是一致收敛的 [31]。这是因为 f′ 分段光滑意味着 f′ 有界变差，从而 f 满足 Hölder 条件（），结合连续性和周期性边界条件，足以保证 S(f) 一致收敛。<br>微分级数 S(f′) 的收敛: 定理的关键在于确保微分后的级数 S(f′) 收敛。<br>条件 f′(x) 分段光滑保证了 f′(x) 本身满足傅里叶级数逐点收敛的条件（如狄利克雷条件或若尔当判别法）[17]。<br>因此，微分得到的级数（即 f′ 的傅里叶级数）至少在 f′ 的连续点处逐点收敛于 f′(x)。<br>如果 f′ 本身是连续的（即 ），那么 S(f′) 也会一致收敛。<br>系数关系:通过分部积分可以建立 f′(x) 的傅里叶系数 () 与 f(x) 的傅里叶系数 () 之间的关系 [20]：<br><br>由于  且 ，边界项为零。<br>因此：<br><br>同理可得：<br><br>(注意：)<br>这与逐项微分得到的级数形式一致。<br>复数形式下，关系更简洁：。<br>光滑性的影响:函数 f 的光滑性越好，其导数 f′ 的光滑性也越好。<br>如果  且 ，那么  且 。<br>这意味着 f′ 至少是 C1 的，根据一致收敛的条件，f′ 的傅里叶级数 S(f′) 必然一致收敛。<br>因此，对于足够光滑的函数（至少 C2），逐项微分是完全合理的，并且得到的级数一致收敛于导函数 [39]。<br>逐项微分并非无条件成立。<br>关键在于微分运算会给系数带来一个因子 n () [20]。<br>如果原级数的系数  衰减速度不够快（例如仅为 O(1/n)），那么乘以 n 后的系数  可能不再趋于零，导致微分后的级数发散 [35]。<br>这就是为什么定理要求 f 连续且 f′ 分段光滑：f 连续保证了  至少以  的速度衰减（因为 f′ 分段光滑意味着 f′ 是 L2 的），这样乘以 n 后的系数  仍然以 O(1/n) 的速度衰减，足以保证 f′ 的傅里叶级数 S(f′) 至少逐点收敛（根据有界变差函数的收敛性）[31]。<br>结论<br>核心关系与层级: 这三种收敛类型构成了一个清晰的强弱层级：绝对收敛是最强的，它蕴含一致收敛；一致收敛强于逐点收敛。<br>然而，这些蕴含关系的反向通常不成立，表明它们各自描述了级数逼近函数的不同侧面。<br>光滑性是关键: 函数的光滑程度是决定其傅里叶级数收敛行为的核心因素。<br>更光滑的函数（具有更多阶连续导数，或满足更高阶的 Hölder 条件）通常对应着更快的傅里叶系数衰减速度。<br>这种更快的衰减是实现更强收敛模式（从逐点到一致，再到绝对）和更快收敛速度的基础。<br>例如，从分段连续到 C1 再到 C2，系数衰减率从 O(1/n) 提升到 O(1/n2) 或更快，收敛性也相应增强。<br>条件与局限:<br>
<br>逐点收敛 依赖于函数的局部性质（如 Dini 条件、可微性）或全局的有界变差性质。它允许函数存在跳跃间断点（级数收敛到均值），但面临 Gibbs 现象和可能发散的问题（即使对连续函数）。
<br>一致收敛 要求函数具有全局连续性和一定的光滑度（如连续且有界变差、Hölder 连续、C1）。它保证了逼近误差在整个区间上一致趋于零，并能保持函数的连续性。
<br>绝对收敛 对函数光滑性要求最高（如 C2、Hölder ），它保证了系数绝对值级数的收敛，从而得到最强的收敛保证，包括一致收敛和允许项重排。
<br>应用意义: 理解这些收敛类型的差异对于理论研究和实际应用至关重要 [1]。<br>
<br>在信号处理中，L2 收敛（均方收敛）与信号能量相关。
<br>在数值计算和近似理论中，一致收敛提供了全局误差界限，保证了近似的可靠性。
<br>在偏微分方程的级数解中，逐项积分和微分的合理性通常依赖于（微分后级数的）一致收敛。
<br>绝对收敛则为级数的代数运算提供了便利。
<br>尽管存在收敛性方面的复杂性和挑战（如发散的反例），傅里叶级数仍然是一个极其强大的工具。<br>对于工程和物理中遇到的大多数“行为良好”的函数（通常足够光滑），其傅里叶级数都具有良好的收敛性质 [1]。<br>即使对于连续但不够光滑的函数，可和性理论（如 Cesàro 平均）也提供了替代的收敛方式，保证了结果的稳健性 [2]。<br>深入理解傅里叶级数的不同收敛模式及其条件，是有效运用这一工具解决科学和工程问题的基础。]]></description><link>数学分析进阶\傅里叶分析初步.html</link><guid isPermaLink="false">数学分析进阶/傅里叶分析初步.md</guid><pubDate>Fri, 09 May 2025 02:22:06 GMT</pubDate></item><item><title><![CDATA[实数的完备性]]></title><description><![CDATA[ 
 <br><br>44．证明下列命题是等价的：<br>
（I）Dedekind 分割原理；<br>
（II）确界存在原理；<br>
（III）单调有界原理；<br>
（IV）区间套定理；<br>
（V）有限覆盖定理；<br>
（VI）聚点原理；<br>
（VII）有界数列必有收敛子列；<br>
（VIII）Cauchy 收敛准则．<br>证明：<br>：只要证明，若数集  有上界，则  必有唯一的上确界。<br>
 若  有最大值 ，则  就是  的上确界。<br>
 设  为无限集且无最大值。做实数集  的分割 ，其中  为  的一切上界所组成之集， 为  的补集。于是<br>
（i），<br>
（ii），<br>
（iii）任取 ，若存在  使 ，则  成为  的一个上界，从而 ，这与（ii）矛盾。故对任意 ，均有 。<br>因此， 是一个 Dedekind 分割。由分割原理，存在唯一 ，使对任意  有<br><br>因  不可能是  的最大值（若  是  的最大值，则 ，从而 ，矛盾！）故对一切 ，均有 ，即  不能成立。这样，只有  成立，即  是  中的最小者，也就是  的上界中的最小者，故  有唯一的上确界 。<br>：不妨假设  单调增加且有上界。据确界存在原理， 必有上确界 ，即<br><br>兹证  就是  当  时的极限。<br>
事实上，由上确界定义知对任意 ，存在 ，使<br><br>再据  单调增加，可知对任何  均有<br><br>因此，当  时有 ，即<br><br>：设闭区间列  满足条件：<br>
（i），<br>
（ii）。<br>
由（i）知数列  单调增加且有上界，故  收敛。令<br><br>又因对每一 ,  是  的上界，且  是  的最小上界，故<br><br>由（1），（2）可知 ，即<br><br>若还存在实数  使<br><br>则 ，故 。<br>：设  是闭区间  的一个开覆盖。假如  不能被  中任何有限个开集覆盖，将  等分为两个区间，则其中至少有一个区间不能被  中任何有限个开集覆盖，记此区间为 。再等分 ，同样至少有一个不能被  中任何有限个开集覆盖，记此区间为 。如此继续下去，得到一列闭区间<br><br>适合<br>
（i）任何一个  都不能被  中任何有限个开集覆盖。<br>
（ii）。<br>
（iii）。<br>
据区间套定理，存在唯一实数 ，且<br><br>因  覆盖了 ，故  中至少有一个开集从而至少有一个开区间 ，使得<br><br>由极限性质知存在 ，当  时有<br><br>即 。因此， 覆盖了 。这与（i）发生矛盾。<br>：设  为有界的无限集。令<br><br>则 。假如  没有聚点，那么对任意 ，存在  的邻域 ，使  中至多含有  的有限个点，即  是有限集。显然，当  走遍  时，这些邻域就覆盖了 ，即<br><br>据有限覆盖定理，存在有限个邻域 ，它们足以覆盖 ，即<br><br>从而 。由此得到  为有限集，此为矛盾。因此， 必有聚点。<br>：设  是有界无穷数列。若  是由有限个实数重复出现而构成的数列，则至少有一个数  要重复出现无穷多次。设  重复出现的项为 ，则<br><br>即  是  的一个收敛子列。<br>
现设  确由无穷多个不同的实数组成，则此数列为一有界无穷集。据聚点原理， 至少有一聚点 。于是，对任何 ， 中必含有  的无穷多项，从而在  中可以选出  的一个项  使 。因  是任意正整数，故得  的一个子列 ，使得 ，因而<br><br>：必要性是显然的。<br>
兹证充分性。据条件，对 ，存在 ，当  时有<br><br>于是，<br><br>令<br><br>则 ，故  有界。因此存在收敛子列 ，设<br><br>于是由不等式<br><br>可知，。<br>：设  是全体实数  的任意一个分割。因 ，故可任取 ，则 。将  等分为二，若分点  就取右半区间并记为 ；若 ，则取左半区间并记为 。总之，。如此继续下去，得到闭区间列 ，满足<br>（i），<br>
（ii），<br>
（iii）。<br>
由（i），（ii）可知数列<br><br>是 Cauchy 数列，因而收敛。设其极限为 。若 ，可证  必为  的最大值。事实上，假如存在  而有 ，取正数 ，则<br><br>由（iii），每个 ，这与  收敛于  发生矛盾。因此， 为  的最大值。此时  显然无最小值。类似地可证，若  在  中，则  必是  的最小值，此时  无最大值。<br>注：本题中八个等价的命题从不同的角度刻画了实数的连续性（又称完备性）。]]></description><link>数学分析进阶\实数的完备性.html</link><guid isPermaLink="false">数学分析进阶/实数的完备性.md</guid><pubDate>Fri, 02 May 2025 16:55:30 GMT</pubDate></item><item><title><![CDATA[chap1]]></title><description><![CDATA[ 
 <br><br><br>第一节介绍正整数（自然数）集合  具有的两个重要的性质，这两个性质还是等价的。它们分别是良序原理（任意非空正整数集有最小数）和数学归纳法原理（若正整数集  含有 1 且若  则  那么 .）<br>Proposition.
1 是最小的正整数
<br>Proposition.
数学归纳法原理和良序原理是等价的
<br>这个证明比较繁琐<br>
接下来是一个应用<br>Proposition.
大于 1 的整数要么是素数，要么在不计次序的情况下可以唯一分解为素数的乘积
<br>若合数  不能写成素数乘积，不妨设  是最小的这样的合数（由良序原理），由于  是合数，就可以写作  其中 . 于是  要么是素数，要么是素数的乘积（因为  是最小的不能写成素数乘积的合数），故  也是素数乘积，故矛盾！<br>其次证明唯一性：若存在合数 ，它的因子分解不是唯一的，，不妨设  是最小的这样的数（由良序原理）显然所有的  都和  互异，否则可以消去，这与  的最小性矛盾。不妨设 ，不妨设 ，考虑 ，显然 ，将  写成素数乘积 ，于是 ，同时 ，这是不同的分解，因为前者中没有 ，于是  取代  成为最小的因子分解不唯一的合数，矛盾！<br>Proposition.
没有最大的素数
<br>若  是前面所有的素数，那么  又是一个素数。<br>Proposition.
若  是素数，那么  是无理数
<br>若  则 ，即 ，那么左边有奇数个素因子，右边有偶数个，矛盾！<br>Proposition.
对于非平方自然数 ，，，那么  没有最小数， 没有最大数
<br><br>Definition (分割).
基本定义 有理数的一个集合  叫做一个分割，倘若<br>
（i） 至少含有一个有理数，但不含有所有有理数；<br>
（ii）若  及  ，其中  为有理数，则  ；<br>
（iii） 不含最大的有理数．
<br>Proposition.
若  则  
<br> 中的元素称为  的下数，不在  的有理数称为  的上数，上数集记作 . <br>Proposition.
对于 ，，那么  是一个分割. 且  是  的最小上数.
<br>上述分割叫做一个有理分割，若  是由此从  做出的有理分割，则记作 .<br>Definition (分割之间的序关系).
若  且 ，那么 . 类似定义 . 简单验证可知这是序关系.
<br>Proposition (分割的加法).
，则  是分割，记作 .
<br>Proposition (有理数的阿基米德性质).
若 ，则存在 ，使得 .
<br>定义  是一个分割.  的真上数指的是  中的非最小数.<br>Proposition (分割的减法).
若  是分割，则存在唯一  使得 . 记作 .
<br>置 ，则 ，若  使得 ，那么 .<br>Proposition (分割的乘法).
， 是一个分割，记作 .
<br>Definition (分割的绝对值).
若  则 ；若  则 .
<br>若  或  那么 ，否则 .<br>Proposition (分割的除法).
对于 ， 是一个分割，且 . 记作  或 .
<br>若 ，那么 <br>Proposition.
对于任意分割 ，存在唯一分割  满足 .
]]></description><link>数学分析进阶\chap1.html</link><guid isPermaLink="false">数学分析进阶/chap1.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate></item><item><title><![CDATA[hw1]]></title><description><![CDATA[ 
 <br><img alt="微信图片_20250301233728.png" src="lib\media\微信图片_20250301233728.png"><br>Exercise.

<br>证明： 是代数。
<br> 证明  是代数。
<br> 证明  是代数。

<br>Definition (代数).
代数是一个非空集合  和一个二元运算 ，满足：<br>
封闭性：，<br>
我们通常将代数记为 。
<br>
<br>简单验证：

<br>
<br>
<br>
<br>


<br>简单验证：

<br>
<br>


<br>简单验证

<br>
<br>


<br>Exercise.
证明  关于矩阵乘法是非 Abel 代数
<br>首先，我们需要明确非 Abel 代数的定义：<br>Definition (非 Abel 代数).
一个代数  称为非 Abel 代数（或非交换代数），如果存在 ，使得 。
<br>现在证明  关于矩阵乘法是非 Abel 代数：<br>
首先验证  关于矩阵乘法是一个代数：<br>
对于任意 <br><br>我们有矩阵乘法下<br><br>其中每个元素都 ，于是 ，故  关于矩阵乘法是一个代数。<br>
接下来验证  关于矩阵乘法是非 Abel 代数：<br>
取<br><br>于是<br><br>于是  关于矩阵乘法是非 Abel 代数。<br>Exercise.
 证明  是 Abel 环
<br>即证  为 Abel 群， 为 Abel 代数，且有乘法单位元，满足乘法结合律<br>Definition (Abel 环).
Abel 环是指满足以下条件的代数结构 ：

<br> 是 Abel 群
<br> 是半群（满足结合律）且有单位元
<br>乘法对加法满足分配律
<br>乘法满足交换律（即 ，）

<br>首先验证  是 Abel 群：<br>
<br>封闭性：对于任意 ，设 ，，则 ，其中若  则 ，若  则 。由于整数对加法封闭，所以 ，因此 。
<br>结合律：对于任意 ，有 ，这是因为多项式系数的加法满足结合律。
<br>单位元：零多项式  是加法单位元，对任意 ，有 。
<br>逆元：对于任意 ，其加法逆元为 ，满足 。
<br>交换律：对于任意 ，有 ，这是因为多项式系数的加法满足交换律。
<br>接下来验证  是 Abel 代数：<br>
<br>封闭性：对于任意 ，，它们的乘积为 ，其中 。由于整数对乘法和加法都封闭，所以 ，因此 。
<br>结合律：对于任意 ，有 ，这是多项式乘法的基本性质。
<br>单位元：多项式  是乘法单位元，对任意 ，有 。
<br>交换律：对于任意 ，有 ，这是因为多项式乘法满足交换律。
<br>最后验证乘法对加法的分配律：<br>
对于任意 ，有：<br>
<br>
<br>
综上所述， 是 Abel 环。<br>Exercise.
 是素数，，其中  表示模  余  的剩余类，证明： 是 Abel 域
<br>即证  为 Abel 环，且任一非零元有乘法逆元<br>
<img alt="8f3725a58915a7b2bb9702d910386c1.jpg" src="lib\media\8f3725a58915a7b2bb9702d910386c1.jpg"><br>Exercise.

<br> 定义 。证明： 是偏序集，而非全序集
<br>设  为非空集合， 为  的子集构成的集合， 为集合的包含关系，证明  为偏序集，而非全序集

<br><img alt="923f077fa8274b535d8cc207b5812bd.jpg" src="lib\media\923f077fa8274b535d8cc207b5812bd.jpg"><br>Exercise.
将整数集良序化
<br><img alt="ad7dab77d435722306c171ed8990669.jpg" src="lib\media\ad7dab77d435722306c171ed8990669.jpg">]]></description><link>数学分析进阶\hw1.html</link><guid isPermaLink="false">数学分析进阶/hw1.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\微信图片_20250301233728.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\微信图片_20250301233728.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw3]]></title><description><![CDATA[ 
 <br><img alt="904841bf36031dff80d98b40c9fafc4.jpg" src="lib\media\904841bf36031dff80d98b40c9fafc4.jpg"><br>Exercise.
证明：Cauchy 列改变前任意有限项仍为 Cauchy 列．
<br><img alt="hw3-20250318.png" src="lib\media\hw3-20250318.png"><br>假设改变的有限项中指标最大的为 ，那么对于任意的 ，存在正整数  是的当  时，<br><br>故得证 !<br>Exercise.
用几何方法证明命题 1．1．10．（提示：有理数的稠密性）
<br>Proposition (命题 1.1.10).
 是  中的 Cauchy 列的小数表示  ．
<br>显然！<br>Exercise.
证明：若  是有理 Cauchy 列，则  也是有理 Cauchy 列．
<br><img alt="1-hw3-20250318.png" src="lib\media\1-hw3-20250318.png"><br>显然 . 由于  是有理 Cauchy 列，故对于任意 ，存在 ，使得对于任意 , 有<br><br>于是<br><br>因此  也是有理 Cauchy 列.<br>Exercise.
证明：<br>
（1）戴德金分割  有理分割；<br>
（2）有理分割  有理 Cauchy 列的等价类．
<br>Definition (戴德金分割).
<img alt="5-hw3-20250318.png" src="lib\media\5-hw3-20250318.png">
<br>Definition (有理分割).
<img alt="3-hw3-20250318.png" src="lib\media\3-hw3-20250318.png">
<br>戴德金分割  有理分割： 根据戴德金原理，对于实数域的戴德金分割 ，要么下类  中存在最大数，要么上类  中存在最小数。无论如何，记这个数字为 , 那么<br><br>或者<br><br>这是个有理分割。显然有理分割  戴德金分割。故戴德金分割  有理分割<br><img alt="4-hw3-20250318.png" src="lib\media\4-hw3-20250318.png"><br>若  是有理分割，分点为 ，它对应等价类 。若 <br>Exercise.
设数列  有界．证明：数列  极限存在  只有唯一的聚点．
<br>若  是数列的极限，这等价于对于任意的 ，存在 ，使得<br><br>显然  是  的聚点，假设  也是聚点，那么存在 ，使得<br><br>于是对于 ，有<br><br>由  任意性可知<br><br>只有唯一聚点。<br>另一个方向是显然的！<br>Exercise.
证明确界存在定理．
<br>根据戴德金定理：只要证明，若数集  有上界，则  必有唯一的上确界。<br>
1．若  有最大值  ，则  就是  的上确界。<br>
2．设  为无限集且无最大值。做实数集  的分割  ，其中  为  的一切上界所组成之集， 为  的补集。于是<br>
（a） ．<br>
（b） ，<br>
（c）任取  ，若存在  使  ，则  成为  的一个上界，从而  ，这与（b）矛盾。故对任意  ，均有  。<br>因此， 是一个 Dedekind 分割。由分割原理，存在唯一  ，使对任意  有<br><br>因  不可能是  的最大值（若  是  的最大值，则  ，从而  ．矛盾！）故对一切  ，均有  ，即  不能成立。这样，只有  成立，即  是  中的最小者，也就是  的上界中的最小者，故  有唯一的上确界  。<br>Exercise.
设  是正整数，给定  个实数  ，构造数列  使得  是其聚点．
<br>我们可以构造数列 ，. 接下来令<br><br>其中 . 于是  是  的聚点.]]></description><link>数学分析进阶\hw3.html</link><guid isPermaLink="false">数学分析进阶/hw3.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\904841bf36031dff80d98b40c9fafc4.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\904841bf36031dff80d98b40c9fafc4.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw4]]></title><description><![CDATA[ 
 <br><img alt="165edb69eb7e6f893a8b1736694ef9b.jpg" src="lib\media\165edb69eb7e6f893a8b1736694ef9b.jpg"><br>Exercise.
<img alt="hw4-2025032411.png" src="lib\media\hw4-2025032411.png">
<br>Proof.<br><br>因此<br><br>□<br>Exercise.
<img alt="1-hw4-2025032411.png" src="lib\media\1-hw4-2025032411.png">
<br>(1)<br>
Proof.<br>
<img alt="4-hw4-2025032411.png" src="lib\media\4-hw4-2025032411.png"><br>
<img alt="5-hw4-2025032411.png" src="lib\media\5-hw4-2025032411.png"><br>
将  写作 ，于是  在  内稠密，由于  连续，所以  在  内稠密.<br>□<br>
(2)<br>
Proof.<br>
为了验证等分布，只需验证对于任意 ，，我们有<br><br>这等价于证明：<br><br>我们先证明如下引理：<br>Lemma.
若  是周期 1 的连续函数， 是无理数，那么<br>

<br>证明思路是是采用三角级数逼近.<br>Proof.<br>
首先我们验证上式对于  都成立，若 ，那么显然成立. 若 ，那么<br><br>显然，如果  都满足 <a data-href="#^619155" href="about:blank#^619155" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^619155</a><a data-href="#^619155" href="about:blank#^619155" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Lemma 3</a>，那么  也满足，其中 . 故 <a data-href="#^619155" href="about:blank#^619155" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^619155</a><a data-href="#^619155" href="about:blank#^619155" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Lemma 3</a> 对于三角多项式都成立.<br>接着我们对于任意的连续  ，存在三角多项式  ，使得<br><br>同时<br><br>因此<br><br>□<br>
<img alt="8-hw4-2025032411.png" src="lib\media\8-hw4-2025032411.png"><br>
<img alt="10-hw4-2025032411.png" src="lib\media\10-hw4-2025032411.png"><br>
□<br>
(3)<br>
Proof.<br>
由前两问，这是显然的<br>
□<br>Exercise.
<img alt="2-hw4-2025032411.png" src="lib\media\2-hw4-2025032411.png">
<br><br>其中<br><br> 与  无关，可以任意小.<br>故<br><br>收敛<br>Exercise.
<img alt="3-hw4-2025032411.png" src="lib\media\3-hw4-2025032411.png">
<br> 时发散， 时收敛.]]></description><link>数学分析进阶\hw4.html</link><guid isPermaLink="false">数学分析进阶/hw4.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\165edb69eb7e6f893a8b1736694ef9b.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\165edb69eb7e6f893a8b1736694ef9b.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw5]]></title><description><![CDATA[ 
 <br><img alt="274eb25c47848157ef9ff45de6f4d76.png" src="lib\media\274eb25c47848157ef9ff45de6f4d76.png"><br><img alt="hw5-2025033023.png" src="lib\media\hw5-2025033023.png"><br>
Proof.<br>
For any , . Thus . For any , then . Then , thus . Hence .<br>
□<br>
<img alt="1-hw5-2025033023.png" src="lib\media\1-hw5-2025033023.png"><br>Theorem (theorem 2.14 in baby rudin).
Let  be the set of all sequences whose elements are the digits  and . This set  is uncountable.<br>
The elements of  are sequences like 
<br>Let  be a countable subset of , and let  consist of the sequences . We construct a sequence  as follows. If the  th digit in  is , we let the  th digit of  be , and vice versa. Then the sequence  differs from every member of  in at least one place; hence . But clearly , so that  is a proper subset of .<br>We have shown that every countable subset of  is a proper subset of . It follows that  is uncountable (for otherwise  would be a proper subset of , which is absurd).<br>Therefore, .<br><img alt="2-hw5-2025033023.png" src="lib\media\2-hw5-2025033023.png"><br><img alt="7-hw5-2025033023.png" src="lib\media\7-hw5-2025033023.png"><br>Proof.<br>
采用蔓延的思想，对于任意 ，考虑 ，记<br><br>显然 . 这里  可能为 ， 可能为 . 显然区间 . 并且  为开集，这是因为对于任意 ，存在 ，若 ，这与  定义矛盾！故 . <br>存在如下映射<br><br>显然  是单射，因此 .<br>
□<br><img alt="3-hw5-2025033023.png" src="lib\media\3-hw5-2025033023.png"><br>不存在<br><img alt="4-hw5-2025033023.png" src="lib\media\4-hw5-2025033023.png"><br><img alt="hw5-2025033100.png" src="lib\media\hw5-2025033100.png"><br>(1) 若 , 则 ， 不是  的内点，也就是说  的“附近”不包含于  中. 对于任意充分小的 ，. 由疏集的定义，对于  中的任意非空开集 ，若 ，那么存在  使得 ，存在 ，选取  的子集 ，这个集合与  不相交，因此  是疏集.<br>若  是疏集，但 . 那么存在 ，使得存在 . 选取区间 ，那么它有非空开子集  与  不相交，这不可能发生在  的拓扑上！<br>因此， 是疏集等价于 .<br>(2) 这是显然的.<br><img alt="5-hw5-2025033023.png" src="lib\media\5-hw5-2025033023.png"><br><img alt="1-hw5-2025033100.png" src="lib\media\1-hw5-2025033100.png"><br>
<img alt="2-hw5-2025033100.png" src="lib\media\2-hw5-2025033100.png"><br><img alt="6-hw5-2025033023.png" src="lib\media\6-hw5-2025033023.png"><br> is a Julia set.<br>JuliaSetPlot[2  z^2 + 3  z + 1, z, ColorFunction -&gt; None]
<br><img alt="1-hw5-2025040218.png" src="lib\media\1-hw5-2025040218.png">]]></description><link>数学分析进阶\hw5.html</link><guid isPermaLink="false">数学分析进阶/hw5.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\274eb25c47848157ef9ff45de6f4d76.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\274eb25c47848157ef9ff45de6f4d76.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw6]]></title><description><![CDATA[ 
 <br><img alt="d64b9372e28853ce2a9c54e98cf4a55.jpg" src="lib\media\d64b9372e28853ce2a9c54e98cf4a55.jpg"><br>Exercise.
<img alt="hw6-2025040420.png" src="lib\media\hw6-2025040420.png">
<br><img alt="2-hw6-2025040420.png" src="lib\media\2-hw6-2025040420.png"><br>(1) 显然  且<br><br>(2) 显然 <br>(3) 不妨设 ，若  那么显然有<br><br>若 ，则<br><br>因此  是一个距离.<br>Exercise.
<img alt="3-hw6-2025040420.png" src="lib\media\3-hw6-2025040420.png">
<br><img alt="2-hw6-2025040420.png" src="lib\media\2-hw6-2025040420.png"><br>
(1) 显然 ，若 ，那么 . 因此 .<br>(2) 显然 .<br>(3) <br><br>因此  是  上的一个距离.<br>Exercise.
<img alt="4-hw6-2025040420.png" src="lib\media\4-hw6-2025040420.png">
<br> 是开集，则  是闭集，但是<br><br>故  是开集，故  既开又闭，但不是全集也不是空集. 这样的定义不合适]]></description><link>数学分析进阶\hw6.html</link><guid isPermaLink="false">数学分析进阶/hw6.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\d64b9372e28853ce2a9c54e98cf4a55.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\d64b9372e28853ce2a9c54e98cf4a55.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw7]]></title><description><![CDATA[ 
 <br><img alt="960a7c361de1ee39a977c4ad836fb639.jpg" src="lib\media\960a7c361de1ee39a977c4ad836fb639.jpg"><br>Exercise.
<img alt="1-hw7-2025041516.png" src="lib\media\1-hw7-2025041516.png">
<br>Definition (inner product space).
<img alt="2-hw7-2025041516.png" src="lib\media\2-hw7-2025041516.png">
<br>Proof.<br>
(1) Let<br><br>Then for any ,  a scalar, we have<br><br><br><br><br>Let  then<br><br>(2)<br>
Let<br><br>Then for any , scalar , we have<br><br><br><br><br><br>□<br>Exercise.
<img alt="hw7-2025041517.png" src="lib\media\hw7-2025041517.png">
<br><img alt="hw7-2025041616.png" src="lib\media\hw7-2025041616.png"><br>
 means for any , there exists  s.t. for any  satisfying , we have<br><br> not existing means that there exists , for any , there exists  satisfying  and <br><br>Exercise.
<img alt="1-hw7-2025041517.png" src="lib\media\1-hw7-2025041517.png">
<br>Proof.<br>
(1) Pick any sequence , . Denote . For any , there exists , s.t.<br><br>Then <br><br>For any , we have<br><br>Thus  converges. By Heine's theorem, <br><br>exists.<br>(2) When , we have<br><br>Let , we have<br><br><br>Let  then , as . But <br><br>Thus  does not exists, while  exists,  exists. Hence<br><br>does not exists.<br>
□<br>Exercise.
<img alt="3-hw7-2025041517.png" src="lib\media\3-hw7-2025041517.png">
<br><img alt="1-hw7-2025041616.png" src="lib\media\1-hw7-2025041616.png"><br>Proof.<br>
(1) for any , check that<br><br>因为  关于充分大的  单调有界趋于 ，且级数  收敛. 由 Abel test，级数  收敛.<br>(2) 任意给定 ，则<br><br>令 ，那么下面两个级数收敛<br><br><br>考虑数列 ，于是<br><br>故  不存在.<br>□<br>Exercise.
<img alt="4-hw7-2025041517.png" src="lib\media\4-hw7-2025041517.png">
<br><img alt="3-hw7-2025041616.png" src="lib\media\3-hw7-2025041616.png"><br>Proof.<br>
For any given , , the limit<br><br>exists. And<br><br>Then<br><br>i.e. the limit  exists, i.e.  converges on  .<br>□<br>Exercise.
<img alt="5-hw7-2025041517.png" src="lib\media\5-hw7-2025041517.png">
<br>Proof.<br>
(1)<br>
For any , for given ,  exists. And<br><br>By dominate convergence theorem,  converge on .<br>(2)<br>
Let , then<br><br>Thus  diverges on .<br>□<br>Exercise.
<img alt="hw7-2025041518.png" src="lib\media\hw7-2025041518.png">
<br>Proof.<br>
Pick any  then for any , we have<br><br>Similar for , then  is uniformly continuous on .<br>For any , pick  then for any , we have<br><br>Thus  is uniformly continuous on . Hence  is uniformly continuous on .<br>
□<br>Exercise.
<img alt="1-hw7-2025041518.png" src="lib\media\1-hw7-2025041518.png">
<br>Proof.<br>
For any , for any given  we have<br><br>exists.<br><br>By dominate convergence theorem,  converge on .<br>
□]]></description><link>数学分析进阶\hw7.html</link><guid isPermaLink="false">数学分析进阶/hw7.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\960a7c361de1ee39a977c4ad836fb639.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\960a7c361de1ee39a977c4ad836fb639.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw8]]></title><description><![CDATA[ 
 <br><img alt="fc79a56f39495e5f630fe3b481bca532.jpg" src="lib\media\fc79a56f39495e5f630fe3b481bca532.jpg"><br>Exercise.

<br>Prove the important limit .

<br>Proof.<br><br><br>When , <br><br>Thus for ,<br><br>Let , then<br><br>i.e. <br><br>Since  is continuous,<br><br>□<br>Exercise.

<br>If  is strictly monotonically increasing on , , then .

<br>Proof.<br>
Since  and  is strictly monotonically increasing on , for any , there exists , s.t. <br><br>Otherwise  for some , which is a contradiction. Since  is strictly monotonically increasing, we have<br><br>Thus . Since  is arbitrary, we have <br><br>□<br>Exercise.

<br>Find .

<br>似乎题出错了.<br>
<img alt="h-2025041721.png" src="lib\media\h-2025041721.png"><br>
<img alt="1-h-2025041721.png" src="lib\media\1-h-2025041721.png"><br>Exercise.

<br> is defined in . Prove that if , then

but the converse is not necessarily true.

<br>Proof.<br>
If  then for any , there exsits , s.t. <br><br>Then for any , , then <br><br>Thus .<br>Conversely, a conterexample is <br><br>For , the limit  but .<br>
□<br>Exercise.

<br>Let , denote , and . Then for ,



<br>Proof.<br>
By the definition of  and , there are two sequences ,  s.t. <br><br>For any , there are infinitely many elements of  lying in , and infinitely many elements of  lying in . WLOG, assume that  and . By the continuity of , applying the IVT, there exists  s.t. . Thus we have a sequence  with .<br>
□<br>Exercise.

<br>(1) Does there exist a function that is continuous at irrational points and discontinuous at rational points?

(2)  Does there exist a function that is continuous at rational points and discontinuous at irrational points?
<br>(1) Yes.<br>Example (Raindrop function).
Define Thomae's function  as follows:

Then  is continuous at every irrational point and discontinuous at every rational point.
<br>(2) No, there does not exist a function that is continuous at rational points and discontinuous at irrational points. The set of points at which a function is continuous must be a  set (a countable intersection of open sets). The set of rational numbers is not a  set.<br>Theorem.
The set of points at which a function is continuous must be a  set.
<br>Proof.<br>
Let  be a function. Let  be the set of points at which  is continuous. We want to show that  is a  set.<br>For each  and each , define<br><br> is open for each , since it is the union of open intervals.<br>We claim that  if and only if for all , . In other words, we claim that  if and only if for every  there exists an open interval  such that  and .<br>Then  if and only if for every  there exists  such that if , then . Therefore,  if and only if for all .<br>Thus, . Since each  is open,  is a  set.<br>Now we prove the if and only if statement.<br> If  is continuous at , then for every , there exists  such that if , then . Let  and , then  and . So  for all .<br> If for all , , then for every  there exists an open interval  such that  and . Let  be given. Choose  large enough such that . Then there exists an open interval  such that  and . Choose  such that . Then if  then . So  is continuous at .<br>
□<br>Exercise.

<br>Prove that the Cantor function on  is continuous.

<br>Definition (Cantor function).
The Cantor function is defined as follows:

<br>Write  in base 3 :  where .
<br>If  has a 1 in its ternary expansion, truncate the expansion at the first occurrence of a 1. Change every digit after that first 1 to 0.
<br>Replace all 2's with 1's.
<br>Interpret the result as a binary number.

This gives the value of the Cantor function .
<br>Proof.<br>
Let . We want to show that for every , there exists a  such that if , then .<br>Let . Choose  such that .<br>Choose . Suppose .<br>Write  and .<br>Since , we must have  for all .<br>Let  and  be the binary representations of  and  respectively.<br>Since  for all , the first  digits of the ternary expansions of  and  are the same.<br>When we apply the Cantor function, we truncate the ternary expansion at the first occurrence of 1, and then change all 2's to 1's. Therefore, the first  digits of the binary expansions of  and  are either the same, or differ by the truncation and replacement rules.<br>In any case, .<br>We can also say .<br>Thus,  is continuous.<br>
□<br>
Alternative proof:<br>
Proof.<br>
Let .<br>Let  where .<br>The Cantor function  is continuous everywhere except at points where  has a 1 in its ternary expansion.<br>If  has a 1 in its ternary expansion, truncate the expansion at the first occurrence of a 1. Change every digit after that first 1 to 0.<br>Replace all 2's with 1's.<br>Interpret the result as a binary number.<br>Let  in base 3.<br>Then  in base 2, where  if  and  if .<br>Let  in base 3.<br>Then  in base 2, where  if  and  if .<br>Since , we have .<br>Therefore,  is continuous at .<br>
□]]></description><link>数学分析进阶\hw8.html</link><guid isPermaLink="false">数学分析进阶/hw8.md</guid><pubDate>Fri, 02 May 2025 16:55:30 GMT</pubDate><enclosure url="lib\media\fc79a56f39495e5f630fe3b481bca532.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\fc79a56f39495e5f630fe3b481bca532.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw9]]></title><description><![CDATA[ 
 <br><img alt="dcd8d4db5536a3e7deec52448a5ff0b9.jpg" src="lib\media\dcd8d4db5536a3e7deec52448a5ff0b9.jpg"><br>Exercise.
<img alt="hw9-2025042812.png" src="lib\media\hw9-2025042812.png">
<br>Proof.<br>
(1)<br><br>(2)<br><br><br>正确的复数极化恒等式为<br><br>□<br>Exercise.
<img alt="hw9-2025042813.png" src="lib\media\hw9-2025042813.png">
<br>Proof.<br>
显然 <br><br>距离函数<br><br>就不满足正齐次性.<br>
□<br>Exercise.
<img alt="1-hw9-2025042813.png" src="lib\media\1-hw9-2025042813.png">
<br>Proof.<br>
For any  satisfying , by Holder's inequality,<br><br>Thus<br><br>Similarly, <br><br>Pick  s.t. <br><br>Then<br><br> □<br>Exercise.
<img alt="hw9-2025042814.png" src="lib\media\hw9-2025042814.png">
<br>在数学领域中，术语“NLP”通常指的是非线性规划 (Nonlinear Programming)。<br>
非线性规划是优化理论的一个分支，研究的是在非线性等式或不等式约束下，如何最小化或最大化一个非线性目标函数的问题。<br>一个一般的非线性规划问题可以表述为：<br>
最小化（或最大化）<br>
约束条件为：<br><br>其中：<br>
<br> 是决策变量向量。
<br> 是目标函数，它是一个非线性函数。
<br> 是不等式约束函数，它们可以是线性的或非线性的。
<br> 是等式约束函数，它们可以是线性的或非线性的。
<br> 是变量的定义域或简单的边界约束，通常是一个凸集。
<br>如果目标函数  或任何一个约束函数  或  是非线性的，那么这个问题就被称为非线性规划问题。作为对比，如果目标函数和所有约束函数都是线性的，那么问题就是线性规划（LP）问题。<br>非线性规划问题的求解通常比线性规划复杂得多，一般没有统一的，能在多项式时间内找到全局最优解的方法（除非问题具有特定的结构，如凸规划）。常用的求解方法包括梯度下降法，牛顿法，序列二次规划（SQP）等。<br>请注意，您可能更熟悉在人工智能和计算机科学领域中的“NLP”，它代表的是自然语言处理（Natural Language Processing）。但在数学的优化或运筹学等领域中，“NLP”几乎总是指代非线性规划。<br>Exercise.
<img alt="1-hw9-2025042814.png" src="lib\media\1-hw9-2025042814.png">
<br>Proof.<br>
Check:<br>
<br> is normed linear space.
<br> is complete.
<br>To check that  is a linear space, we need to verify that it satisfies the axioms of a vector space.<br>
<br>
Closure under addition: If , then  is also continuous on . Thus, .

<br>
Closure under scalar multiplication: If  and  is a scalar, then  is also continuous on . Thus, .

<br>
Commutativity of addition: For all ,  for all , so .

<br>
Associativity of addition: For all ,  for all , so .

<br>
Existence of additive identity: The zero function  for all  is continuous on , so . For any ,  for all , so .

<br>
Existence of additive inverse: If , then  is also continuous on , so . For any ,  for all , so .

<br>
Compatibility of scalar multiplication with field multiplication: For all scalars  and ,  for all , so .

<br>
Identity element of scalar multiplication: For all ,  for all , so .

<br>
Distributivity of scalar multiplication with respect to vector addition: For all scalars  and ,  for all , so .

<br>
Distributivity of scalar multiplication with respect to field addition: For all scalars  and ,  for all , so .

<br>Since  satisfies all the axioms of a vector space, it is a linear space.<br>Definition (Normed linear space).
A normed linear space is a linear space  on which there is defined a real-valued function that satisfies
(i)  for all , and  if and only if .<br>
(ii)  for all .<br>
(iii)  for all  and all scalars .
<br>Clearly, . <br><br><br>Definition (Complete Space).
A metric space  is called complete if every Cauchy sequence in  converges to a limit that is also in .
<br>Suppose there is a Cauchy sequence  of functions in . Check that  converges in . Let , then for any , there exists  s.t. , <br><br>Let  then<br><br>Check that . For any , there exists , s.t. <br><br>Then<br><br>, then we are done.<br>
□]]></description><link>数学分析进阶\hw9.html</link><guid isPermaLink="false">数学分析进阶/hw9.md</guid><pubDate>Fri, 02 May 2025 16:55:30 GMT</pubDate><enclosure url="lib\media\dcd8d4db5536a3e7deec52448a5ff0b9.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\dcd8d4db5536a3e7deec52448a5ff0b9.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw10]]></title><description><![CDATA[ 
 <br><img alt="6498218cd114e8c64311afd79fffef67.jpg" src="lib\media\6498218cd114e8c64311afd79fffef67.jpg"><br>Exercise.
<img alt="hw10-2025050821.png" src="lib\media\hw10-2025050821.png">
<br>For any , put , then<br><br>Thus  is uniformly continuous on .<br>Exercise.
<img alt="1-hw10-2025050821.png" src="lib\media\1-hw10-2025050821.png">
<br>
这个习题很有挑战性！
<br>Remark.
参见 Stein 习题 3.16 (d)<br>
<img alt="2-hw10-2025050822.png" src="lib\media\2-hw10-2025050822.png"><br>
<img alt="3-hw10-2025050822.png" src="lib\media\3-hw10-2025050822.png">
<br> 时一致收敛， 时存在反例.<br>
反例参见《实分析中的反例》汪林<br>
<img alt="4-hw10-2025050822.png" src="lib\media\4-hw10-2025050822.png">
<br>证明太长了<br><img alt="hw10-2025050823.png" src="lib\media\hw10-2025050823.png"><br>
<img alt="1-hw10-2025050823.png" src="lib\media\1-hw10-2025050823.png"><br>
<img alt="2-hw10-2025050823.png" src="lib\media\2-hw10-2025050823.png"><br>A simpler version in Harmonic Analysis, Katznelson, p.33 :<br>
<img alt="3-hw10-2025050823.png" src="lib\media\3-hw10-2025050823.png"><br>Exercise.
<img alt="2-hw10-2025050821.png" src="lib\media\2-hw10-2025050821.png">
<br>du Bois-Reymond showed an counterexample.<br>
参见于品《数学分析讲义 123》p.660<br>
<img alt="hw10-2025050822.png" src="lib\media\hw10-2025050822.png">
<br><img alt="1-hw10-2025050822.png" src="lib\media\1-hw10-2025050822.png"><br>Exercise.
<img alt="3-hw10-2025050821.png" src="lib\media\3-hw10-2025050821.png">
<br>
题目可能出错了， 在  上无定义. 
<br>Since  and  are continuous differentiable out of the neighborhood of 0,  is continuous differentiable.<br>For ,<br><br>For ,<br>Exercise.
<img alt="4-hw10-2025050821.png" src="lib\media\4-hw10-2025050821.png">
<br> 在  的  阶-Holder 常数定义为<br><br>这是  上导数定义的推广（推广到分数阶）.<br>(1)<br>
对于 ，当  时，<br><br>于是<br><br>类似的，对于 ，<br><br>当  时，<br><br>于是<br><br>因此<br><br>(2)<br>
For ,  small enough<br><br>Thus<br><br>Similarly, for ,<br><br>When , <br><br>Then<br><br>Hence<br><br>Exercise.
<img alt="5-hw10-2025050822.png" src="lib\media\5-hw10-2025050822.png">
<br>若  则称 ；若还有 ，，则称 . <br>由此，(1) 是显然的.<br>(2)<br>
Too hard.
<br>选择合适的希尔伯特空间和带有合适边界条件的定义域（例如，Dirichlet条件下的，或上的)，算子就是一个无界正算子。]]></description><link>数学分析进阶\hw10.html</link><guid isPermaLink="false">数学分析进阶/hw10.md</guid><pubDate>Thu, 08 May 2025 15:50:01 GMT</pubDate><enclosure url="lib\media\6498218cd114e8c64311afd79fffef67.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\6498218cd114e8c64311afd79fffef67.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[hw11]]></title><description><![CDATA[ 
 <br><img alt="b3af1a78cc4641ad344199485048bd09.jpg" src="lib\media\b3af1a78cc4641ad344199485048bd09.jpg"><br>Exercise.
<img alt="hw11-2025051923.png" src="lib\media\hw11-2025051923.png">
<br>For , , then , thus , <br><br>Let , then , i.e. <br><br>We are done!<br>Exercise.
<img alt="1-hw11-2025051923.png" src="lib\media\1-hw11-2025051923.png">
<br>(1)<br>
There exists , such that<br><br>Then for any <br><br>where . <br>(2)<br>
If <br><br>for some . Let , then . Thus  is continuous at .<br>Definition (变分).
<img alt="2-hw11-2025051923.png" src="lib\media\2-hw11-2025051923.png">
<br>Definition (Holder 条件).
<img alt="3-hw11-2025051923.png" src="lib\media\3-hw11-2025051923.png">
<br>Exercise.
<img alt="hw11-2025052000.png" src="lib\media\hw11-2025052000.png">
<br>Proof.<br>
由于将  个分点一次插入  与将这  个分点逐个插入 ，所得到的都是分割 ，因此我们可以考虑将这  个分点逐个插入  的情况。设步长为 .<br>设<br><br>先考虑在  中插入一个分点 ，记对应的新分割为 ，不妨设  被插入小区间  中，于是<br><br>这样，对应于分割  的小区间有  个，它们包含分割  的  个完全相同的小区间以及  被  分成的两个子区间 , . 记<br><br>则<br><br>由于<br><br>所以 , 即 . 从而有<br><br>对于在  中插入两个分点对应的分割 ，可以看成在  中插入一个分点，于是有 , 且 . 从而<br><br>分割  是由分割  增加  个分点所得的新分割，则<br><br>对于不等式的第二部分 ： 当从  添加一个分点得到  时，这个新分点必然落入  的某个子区间，设其长度为 。根据单点插入的结果，我们有： . 由于  是  的一个加细分割（或者是  本身），其任何子区间的长度  都不会超过  的最大子区间长度，即 。所以，  对于 。现在我们可以进行迭代：<br>
这就证明了不等式的第二部分：。 综上所述，对于下和，我们已经完整证明了：  命题证毕。<br>□<br>Exercise.
<img alt="1-hw11-2025052000.png" src="lib\media\1-hw11-2025052000.png">
<br>只需要证明<br><br>对于任意给定的  的划分 , 由定义可知<br><br>令  就有<br><br>另一方面，对于任意给定的  的划分 , 由 <a data-href="#^e12f09" href="about:blank#^e12f09" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^e12f09</a><a data-href="#^e12f09" href="about:blank#^e12f09" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Exercise 2</a>, <br><br>令  就有<br><br>再对  取  就有<br><br>故<br><br>类似可证：<br><br>Definition (上积分的定义).
设  是一个有界函数。对于  的一个划分 ，其中 ，令 。上达布和定义为 。
上积分  定义为所有上达布和的下确界：

<br>Definition (下积分的定义).
设  是一个有界函数。对于  的一个划分 ，其中 ，令 。下达布和定义为 。
下积分  定义为所有下达布和的上确界：

<br>Definition (Darboux 上和与下和).
设  是定义在  上的有界函数,  是  的一个分割. 记  和 . 定义  关于分割  的 Darboux 上和 为

定义  关于分割  的 Darboux 下和 为

<br>Exercise.
<img alt="2-hw11-2025052000.png" src="lib\media\2-hw11-2025052000.png">
<br>
由于闭区间单调函数有界，单调函数间断点至多可数，由 Lebesgue 定理可知，闭区间单调函数 Riemann 可积.
<br>Theorem (Lebesgue 定理).
 是有界的. 则  黎曼可积当且仅当  的不连续点集是勒贝格零测集.
<br>下面我们给出一个初等的证明：<br><img alt="hw11-2025052001.png" src="lib\media\hw11-2025052001.png"><br>
<img alt="1-hw11-2025052001.png" src="lib\media\1-hw11-2025052001.png"><br><img alt="2-hw11-2025052001.png" src="lib\media\2-hw11-2025052001.png"><br>
<img alt="3-hw11-2025052001.png" src="lib\media\3-hw11-2025052001.png">]]></description><link>数学分析进阶\hw11.html</link><guid isPermaLink="false">数学分析进阶/hw11.md</guid><pubDate>Mon, 19 May 2025 17:09:57 GMT</pubDate><enclosure url="lib\media\b3af1a78cc4641ad344199485048bd09.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\b3af1a78cc4641ad344199485048bd09.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[测地曲率和测地线(计算版本)]]></title><description><![CDATA[ 
 <br><br>通常我们把欧式平面看作是二维平直空间 (Gauss 曲率为零)，而把给定第一基本形式的抽象曲面称为二维弯曲空间. 本章的目标就是研究二维弯曲空间中的几何学.<br><br>对于正则参数曲面  满足方程 .  是曲面  上的一条曲线，它的方程是 ，其中  是曲线  的弧长参数. 那么  的参数方程为 <br><br>我们的目的是沿着曲线  建立一个新的正交标架场 ，兼顾  和  ，定义如下<br><br>直观上， 是将曲线  的切向量  绕着  的单位法向量  正向旋转  得到的. 改标架场沿着曲线  的运动公式为<br><br>其中  是曲线  的曲率向量在曲面  的法向量上的正交投影，故  恰好是曲面  上的曲线  的法曲率； 是曲线  的曲率向量在曲面  的切平面上的正交投影。这里的  的计算公式是<br><br>把最后的式子展开得到<br><br>曲线  作为曲面  内的曲线的测地曲率  和它作为空间曲线的曲率  的关系式是<br><br>这里  是曲线  的次法向量和曲面  的单位法向量之间的夹角．<br>沿曲线  的上述正交标架场的运动公式中的  不是属于曲面的内蕴几何学的量，它的计算公式是<br><br>称为曲线的测地挠率. 实际上，测地挠率  和法曲率  的性质相同，都是曲面  在任意一点的切方向的函数，与曲线  本身的弯曲性无关. <br><br>Definition (测地线).
在曲面  上测地曲率恒等于零的曲线称为曲面  上的测地线. 曲面  上的测地线是属于曲面  的内蕴几何学的概念.
<br>因为平面曲线的测地曲率就是它的相对曲率，因此平面上的测地线就是该平面上的直线．由此可见，曲面上的测地线的概念是平面上的直线概念的推广．<br><br>曲面  上的测地线  作为  的外围空间  中的曲线的特征是：或者曲线  本身是直线，或者它的主法向量处处是曲面  的法向量．从运动学观点来看，测地线  的特征是：如果在曲面  上运动的质点  只受到将它约束在曲面  上的力的作用（即作用力的方向垂直于曲面  ），则点  的轨迹  是曲面  上的测地线．<br><br>曲面  上的测地线  所满足的内在特征是：对于它在曲面  内的任意一个有固定端点的变分  而言， 的弧长是变分曲线  的弧长的临界值．<br><br><img alt="测地曲率和测地线(计算版本)-2025040401.png" src="lib\media\测地曲率和测地线(计算版本)-2025040401.png"><br><br><img alt="1-测地曲率和测地线(计算版本)-2025040401.png" src="lib\media\1-测地曲率和测地线(计算版本)-2025040401.png"><br>
<img alt="2-测地曲率和测地线(计算版本)-2025040401.png" src="lib\media\2-测地曲率和测地线(计算版本)-2025040401.png">]]></description><link>微分几何\测地曲率和测地线(计算版本).html</link><guid isPermaLink="false">微分几何/测地曲率和测地线(计算版本).md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\测地曲率和测地线(计算版本)-2025040401.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\测地曲率和测地线(计算版本)-2025040401.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[极小曲面]]></title><description><![CDATA[ 
 <br><br>参见彭家贵《微分几何教材》<br>Definition (极小曲面).
 中平均曲率处处恒为零的曲面称为极小曲面.
<br><br>第一基本形式系数<br><br>中的曲率函数<br><br>即曲面为极小曲面．]]></description><link>微分几何\极小曲面.html</link><guid isPermaLink="false">微分几何/极小曲面.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate></item><item><title><![CDATA[空间曲线(不严谨)]]></title><description><![CDATA[ 
 <br><br><br>对于  中的正则曲线 () ，引进参数  使得<br><br> 被称为曲线  的 (弧长参数. 一个显然的事实是，正则曲线  的参数  为正则参数的特征是 . 一般的计算中， 未必是弧长参数. <br>关于空间曲线的理论，最重要的是沿曲线  定义的 Frenet 标架  和 Frenet 公式. <br>假定空间曲线  的参数方程为 ，其中  是弧长参数，那么它的<br>单位切向量：<br><br>曲率：<br><br>曲率非零时，主法向量 (这样的定义是自然的)：<br><br>次法向量：<br><br>挠率<a data-footref="[inline0" href="about:blank#fn-1-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a><br><br>曲线的 Frenet 公式是<br><br>上式都是关于弧长参数  的导数.<br><br>首先根据  定义知道 . 其次根据  的定义知道<br><br>根据  最原本的定义可知<br><br>接下来待定系数求解 ，分别与  作内积得到<br><br>从而<br><br>我们完成了 Frenet 公式的推导证明！<br><br>在曲线的一般参数下，设曲线的参数方程是  ，则它的单位切向量是<br><br>假定曲线的弧长参数是  ，则  ，所以<br><br>因此<br><br>故<br><br>由此得到曲线的曲率是<br><br>次法向量是<br><br>这样，曲线的主法向量是<br><br>再利用 Frenet 公式得到<br><br>此时，单位切向量，主法向量和次法向量的导数是<br><br>Theorem (空间曲线基本定理).
给定两个连续可微函数  其中 ，则在三维欧式空间中存在一条空间曲线，以  为弧长参数，以  为曲率，以  为挠率，并且这样的曲线的形状是完全确定的.
<br>Remark.
在给定  的情况下，Frenet 公式构成了向量  的微分方程组，可以求解.
<br><br>两条相交曲线在交点附近的接近程度是用所谓的切触阶来刻画的.<br>
<img alt="3-空间曲线(不严谨)-2025040423.png" src="lib\media\3-空间曲线(不严谨)-2025040423.png"><br><br>平面曲线可以看作空间曲线的特例，即  的空间曲线. 空间曲线求曲率  的公式照用. 特别的是，平面本身有定向，将其单位切向量正向 (逆时针) 旋转  便得到法向量 (唯一确定). 于是<br><br>正向旋转  得到<a data-footref="[inline1" href="about:blank#fn-2-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[2]</a><br><br>相对曲率<br><br>相对曲率  与曲率  的关系是 . 正号表示曲线朝着  的方向弯曲，负号表示曲线的主法向量为 .<br><br><br><br><br>已知参数方程，直接套公式爆算：<br>
<img alt="3-空间曲线(不严谨)-2025040322.png" src="lib\media\3-空间曲线(不严谨)-2025040322.png"><br>
已知一般方程：<br>
<img alt="空间曲线(不严谨)-2025040322.png" src="lib\media\空间曲线(不严谨)-2025040322.png"><br>
直接通过对方程求导，求解出 .<br>
<img alt="2-空间曲线(不严谨)-2025040322.png" src="lib\media\2-空间曲线(不严谨)-2025040322.png"><br><br><img alt="4-空间曲线(不严谨)-2025040322.png" src="lib\media\4-空间曲线(不严谨)-2025040322.png"><br><img alt="5-空间曲线(不严谨)-2025040322.png" src="lib\media\5-空间曲线(不严谨)-2025040322.png"><br><br><img alt="6-空间曲线(不严谨)-2025040322.png" src="lib\media\6-空间曲线(不严谨)-2025040322.png"><br><img alt="7-空间曲线(不严谨)-2025040322.png" src="lib\media\7-空间曲线(不严谨)-2025040322.png"><br><br><img alt="8-空间曲线(不严谨)-2025040322.png" src="lib\media\8-空间曲线(不严谨)-2025040322.png"><br>根据曲线论基本定理具有这样常数曲率  和挠率  的曲线必定是圆螺旋线<br><br>Remark.
本题也可以根据 Frenet 标架直接求解微分方程组.
<br><br><img alt="9-空间曲线(不严谨)-2025040322.png" src="lib\media\9-空间曲线(不严谨)-2025040322.png"><br><img alt="10-空间曲线(不严谨)-2025040322.png" src="lib\media\10-空间曲线(不严谨)-2025040322.png"><br><br><img alt="11-空间曲线(不严谨)-2025040322.png" src="lib\media\11-空间曲线(不严谨)-2025040322.png"><br><br><img alt="12-空间曲线(不严谨)-2025040322.png" src="lib\media\12-空间曲线(不严谨)-2025040322.png"> <img alt="13-空间曲线(不严谨)-2025040322.png" src="lib\media\13-空间曲线(不严谨)-2025040322.png"><br>
<img alt="14-空间曲线(不严谨)-2025040322.png" src="lib\media\14-空间曲线(不严谨)-2025040322.png"><br>
<br>
<br>挠率一开始的定义就是使得  的  函数，下面这个只是计算式.<a href="about:blank#fnref-1-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
<br>不一定是主法向量<a href="about:blank#fnref-2-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>微分几何\空间曲线(不严谨).html</link><guid isPermaLink="false">微分几何/空间曲线(不严谨).md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\3-空间曲线(不严谨)-2025040423.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\3-空间曲线(不严谨)-2025040423.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[曲面的整体性质]]></title><description><![CDATA[ 
 <br>参见《微分几何学习指导》徐森林<br><br><br><img alt="曲面的整体性质-2025040823.png" src="lib\media\曲面的整体性质-2025040823.png"><br><br><img alt="1-曲面的整体性质-2025040823.png" src="lib\media\1-曲面的整体性质-2025040823.png"><br>
<img alt="3-曲面的整体性质-2025040823.png" src="lib\media\3-曲面的整体性质-2025040823.png"><br>
<img alt="5-曲面的整体性质-2025040823.png" src="lib\media\5-曲面的整体性质-2025040823.png"><br>
<img alt="6-曲面的整体性质-2025040823.png" src="lib\media\6-曲面的整体性质-2025040823.png"><br>
<img alt="7-曲面的整体性质-2025040823.png" src="lib\media\7-曲面的整体性质-2025040823.png"><br><br><img alt="曲面的整体性质-2025040900.png" src="lib\media\曲面的整体性质-2025040900.png"><br>曲面上点  为脐点，当且仅当存在  使得<br>]]></description><link>微分几何\曲面的整体性质.html</link><guid isPermaLink="false">微分几何/曲面的整体性质.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\曲面的整体性质-2025040823.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\曲面的整体性质-2025040823.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[曲面论(不严谨)]]></title><description><![CDATA[ 
 <br><br>为了说明  构成曲面的完全的不变量系统，需要曲面论的基本公式，也就是曲面的自然标架场的求导公式．它们在曲面的理论中扮演基本的角色，相当于曲线论中的 Frenet 公式．<br>Einstein 和式约定：<br>
<img alt="曲面论(不严谨)-2025040322.png" src="lib\media\曲面论(不严谨)-2025040322.png"><br>规定希腊字母  作为指标的取值范围为 . 规定拉丁字母  作为指标的取值范围为 .<br><img alt="曲面论(不严谨)-2025040323.png" src="lib\media\曲面论(不严谨)-2025040323.png"><br><br>Theorem (Gauss 绝妙定理).
曲面的 Gauss 曲率是曲面在保长变换下的不变量.
<br>事实上，由 Gauss 方程可知<br><br>因此曲面的 Gauss 曲率是由它的第一基本形式完全确定的. 在  的情形，Gauss 曲率用曲面的第一基本形式的表达式是<br><br>在曲面的等温参数系下，，则 Gauss 曲率的表达式是<br><br>Remark.
Gauss 绝妙定理是微分几何学发展过程中的里程碑，开创了内蕴几何学的新时代，进而引发了 Riemann 几何学.
]]></description><link>微分几何\曲面论(不严谨).html</link><guid isPermaLink="false">微分几何/曲面论(不严谨).md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\曲面论(不严谨)-2025040322.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\曲面论(不严谨)-2025040322.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[曲面形式(不严谨)]]></title><description><![CDATA[ 
 <br><br>参考微分几何例题详解和习题汇编·陈维恒.<br>正则参数曲面<a data-footref="[inline0" href="about:blank#fn-1-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a>  是满足  的连续可微映射<br><br> 在每一点处有确定的标架 ，其中<br><br>称一个变换  为正则参数变换，若<br><br>而且有足够的可微性.<br><br>其中 .<br><br>直纹面可以表示为<br><br>其中  是直纹面的准现， 是直母线的方向向量. <br><br>可展曲面是一种特殊的直纹面. 它的切平面沿每一条直母线是不变的. 曲面  是可展曲面的充要条件是<br><br><br><br><br>Exercise.
例题 3.2 写出单叶双曲面  作为直纹面的参数方程．
<br>直接强行因式分解即可.<br><br><img alt="曲面形式(不严谨)-2025040320.png" src="lib\media\曲面形式(不严谨)-2025040320.png"><br><br><img alt="2-曲面形式(不严谨)-2025040320.png" src="lib\media\2-曲面形式(不严谨)-2025040320.png"><br><br>Exercise.
例题 3.5 证明：一个正则参数曲面是球面的一部分的充分必要条件是，它的所有法线都经过一个固定点．
<br>必要性显然，下面考虑充分性：假定曲面  的所有法线都经过一个固定点 , 即存在函数  使得<br><br>下面证明  是常值函数. 将 <a data-href="#^caa238" href="about:blank#^caa238" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^caa238</a><a data-href="#^caa238" href="about:blank#^caa238" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (1)</a> 分别对  求导数得到<br><br>因为  是切向量，又因为单位向量函数  的偏导数必定与其它自身正交，因此用  与 <a data-href="#^c27a16" href="about:blank#^c27a16" class="original-internal-link" target="_blank" rel="noopener nofollow" style="display: none;">^c27a16</a><a data-href="#^c27a16" href="about:blank#^c27a16" class="internal-link mathLink-internal-link" target="_self" rel="noopener nofollow">Equation (2)</a> 做内积得到 . 这说明 ，于是<br><br>因此 .<br><br>Exercise.
例题 3.6 证明：旋转面的法线必定与旋转轴平行或相交；反过来，如果一个正则参数曲面的所有法线都与一条固定的直线相交，则它必定是旋转面．
<br>必要性显然. 因为旋转面的参数方程为<br><br>其中 . <br>充分性的证明需要发挥一点几何想象力．不妨假定曲面  的所有法线都经过  －轴，用一个通过  －轴，并且与  平面的夹角为  的平面截曲面  ，其截线的参数方程可以假设为  ，这就是说该截线上的点到  －轴的距离是  ，到  平面的距离是  ，这里  是该截线上的参数， 是任意的固定值．现在要证明：函数  与  无关，因而该曲面  就是一个旋转面.<a data-footref="[inline1" href="about:blank#fn-2-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[2]</a> <br><br>Exercise.
例题 3.10 设球面的参数方程是（参看例题 3．3（1））

求它的第一基本形式．
<br>直接计算 .<br><br><img alt="曲面形式(不严谨)-2025040321.png" src="lib\media\曲面形式(不严谨)-2025040321.png"><br><img alt="1-曲面形式(不严谨)-2025040321.png" src="lib\media\1-曲面形式(不严谨)-2025040321.png"><br><br><img alt="2-曲面形式(不严谨)-2025040321.png" src="lib\media\2-曲面形式(不严谨)-2025040321.png"><br>先写成第一基本形式，然后再配方换元.<br><br>Exercise.
求单参数平面族的包络：<br>

<br>命<br><br>则<br><br>将方程组  中的参数  消去得到<br><br>这是一张柱面，属于可展曲面的一种．写成参数方程的形式是<br><br><br>曲面第一基本形式描写曲面上与度量有关的性质，曲面第二基本形式描写曲面的形状. <br>设曲面  的参数方程是 ，其单位法向量为 ，则曲面的第二基本形式为<br><br>其中<br><br>在计算系数  时，必须用单位法向量. 初学者容易犯用  代替  的错误.<br>法曲率：<br><br>正则参数曲面在任意一个固定点，其法曲率必定在两个彼此正交的切方向上分别取最大值和最小值．曲面在一个固定点处沿各个切方向的法曲率的最大值和最小值称为曲面在该点的主曲率，记为  ，达到这最大值和最小值的切方向称为曲面在该点的主方向．这个事实可以通过直接计算来证实（参看例题 4．5）．若曲面在  点的两个彼此正交的主方向单位向量是  ，对应的主曲率是  ，则曲面在点  沿着与主方向  的夹角为  的切方向的法曲率是<br><br>这就是著名的 Euler 公式．<br>Gauss 曲率:<br><br>平均曲率:<br><br><br><img alt="曲面形式(不严谨)-2025040322.png" src="lib\media\曲面形式(不严谨)-2025040322.png"><br><br><img alt="1-曲面形式(不严谨)-2025040322.png" src="lib\media\1-曲面形式(不严谨)-2025040322.png"><br><img alt="2-曲面形式(不严谨)-2025040322.png" src="lib\media\2-曲面形式(不严谨)-2025040322.png"><br><br>法曲率为零的切方向称为渐近方向．曲面只在双曲点和抛物点有渐近方向．曲面上其切方向处处是曲面的渐近方向的曲线称为曲面上的渐近曲线．渐近曲线的微分方程是<br><br><br><img alt="3-曲面形式(不严谨)-2025040322.png" src="lib\media\3-曲面形式(不严谨)-2025040322.png"><br><br><br><img alt="4-曲面形式(不严谨)-2025040322.png" src="lib\media\4-曲面形式(不严谨)-2025040322.png"><br><img alt="5-曲面形式(不严谨)-2025040322.png" src="lib\media\5-曲面形式(不严谨)-2025040322.png"><br>
<img alt="6-曲面形式(不严谨)-2025040322.png" src="lib\media\6-曲面形式(不严谨)-2025040322.png"><br>
<img alt="7-曲面形式(不严谨)-2025040322.png" src="lib\media\7-曲面形式(不严谨)-2025040322.png"><br>
<img alt="8-曲面形式(不严谨)-2025040322.png" src="lib\media\8-曲面形式(不严谨)-2025040322.png"><br><br>曲面上点  为脐点，当且仅当存在  使得<br><br><img alt="9-曲面形式(不严谨)-2025040322.png" src="lib\media\9-曲面形式(不严谨)-2025040322.png"><br>
这题计算量太大
<br>
<br>
<br>正则曲面是二维流形的例子，曲面的每一个正则参数表示给出了一个局部坐标系<a href="about:blank#fnref-1-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
<br>很明显，当  变化时，上面的截线就扫出曲面  .<a href="about:blank#fnref-2-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>微分几何\曲面形式(不严谨).html</link><guid isPermaLink="false">微分几何/曲面形式(不严谨).md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\曲面形式(不严谨)-2025040320.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\曲面形式(不严谨)-2025040320.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[数学类解析几何]]></title><description><![CDATA[ 
 <br><br>先自己画图看看能不能用几何直观秒了.<br><img alt="数学类解析几何-2025040420.png" src="lib\media\数学类解析几何-2025040420.png"><br><br>见《解析几何》·吕林根·第四版<br>二次曲面的一般方程为<br><br>适当选取坐标系，二次曲面的方程总可以化为下列五个方程之一：<br>
<br>.
<br>.
<br>.
<br>.
<br>.
<br>通过适当选取坐标系，二次曲面的方程总可以化成以下十七种形式之一：<br><br>椭球面<br><br>单叶双曲面<br><br>双叶双曲面<br><br>二次锥面<br><br>椭圆抛物面<br><br>双曲抛物面<br><br>椭圆柱面<br><br>双曲柱面<br><br>抛物柱面<br><br><br>虚椭球面<br><br>点（虚母线二次锥面）<br><br>虚椭圆柱面<br><br>交于一条实直线的一对共轭虚平面<br><br>一对相交平面<br><br>一对平行平面<br><br>一对平行的共轭虚平面<br><br>一对重合平面<br><br><br>对  进行正交变换化为标准型即可. 或者直接配方.<br><br><img alt="数学类解析几何-2025040422.png" src="lib\media\数学类解析几何-2025040422.png"><br><br><img alt="1-数学类解析几何-2025040422.png" src="lib\media\1-数学类解析几何-2025040422.png"><br><br><img alt="数学类解析几何-2025040423.png" src="lib\media\数学类解析几何-2025040423.png"><br><img alt="1-数学类解析几何-2025040423.png" src="lib\media\1-数学类解析几何-2025040423.png">]]></description><link>微分几何\数学类解析几何.html</link><guid isPermaLink="false">微分几何/数学类解析几何.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate><enclosure url="lib\media\数学类解析几何-2025040420.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\数学类解析几何-2025040420.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Differential-Geometry]]></title><description><![CDATA[ 
 <br><br>Exercise.
八，（本题 12 分）在空间直角坐标系中，设悬链面  的方程为  ．
（1）证明：悬链面是极小曲面；
（2）求悬链面上 Gauss 曲率  取到最大值的所有点．
<br>（1）计算偏导数，得<br><br>于是曲面的单位法向量为<br><br>又它们的二阶偏导数为<br><br>故得第一基本形式系数<br><br>中的曲率函数<br><br>即曲面为极小曲面．<br>（2）Gauss 曲率  ．故  取到最大值 -1 当且仅当  ，对应悬链面上的点为单位圆周<br><br>Exercise.
八，（12 分）（i）设庞加莱上半平面  带有黎曼度量

证明  的测地线为圆心在  轴上的上半圆或者为平行于  轴的直线；<br>
（ii）对于半径为  的球面

称经过球心的平面与球面的交线为大圆．求球面上的测地线方程，并说明球面上的大圆是测地线；<br>
（iii）阐明（i），（ii）的几何意义
]]></description><link>微分几何\differential-geometry.html</link><guid isPermaLink="false">微分几何/Differential-Geometry.md</guid><pubDate>Fri, 02 May 2025 16:55:29 GMT</pubDate></item><item><title><![CDATA[数学分析]]></title><description><![CDATA[ 
 <br><img alt="数学分析-2025040517.png" src="figures\数学分析-2025040517.png"><br>
证明考虑泰勒展开<br><br>于是<br><br>令  那么<br>]]></description><link>数学分析.html</link><guid isPermaLink="false">数学分析.md</guid><pubDate>Fri, 02 May 2025 16:55:04 GMT</pubDate><enclosure url="figures\数学分析-2025040517.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;figures\数学分析-2025040517.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Appendix]]></title><description><![CDATA[ 
 <br><br><br>]]></description><link>appendix.html</link><guid isPermaLink="false">Appendix.md</guid><pubDate>Tue, 06 May 2025 07:27:10 GMT</pubDate></item><item><title><![CDATA[cmc决赛]]></title><description><![CDATA[ 
 <br><br>
<br>优先采用教材上提供的基本方法和自然的思路.
<br>换序问题在时间比较富裕的情况下一定要严格证明.
<br>中值定理一定是自然的构造, 不要想的奇奇怪怪.
<br>填空题是基本盘, 一定不能错, 多检查, 可以猜答案.
<br>遇事不绝, 分部积分.
<br>遇事不绝, 不妨设标准型.
<br>数学类高年级组误判率较高! 重代数轻分析!
<br>第一天考完下午和晚上是最好玩的, 抓紧时机面基各路大神, 笔者当初考完带着一堆小伙伴去撸串, 干了十瓶可乐.
<br>考完当天晚上就会出成绩, 误判几率不低, 可以尽力配合老师查分.
<br><br>
<br>Jordan 分解
<br>同时（正交）相似上三角/对角化<a data-footref="[inline0" href="about:blank#fn-1-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a>
<br>两个半正定矩阵  可以同时合同对角化.
<br>实对称矩阵和正定矩阵显然可以同时合同对角化
<br>矩阵打洞
<br>摄动法，可以不妨设可逆
<br> 和  有完全一样的非零 Jordan 块
<br>与所有可逆矩阵可交换的矩阵是数量矩阵 .
<br>对 ，有 .
<br>.
<br> 是半正定矩阵，等价于  所有主子式<a data-footref="[inline1" href="about:blank#fn-2-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[2]</a>非负，等价于  的所有特征值为非负实数，等价于存在  使得 .
<br>若  可逆，则  是  的多项式. 考虑特征多项式和哈密顿凯莱定理 (结合 )
<br> 是  的多项式. 注意到 .
<br>瑞丽商
<br>反对称实矩阵的特征值实部为 0.
<br>循环行列式
<br>求解 . 有唯一解的充要条件是  无相同特征值. 证明考虑分块 Jordan 爆算. 这也是对于  交结数的证明.
<br>特征多项式等于极小多项式的等价条件.
<br>覆盖定理
<br>实正规矩阵<a data-footref="[inline2" href="about:blank#fn-3-e4654dfa0e1b559e" class="footnote-link" target="_self" rel="noopener nofollow">[3]</a>的正交相似标准型.
<br>相似的正规矩阵必然酉相似. 若为实正规，则正交相似.
<br>酉相似实矩阵必然实正交相似. 
<br> 是复正规矩阵的充要条件是  的共轭转置是  的多项式
<br>三对角矩阵的行列式递推
<br>Perron 判别法
<br><img alt="cmc决赛-2025040617.png" src="figures\cmc决赛-2025040617.png"><br>
<img alt="1-cmc决赛-2025040617.png" src="figures\1-cmc决赛-2025040617.png"><br>
<img alt="2-cmc决赛-2025040617.png" src="figures\2-cmc决赛-2025040617.png"><br>
<img alt="3-cmc决赛-2025040617.png" src="figures\3-cmc决赛-2025040617.png"><br>
<img alt="3-cmc决赛-2025040618.png" src="figures\3-cmc决赛-2025040618.png"><br>
<img alt="4-cmc决赛-2025040618.png" src="figures\4-cmc决赛-2025040618.png"><br>
<img alt="5-cmc决赛-2025040618.png" src="figures\5-cmc决赛-2025040618.png"><br>
<img alt="6-cmc决赛-2025040618.png" src="figures\6-cmc决赛-2025040618.png"><br>
<img alt="7-cmc决赛-2025040618.png" src="figures\7-cmc决赛-2025040618.png"><br>
<img alt="8-cmc决赛-2025040618.png" src="figures\8-cmc决赛-2025040618.png"><br>
<img alt="9-cmc决赛-2025040618.png" src="figures\9-cmc决赛-2025040618.png"><br>
<img alt="10-cmc决赛-2025040618.png" src="figures\10-cmc决赛-2025040618.png"><br>
<img alt="11-cmc决赛-2025040618.png" src="figures\11-cmc决赛-2025040618.png"><br>
<img alt="12-cmc决赛-2025040618.png" src="figures\12-cmc决赛-2025040618.png"><br>
<img alt="13-cmc决赛-2025040618.png" src="figures\13-cmc决赛-2025040618.png"><br>
<img alt="14-cmc决赛-2025040618.png" src="figures\14-cmc决赛-2025040618.png"><br>
<img alt="15-cmc决赛-2025040618.png" src="figures\15-cmc决赛-2025040618.png"><br><img alt="16-cmc决赛-2025040618.png" src="figures\16-cmc决赛-2025040618.png"><br>
<img alt="17-cmc决赛-2025040618.png" src="figures\17-cmc决赛-2025040618.png"><br>
<img alt="18-cmc决赛-2025040618.png" src="figures\18-cmc决赛-2025040618.png"><br>
<br>
<br>正交性要求特征值全为实数，或者实对称...<a href="about:blank#fnref-1-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
<br>主子式是指取任意行和对应的列交叉出来的子式的行列式，代数主子式还要考虑逆序数.<a href="about:blank#fnref-2-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
<br><a href="about:blank#fnref-3-e4654dfa0e1b559e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>cmc决赛.html</link><guid isPermaLink="false">cmc决赛.md</guid><pubDate>Fri, 09 May 2025 02:43:00 GMT</pubDate><enclosure url="figures\cmc决赛-2025040617.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;figures\cmc决赛-2025040617.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[vim]]></title><description><![CDATA[ 
 <br><br><br><br><br>
<br>cw：删除从光标位置到单词末尾，并进入插入模式。<br>

<br>cb：删除从光标位置到单词开头，并进入插入模式。<br>

<br>c$&nbsp;或&nbsp;C：删除从光标到行尾的内容，并进入插入模式。<br>

<br>c0：删除从光标到行首的内容，并进入插入模式。<br>

<br>ci"&nbsp;/&nbsp;ci(&nbsp;/&nbsp;ci[：删除引号/括号内的内容，并进入插入模式（需光标在符号内）。
<br><br>• 输入 : 行号后按 Enter，例如 : 50 跳到第 50 行。<br><br><br>• i：在当前光标位置前进入插入模式。<br>• I：在当前行的开头进入插入模式。<br>• a：在当前光标位置后进入插入模式。<br>• A：在当前行末尾进入插入模式。<br>• o：在当前行下面新建一行并进入插入模式。<br>• O：在当前行上面新建一行并进入插入模式。<br><br>• x：删除当前光标处的字符。<br>• dw：删除从当前光标到下一个单词的开头。<br>• dd：删除当前整行。<br>• D：删除从当前光标到行末的内容。<br>• : n1, n2d 删除指定范围的行<br><br>• yy（或 Y）：复制当前整行。<br>• p：在当前光标后粘贴。<br>• P：在当前光标前粘贴。<br><br>• u：撤销上一步操作。<br>• Ctrl+r：重做上一步被撤销的操作。<br><br><br><br>• /pattern：向下查找匹配 pattern 的字符串。<br>• ?pattern：向上查找匹配 pattern 的字符串。<br>• n：重复上一次查找操作（相同方向）。<br>• N：重复上一次查找操作（相反方向）。<br><br>• :s/old/new/：替换当前行第一个匹配的字符串。<br>• :s/old/new/g：替换当前行所有匹配的字符串。<br>• :%s/old/new/g：替换整个文件中所有匹配的字符串。<br>• :%s/old/new/gc：替换时询问确认。<br><br><br>• :w：保存文件。<br>• :q：退出 Vim。<br>• :wq 或 :x：保存并退出。<br>• :q!：不保存强制退出。<br><br><br>• :e filename：打开文件 filename。<br>• :ls 或 :buffers：列出当前打开的缓冲区。<br>• :b N：切换到编号为 N 的缓冲区。<br>• :split filename：水平分割窗口并打开文件。<br>• :vsplit filename：垂直分割窗口并打开文件。<br>• Ctrl+w 后跟 h/j/k/l：在分割窗口间切换。<br><br>参考资料<br>• Vim 官方文档：<a data-tooltip-position="top" aria-label="https://www.vim.org/docs.php" rel="noopener nofollow" class="external-link" title="Vim documentation" href="https://www.vim.org/docs.php" target="_blank">Vim documentation</a><br>• 菜鸟教程 Vim 教程：<a data-tooltip-position="top" aria-label="https://www.runoob.com/vim/vim-tutorial.html" rel="noopener nofollow" class="external-link" title="菜鸟教程 - Vim 教程" href="https://www.runoob.com/vim/vim-tutorial.html" target="_blank">菜鸟教程 - Vim 教程</a>]]></description><link>vim.html</link><guid isPermaLink="false">vim.md</guid><pubDate>Fri, 02 May 2025 16:55:04 GMT</pubDate></item></channel></rss>